/* automatically generated by rust-bindgen 0.69.5 */

#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(non_snake_case)]

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const HIPBLASLT_VERSION_MAJOR: u32 = 0;
pub const HIPBLASLT_VERSION_MINOR: u32 = 12;
pub const HIPBLASLT_VERSION_PATCH: u32 = 1;
pub const HIP_VERSION_MAJOR: u32 = 6;
pub const HIP_VERSION_MINOR: u32 = 4;
pub const HIP_VERSION_PATCH: u32 = 43483;
pub const HIP_VERSION_GITHASH: &[u8; 10] = b"a187df25c\0";
pub const HIP_VERSION_BUILD_ID: u32 = 0;
pub const HIP_VERSION_BUILD_NAME: &[u8; 1] = b"\0";
pub const HIP_VERSION: u32 = 60443483;
pub const HIP_TRSA_OVERRIDE_FORMAT: u32 = 1;
pub const HIP_TRSF_READ_AS_INTEGER: u32 = 1;
pub const HIP_TRSF_NORMALIZED_COORDINATES: u32 = 2;
pub const HIP_TRSF_SRGB: u32 = 16;
pub const hipTextureType1D: u32 = 1;
pub const hipTextureType2D: u32 = 2;
pub const hipTextureType3D: u32 = 3;
pub const hipTextureTypeCubemap: u32 = 12;
pub const hipTextureType1DLayered: u32 = 241;
pub const hipTextureType2DLayered: u32 = 242;
pub const hipTextureTypeCubemapLayered: u32 = 252;
pub const HIP_IMAGE_OBJECT_SIZE_DWORD: u32 = 12;
pub const HIP_SAMPLER_OBJECT_SIZE_DWORD: u32 = 8;
pub const HIP_SAMPLER_OBJECT_OFFSET_DWORD: u32 = 12;
pub const HIP_TEXTURE_OBJECT_SIZE_DWORD: u32 = 20;
pub const HIP_DEPRECATED_MSG : & [u8 ; 189] = b"This API is marked as deprecated and might not be supported in future releases. For more details please refer https://github.com/ROCm/HIP/blob/develop/docs/reference/deprecated_api_list.md\0" ;
pub const hipIpcMemLazyEnablePeerAccess: u32 = 1;
pub const HIP_IPC_HANDLE_SIZE: u32 = 64;
pub const hipStreamDefault: u32 = 0;
pub const hipStreamNonBlocking: u32 = 1;
pub const hipEventDefault: u32 = 0;
pub const hipEventBlockingSync: u32 = 1;
pub const hipEventDisableTiming: u32 = 2;
pub const hipEventInterprocess: u32 = 4;
pub const hipEventRecordDefault: u32 = 0;
pub const hipEventRecordExternal: u32 = 1;
pub const hipEventDisableSystemFence: u32 = 536870912;
pub const hipEventReleaseToDevice: u32 = 1073741824;
pub const hipEventReleaseToSystem: u32 = 2147483648;
pub const hipHostAllocDefault: u32 = 0;
pub const hipHostMallocDefault: u32 = 0;
pub const hipHostAllocPortable: u32 = 1;
pub const hipHostMallocPortable: u32 = 1;
pub const hipHostAllocMapped: u32 = 2;
pub const hipHostMallocMapped: u32 = 2;
pub const hipHostAllocWriteCombined: u32 = 4;
pub const hipHostMallocWriteCombined: u32 = 4;
pub const hipHostMallocNumaUser: u32 = 536870912;
pub const hipHostMallocCoherent: u32 = 1073741824;
pub const hipHostMallocNonCoherent: u32 = 2147483648;
pub const hipMemAttachGlobal: u32 = 1;
pub const hipMemAttachHost: u32 = 2;
pub const hipMemAttachSingle: u32 = 4;
pub const hipDeviceMallocDefault: u32 = 0;
pub const hipDeviceMallocFinegrained: u32 = 1;
pub const hipMallocSignalMemory: u32 = 2;
pub const hipDeviceMallocUncached: u32 = 3;
pub const hipDeviceMallocContiguous: u32 = 4;
pub const hipHostRegisterDefault: u32 = 0;
pub const hipHostRegisterPortable: u32 = 1;
pub const hipHostRegisterMapped: u32 = 2;
pub const hipHostRegisterIoMemory: u32 = 4;
pub const hipHostRegisterReadOnly: u32 = 8;
pub const hipExtHostRegisterCoarseGrained: u32 = 8;
pub const hipDeviceScheduleAuto: u32 = 0;
pub const hipDeviceScheduleSpin: u32 = 1;
pub const hipDeviceScheduleYield: u32 = 2;
pub const hipDeviceScheduleBlockingSync: u32 = 4;
pub const hipDeviceScheduleMask: u32 = 7;
pub const hipDeviceMapHost: u32 = 8;
pub const hipDeviceLmemResizeToMax: u32 = 16;
pub const hipArrayDefault: u32 = 0;
pub const hipArrayLayered: u32 = 1;
pub const hipArraySurfaceLoadStore: u32 = 2;
pub const hipArrayCubemap: u32 = 4;
pub const hipArrayTextureGather: u32 = 8;
pub const hipOccupancyDefault: u32 = 0;
pub const hipOccupancyDisableCachingOverride: u32 = 1;
pub const hipCooperativeLaunchMultiDeviceNoPreSync: u32 = 1;
pub const hipCooperativeLaunchMultiDeviceNoPostSync: u32 = 2;
pub const hipExtAnyOrderLaunch: u32 = 1;
pub const hipStreamWaitValueGte: u32 = 0;
pub const hipStreamWaitValueEq: u32 = 1;
pub const hipStreamWaitValueAnd: u32 = 2;
pub const hipStreamWaitValueNor: u32 = 3;
pub const hipExternalMemoryDedicated: u32 = 1;
pub const hipGraphKernelNodePortDefault: u32 = 0;
pub const hipGraphKernelNodePortLaunchCompletion: u32 = 2;
pub const hipGraphKernelNodePortProgrammatic: u32 = 1;
#[repr(u32)]
#[non_exhaustive]
#[doc = " \\brief hipblas status codes definition"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipblasStatus_t {
    #[doc = "< Function succeeds"]
    HIPBLAS_STATUS_SUCCESS = 0,
    #[doc = "< HIPBLAS library not initialized"]
    HIPBLAS_STATUS_NOT_INITIALIZED = 1,
    #[doc = "< resource allocation failed"]
    HIPBLAS_STATUS_ALLOC_FAILED = 2,
    #[doc = "< unsupported numerical value was passed to function"]
    HIPBLAS_STATUS_INVALID_VALUE = 3,
    #[doc = "< access to GPU memory space failed"]
    HIPBLAS_STATUS_MAPPING_ERROR = 4,
    #[doc = "< GPU program failed to execute"]
    HIPBLAS_STATUS_EXECUTION_FAILED = 5,
    #[doc = "< an internal HIPBLAS operation failed"]
    HIPBLAS_STATUS_INTERNAL_ERROR = 6,
    #[doc = "< function not implemented"]
    HIPBLAS_STATUS_NOT_SUPPORTED = 7,
    #[doc = "< architecture mismatch"]
    HIPBLAS_STATUS_ARCH_MISMATCH = 8,
    #[doc = "< hipBLAS handle is null pointer"]
    HIPBLAS_STATUS_HANDLE_IS_NULLPTR = 9,
    #[doc = "<  unsupported enum value was passed to function"]
    HIPBLAS_STATUS_INVALID_ENUM = 10,
    #[doc = "<  back-end returned an unsupported status code"]
    HIPBLAS_STATUS_UNKNOWN = 11,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " \\brief Used to specify whether the matrix is to be transposed or not."]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipblasOperation_t {
    #[doc = "<  Operate with the matrix."]
    HIPBLAS_OP_N = 111,
    #[doc = "<  Operate with the transpose of the matrix."]
    HIPBLAS_OP_T = 112,
    #[doc = "< Operate with the conjugate transpose of the matrix."]
    HIPBLAS_OP_C = 113,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " \\brief The compute type to be used. Currently only used with GemmEx with the HIPBLAS_V2 interface.\n         Note that support for compute types is largely dependent on backend."]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipblasComputeType_t {
    #[doc = "< compute will be at least 16-bit precision"]
    HIPBLAS_COMPUTE_16F = 0,
    #[doc = "< compute will be exactly 16-bit precision"]
    HIPBLAS_COMPUTE_16F_PEDANTIC = 1,
    #[doc = "< compute will be at least 32-bit precision"]
    HIPBLAS_COMPUTE_32F = 2,
    #[doc = "< compute will be exactly 32-bit precision"]
    HIPBLAS_COMPUTE_32F_PEDANTIC = 3,
    #[doc = "< 32-bit input can use 16-bit compute"]
    HIPBLAS_COMPUTE_32F_FAST_16F = 4,
    #[doc = "< 32-bit input can is bf16 compute"]
    HIPBLAS_COMPUTE_32F_FAST_16BF = 5,
    HIPBLAS_COMPUTE_32F_FAST_TF32 = 6,
    #[doc = "< compute will be at least 64-bit precision"]
    HIPBLAS_COMPUTE_64F = 7,
    #[doc = "< compute will be exactly 64-bit precision"]
    HIPBLAS_COMPUTE_64F_PEDANTIC = 8,
    #[doc = "< compute will be at least 32-bit integer precision"]
    HIPBLAS_COMPUTE_32I = 9,
    #[doc = "< compute will be exactly 32-bit integer precision"]
    HIPBLAS_COMPUTE_32I_PEDANTIC = 10,
}
#[doc = " \\brief Struct to represent a 16 bit brain floating point number."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hip_bfloat16 {
    pub data: u16,
}
#[test]
fn bindgen_test_layout_hip_bfloat16() {
    const UNINIT: ::std::mem::MaybeUninit<hip_bfloat16> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hip_bfloat16>(),
        2usize,
        concat!("Size of: ", stringify!(hip_bfloat16))
    );
    assert_eq!(
        ::std::mem::align_of::<hip_bfloat16>(),
        2usize,
        concat!("Alignment of ", stringify!(hip_bfloat16))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hip_bfloat16),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8hip_impl8hip_initEv"]
    pub fn hip_impl_hip_init() -> hipError_t;
}
pub type float2 = u64;
pub type double2 = u128;
pub type hipFloatComplex = float2;
pub type hipDoubleComplex = double2;
pub type hipComplex = hipFloatComplex;
#[repr(u32)]
#[non_exhaustive]
#[doc = " hipJitOption"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipJitOption {
    #[doc = "< CUDA Only Maximum registers may be used in a thread,\n< passed to compiler"]
    hipJitOptionMaxRegisters = 0,
    #[doc = "< CUDA Only Number of thread per block"]
    hipJitOptionThreadsPerBlock = 1,
    #[doc = "< CUDA Only Value for total wall clock time"]
    hipJitOptionWallTime = 2,
    #[doc = "< CUDA Only Pointer to the buffer with logged information"]
    hipJitOptionInfoLogBuffer = 3,
    #[doc = "< CUDA Only Size of the buffer in bytes for logged info"]
    hipJitOptionInfoLogBufferSizeBytes = 4,
    #[doc = "< CUDA Only Pointer to the buffer with logged error(s)"]
    hipJitOptionErrorLogBuffer = 5,
    #[doc = "< CUDA Only Size of the buffer in bytes for logged error(s)"]
    hipJitOptionErrorLogBufferSizeBytes = 6,
    #[doc = "< Value of optimization level for generated codes, acceptable options\n< -O0, -O1, -O2, -O3"]
    hipJitOptionOptimizationLevel = 7,
    #[doc = "< CUDA Only The target context, which is the default"]
    hipJitOptionTargetFromContext = 8,
    #[doc = "< CUDA Only JIT target"]
    hipJitOptionTarget = 9,
    #[doc = "< CUDA Only Fallback strategy"]
    hipJitOptionFallbackStrategy = 10,
    #[doc = "< CUDA Only Generate debug information"]
    hipJitOptionGenerateDebugInfo = 11,
    #[doc = "< CUDA Only Generate log verbose"]
    hipJitOptionLogVerbose = 12,
    #[doc = "< CUDA Only Generate line number information"]
    hipJitOptionGenerateLineInfo = 13,
    #[doc = "< CUDA Only Set cache mode"]
    hipJitOptionCacheMode = 14,
    #[doc = "< @deprecated CUDA Only New SM3X option."]
    hipJitOptionSm3xOpt = 15,
    #[doc = "< CUDA Only Set fast compile"]
    hipJitOptionFastCompile = 16,
    #[doc = "< CUDA Only Array of device symbol names to be relocated to the host"]
    hipJitOptionGlobalSymbolNames = 17,
    #[doc = "< CUDA Only Array of host addresses to be relocated to the device"]
    hipJitOptionGlobalSymbolAddresses = 18,
    #[doc = "< CUDA Only Number of symbol count."]
    hipJitOptionGlobalSymbolCount = 19,
    #[doc = "< @deprecated CUDA Only Enable link-time optimization for device code"]
    hipJitOptionLto = 20,
    #[doc = "< @deprecated CUDA Only Set single-precision denormals."]
    hipJitOptionFtz = 21,
    #[doc = "< @deprecated CUDA Only Set single-precision floating-point division\n< and reciprocals"]
    hipJitOptionPrecDiv = 22,
    #[doc = "< @deprecated CUDA Only Set single-precision floating-point square root"]
    hipJitOptionPrecSqrt = 23,
    #[doc = "< @deprecated CUDA Only Enable floating-point multiplies and\n< adds/subtracts operations"]
    hipJitOptionFma = 24,
    #[doc = "< CUDA Only Generates Position Independent code"]
    hipJitOptionPositionIndependentCode = 25,
    #[doc = "< CUDA Only Hints to JIT compiler the minimum number of CTAs frin kernel's\n< grid to be mapped to SM"]
    hipJitOptionMinCTAPerSM = 26,
    #[doc = "< CUDA only Maximum number of threads in a thread block"]
    hipJitOptionMaxThreadsPerBlock = 27,
    #[doc = "< Cuda only Override Directive values"]
    hipJitOptionOverrideDirectiveValues = 28,
    #[doc = "< Number of options"]
    hipJitOptionNumOptions = 29,
    #[doc = "< Hip Only Linker options to be passed on to compiler"]
    hipJitOptionIRtoISAOptExt = 10000,
    #[doc = "< Hip Only Count of linker options to be passed on to compiler"]
    hipJitOptionIRtoISAOptCountExt = 10001,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " hipJitInputType"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipJitInputType {
    #[doc = "< Cuda only Input cubin"]
    hipJitInputCubin = 0,
    #[doc = "< Cuda only Input PTX"]
    hipJitInputPtx = 1,
    #[doc = "< Cuda Only Input FAT Binary"]
    hipJitInputFatBinary = 2,
    #[doc = "< Cuda Only Host Object with embedded device code"]
    hipJitInputObject = 3,
    #[doc = "< Cuda Only Archive of Host Objects with embedded\n< device code"]
    hipJitInputLibrary = 4,
    #[doc = "< @deprecated Cuda only High Level intermediate\n< code for LTO"]
    hipJitInputNvvm = 5,
    #[doc = "< Count of Legacy Input Types"]
    hipJitNumLegacyInputTypes = 6,
    #[doc = "< HIP Only LLVM Bitcode or IR assembly"]
    hipJitInputLLVMBitcode = 100,
    #[doc = "< HIP Only LLVM Clang Bundled Code"]
    hipJitInputLLVMBundledBitcode = 101,
    #[doc = "< HIP Only LLVM Archive of Bundled Bitcode"]
    hipJitInputLLVMArchivesOfBundledBitcode = 102,
    #[doc = "< HIP Only SPIRV Code Object"]
    hipJitInputSpirv = 103,
    #[doc = "< Count of Input Types"]
    hipJitNumInputTypes = 10,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " hipJitCacheMode"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipJitCacheMode {
    hipJitCacheOptionNone = 0,
    hipJitCacheOptionCG = 1,
    hipJitCacheOptionCA = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " hipJitFallback"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipJitFallback {
    hipJitPreferPTX = 0,
    hipJitPreferBinary = 1,
}
pub const HIP_SUCCESS: _bindgen_ty_55 = 0;
pub const HIP_ERROR_INVALID_VALUE: _bindgen_ty_55 = 1;
pub const HIP_ERROR_NOT_INITIALIZED: _bindgen_ty_55 = 2;
pub const HIP_ERROR_LAUNCH_OUT_OF_RESOURCES: _bindgen_ty_55 = 3;
pub type _bindgen_ty_55 = ::libc::c_uint;
#[doc = " @defgroup GlobalDefs Global enum and defines\n @{\n\n/\n/**\n hipDeviceArch_t\n"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipDeviceArch_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub __bindgen_padding_0: u8,
}
#[test]
fn bindgen_test_layout_hipDeviceArch_t() {
    assert_eq!(
        ::std::mem::size_of::<hipDeviceArch_t>(),
        4usize,
        concat!("Size of: ", stringify!(hipDeviceArch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hipDeviceArch_t>(),
        4usize,
        concat!("Alignment of ", stringify!(hipDeviceArch_t))
    );
}
impl hipDeviceArch_t {
    #[inline]
    pub fn hasGlobalInt32Atomics(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasGlobalInt32Atomics(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasGlobalFloatAtomicExch(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasGlobalFloatAtomicExch(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasSharedInt32Atomics(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasSharedInt32Atomics(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasSharedFloatAtomicExch(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasSharedFloatAtomicExch(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasFloatAtomicAdd(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasFloatAtomicAdd(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasGlobalInt64Atomics(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasGlobalInt64Atomics(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasSharedInt64Atomics(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasSharedInt64Atomics(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasDoubles(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasDoubles(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasWarpVote(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasWarpVote(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasWarpBallot(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasWarpBallot(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasWarpShuffle(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasWarpShuffle(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasFunnelShift(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasFunnelShift(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasThreadFenceSystem(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasThreadFenceSystem(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasSyncThreadsExt(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasSyncThreadsExt(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasSurfaceFuncs(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasSurfaceFuncs(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has3dGrid(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has3dGrid(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasDynamicParallelism(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasDynamicParallelism(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        hasGlobalInt32Atomics: ::libc::c_uint,
        hasGlobalFloatAtomicExch: ::libc::c_uint,
        hasSharedInt32Atomics: ::libc::c_uint,
        hasSharedFloatAtomicExch: ::libc::c_uint,
        hasFloatAtomicAdd: ::libc::c_uint,
        hasGlobalInt64Atomics: ::libc::c_uint,
        hasSharedInt64Atomics: ::libc::c_uint,
        hasDoubles: ::libc::c_uint,
        hasWarpVote: ::libc::c_uint,
        hasWarpBallot: ::libc::c_uint,
        hasWarpShuffle: ::libc::c_uint,
        hasFunnelShift: ::libc::c_uint,
        hasThreadFenceSystem: ::libc::c_uint,
        hasSyncThreadsExt: ::libc::c_uint,
        hasSurfaceFuncs: ::libc::c_uint,
        has3dGrid: ::libc::c_uint,
        hasDynamicParallelism: ::libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let hasGlobalInt32Atomics: u32 =
                unsafe { ::std::mem::transmute(hasGlobalInt32Atomics) };
            hasGlobalInt32Atomics as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let hasGlobalFloatAtomicExch: u32 =
                unsafe { ::std::mem::transmute(hasGlobalFloatAtomicExch) };
            hasGlobalFloatAtomicExch as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let hasSharedInt32Atomics: u32 =
                unsafe { ::std::mem::transmute(hasSharedInt32Atomics) };
            hasSharedInt32Atomics as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let hasSharedFloatAtomicExch: u32 =
                unsafe { ::std::mem::transmute(hasSharedFloatAtomicExch) };
            hasSharedFloatAtomicExch as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let hasFloatAtomicAdd: u32 = unsafe { ::std::mem::transmute(hasFloatAtomicAdd) };
            hasFloatAtomicAdd as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let hasGlobalInt64Atomics: u32 =
                unsafe { ::std::mem::transmute(hasGlobalInt64Atomics) };
            hasGlobalInt64Atomics as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let hasSharedInt64Atomics: u32 =
                unsafe { ::std::mem::transmute(hasSharedInt64Atomics) };
            hasSharedInt64Atomics as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let hasDoubles: u32 = unsafe { ::std::mem::transmute(hasDoubles) };
            hasDoubles as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let hasWarpVote: u32 = unsafe { ::std::mem::transmute(hasWarpVote) };
            hasWarpVote as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let hasWarpBallot: u32 = unsafe { ::std::mem::transmute(hasWarpBallot) };
            hasWarpBallot as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let hasWarpShuffle: u32 = unsafe { ::std::mem::transmute(hasWarpShuffle) };
            hasWarpShuffle as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let hasFunnelShift: u32 = unsafe { ::std::mem::transmute(hasFunnelShift) };
            hasFunnelShift as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let hasThreadFenceSystem: u32 = unsafe { ::std::mem::transmute(hasThreadFenceSystem) };
            hasThreadFenceSystem as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let hasSyncThreadsExt: u32 = unsafe { ::std::mem::transmute(hasSyncThreadsExt) };
            hasSyncThreadsExt as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let hasSurfaceFuncs: u32 = unsafe { ::std::mem::transmute(hasSurfaceFuncs) };
            hasSurfaceFuncs as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let has3dGrid: u32 = unsafe { ::std::mem::transmute(has3dGrid) };
            has3dGrid as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let hasDynamicParallelism: u32 =
                unsafe { ::std::mem::transmute(hasDynamicParallelism) };
            hasDynamicParallelism as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipUUID_t {
    pub bytes: [::libc::c_char; 16usize],
}
#[test]
fn bindgen_test_layout_hipUUID_t() {
    const UNINIT: ::std::mem::MaybeUninit<hipUUID_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipUUID_t>(),
        16usize,
        concat!("Size of: ", stringify!(hipUUID_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hipUUID_t>(),
        1usize,
        concat!("Alignment of ", stringify!(hipUUID_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipUUID_t),
            "::",
            stringify!(bytes)
        )
    );
}
pub type hipUUID = hipUUID_t;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipDeviceProp_tR0600 {
    #[doc = "< Device name."]
    pub name: [::libc::c_char; 256usize],
    #[doc = "< UUID of a device"]
    pub uuid: hipUUID,
    #[doc = "< 8-byte unique identifier. Only valid on windows"]
    pub luid: [::libc::c_char; 8usize],
    #[doc = "< LUID node mask"]
    pub luidDeviceNodeMask: ::libc::c_uint,
    #[doc = "< Size of global memory region (in bytes)."]
    pub totalGlobalMem: usize,
    #[doc = "< Size of shared memory per block (in bytes)."]
    pub sharedMemPerBlock: usize,
    #[doc = "< Registers per block."]
    pub regsPerBlock: ::libc::c_int,
    #[doc = "< Warp size."]
    pub warpSize: ::libc::c_int,
    #[doc = "< Maximum pitch in bytes allowed by memory copies\n< pitched memory"]
    pub memPitch: usize,
    #[doc = "< Max work items per work group or workgroup max size."]
    pub maxThreadsPerBlock: ::libc::c_int,
    #[doc = "< Max number of threads in each dimension (XYZ) of a block."]
    pub maxThreadsDim: [::libc::c_int; 3usize],
    #[doc = "< Max grid dimensions (XYZ)."]
    pub maxGridSize: [::libc::c_int; 3usize],
    #[doc = "< Max clock frequency of the multiProcessors in khz."]
    pub clockRate: ::libc::c_int,
    #[doc = "< Size of shared constant memory region on the device\n< (in bytes)."]
    pub totalConstMem: usize,
    #[doc = "< Major compute capability.  On HCC, this is an approximation and features may\n< differ from CUDA CC.  See the arch feature flags for portable ways to query\n< feature caps."]
    pub major: ::libc::c_int,
    #[doc = "< Minor compute capability.  On HCC, this is an approximation and features may\n< differ from CUDA CC.  See the arch feature flags for portable ways to query\n< feature caps."]
    pub minor: ::libc::c_int,
    #[doc = "< Alignment requirement for textures"]
    pub textureAlignment: usize,
    #[doc = "< Pitch alignment requirement for texture references bound to"]
    pub texturePitchAlignment: usize,
    #[doc = "< Deprecated. Use asyncEngineCount instead"]
    pub deviceOverlap: ::libc::c_int,
    #[doc = "< Number of multi-processors (compute units)."]
    pub multiProcessorCount: ::libc::c_int,
    #[doc = "< Run time limit for kernels executed on the device"]
    pub kernelExecTimeoutEnabled: ::libc::c_int,
    #[doc = "< APU vs dGPU"]
    pub integrated: ::libc::c_int,
    #[doc = "< Check whether HIP can map host memory"]
    pub canMapHostMemory: ::libc::c_int,
    #[doc = "< Compute mode."]
    pub computeMode: ::libc::c_int,
    #[doc = "< Maximum number of elements in 1D images"]
    pub maxTexture1D: ::libc::c_int,
    #[doc = "< Maximum 1D mipmap texture size"]
    pub maxTexture1DMipmap: ::libc::c_int,
    #[doc = "< Maximum size for 1D textures bound to linear memory"]
    pub maxTexture1DLinear: ::libc::c_int,
    #[doc = "< Maximum dimensions (width, height) of 2D images, in image elements"]
    pub maxTexture2D: [::libc::c_int; 2usize],
    #[doc = "< Maximum number of elements in 2D array mipmap of images"]
    pub maxTexture2DMipmap: [::libc::c_int; 2usize],
    #[doc = "< Maximum 2D tex dimensions if tex are bound to pitched memory"]
    pub maxTexture2DLinear: [::libc::c_int; 3usize],
    #[doc = "< Maximum 2D tex dimensions if gather has to be performed"]
    pub maxTexture2DGather: [::libc::c_int; 2usize],
    #[doc = "< Maximum dimensions (width, height, depth) of 3D images, in image\n< elements"]
    pub maxTexture3D: [::libc::c_int; 3usize],
    #[doc = "< Maximum alternate 3D texture dims"]
    pub maxTexture3DAlt: [::libc::c_int; 3usize],
    #[doc = "< Maximum cubemap texture dims"]
    pub maxTextureCubemap: ::libc::c_int,
    #[doc = "< Maximum number of elements in 1D array images"]
    pub maxTexture1DLayered: [::libc::c_int; 2usize],
    #[doc = "< Maximum number of elements in 2D array images"]
    pub maxTexture2DLayered: [::libc::c_int; 3usize],
    #[doc = "< Maximum cubemaps layered texture dims"]
    pub maxTextureCubemapLayered: [::libc::c_int; 2usize],
    #[doc = "< Maximum 1D surface size"]
    pub maxSurface1D: ::libc::c_int,
    #[doc = "< Maximum 2D surface size"]
    pub maxSurface2D: [::libc::c_int; 2usize],
    #[doc = "< Maximum 3D surface size"]
    pub maxSurface3D: [::libc::c_int; 3usize],
    #[doc = "< Maximum 1D layered surface size"]
    pub maxSurface1DLayered: [::libc::c_int; 2usize],
    #[doc = "< Maximum 2D layared surface size"]
    pub maxSurface2DLayered: [::libc::c_int; 3usize],
    #[doc = "< Maximum cubemap surface size"]
    pub maxSurfaceCubemap: ::libc::c_int,
    #[doc = "< Maximum cubemap layered surface size"]
    pub maxSurfaceCubemapLayered: [::libc::c_int; 2usize],
    #[doc = "< Alignment requirement for surface"]
    pub surfaceAlignment: usize,
    #[doc = "< Device can possibly execute multiple kernels concurrently."]
    pub concurrentKernels: ::libc::c_int,
    #[doc = "< Device has ECC support enabled"]
    pub ECCEnabled: ::libc::c_int,
    #[doc = "< PCI Bus ID."]
    pub pciBusID: ::libc::c_int,
    #[doc = "< PCI Device ID."]
    pub pciDeviceID: ::libc::c_int,
    #[doc = "< PCI Domain ID"]
    pub pciDomainID: ::libc::c_int,
    #[doc = "< 1:If device is Tesla device using TCC driver, else 0"]
    pub tccDriver: ::libc::c_int,
    #[doc = "< Number of async engines"]
    pub asyncEngineCount: ::libc::c_int,
    #[doc = "< Does device and host share unified address space"]
    pub unifiedAddressing: ::libc::c_int,
    #[doc = "< Max global memory clock frequency in khz."]
    pub memoryClockRate: ::libc::c_int,
    #[doc = "< Global memory bus width in bits."]
    pub memoryBusWidth: ::libc::c_int,
    #[doc = "< L2 cache size."]
    pub l2CacheSize: ::libc::c_int,
    #[doc = "< Device's max L2 persisting lines in bytes"]
    pub persistingL2CacheMaxSize: ::libc::c_int,
    #[doc = "< Maximum resident threads per multi-processor."]
    pub maxThreadsPerMultiProcessor: ::libc::c_int,
    #[doc = "< Device supports stream priority"]
    pub streamPrioritiesSupported: ::libc::c_int,
    #[doc = "< Indicates globals are cached in L1"]
    pub globalL1CacheSupported: ::libc::c_int,
    #[doc = "< Locals are cahced in L1"]
    pub localL1CacheSupported: ::libc::c_int,
    #[doc = "< Amount of shared memory available per multiprocessor."]
    pub sharedMemPerMultiprocessor: usize,
    #[doc = "< registers available per multiprocessor"]
    pub regsPerMultiprocessor: ::libc::c_int,
    #[doc = "< Device supports allocating managed memory on this system"]
    pub managedMemory: ::libc::c_int,
    #[doc = "< 1 if device is on a multi-GPU board, 0 if not."]
    pub isMultiGpuBoard: ::libc::c_int,
    #[doc = "< Unique identifier for a group of devices on same multiboard GPU"]
    pub multiGpuBoardGroupID: ::libc::c_int,
    #[doc = "< Link between host and device supports native atomics"]
    pub hostNativeAtomicSupported: ::libc::c_int,
    #[doc = "< Deprecated. CUDA only."]
    pub singleToDoublePrecisionPerfRatio: ::libc::c_int,
    #[doc = "< Device supports coherently accessing pageable memory\n< without calling hipHostRegister on it"]
    pub pageableMemoryAccess: ::libc::c_int,
    #[doc = "< Device can coherently access managed memory concurrently with\n< the CPU"]
    pub concurrentManagedAccess: ::libc::c_int,
    #[doc = "< Is compute preemption supported on the device"]
    pub computePreemptionSupported: ::libc::c_int,
    #[doc = "< Device can access host registered memory with same\n< address as the host"]
    pub canUseHostPointerForRegisteredMem: ::libc::c_int,
    #[doc = "< HIP device supports cooperative launch"]
    pub cooperativeLaunch: ::libc::c_int,
    #[doc = "< HIP device supports cooperative launch on multiple\n< devices"]
    pub cooperativeMultiDeviceLaunch: ::libc::c_int,
    #[doc = "< Per device m ax shared mem per block usable by special opt in"]
    pub sharedMemPerBlockOptin: usize,
    #[doc = "< Device accesses pageable memory via the host's\n< page tables"]
    pub pageableMemoryAccessUsesHostPageTables: ::libc::c_int,
    #[doc = "< Host can directly access managed memory on the device\n< without migration"]
    pub directManagedMemAccessFromHost: ::libc::c_int,
    #[doc = "< Max number of blocks on CU"]
    pub maxBlocksPerMultiProcessor: ::libc::c_int,
    #[doc = "< Max value of access policy window"]
    pub accessPolicyMaxWindowSize: ::libc::c_int,
    #[doc = "< Shared memory reserved by driver per block"]
    pub reservedSharedMemPerBlock: usize,
    #[doc = "< Device supports hipHostRegister"]
    pub hostRegisterSupported: ::libc::c_int,
    #[doc = "< Indicates if device supports sparse hip arrays"]
    pub sparseHipArraySupported: ::libc::c_int,
    #[doc = "< Device supports using the hipHostRegisterReadOnly flag\n< with hipHostRegistger"]
    pub hostRegisterReadOnlySupported: ::libc::c_int,
    #[doc = "< Indicates external timeline semaphore support"]
    pub timelineSemaphoreInteropSupported: ::libc::c_int,
    #[doc = "< Indicates if device supports hipMallocAsync and hipMemPool APIs"]
    pub memoryPoolsSupported: ::libc::c_int,
    #[doc = "< Indicates device support of RDMA APIs"]
    pub gpuDirectRDMASupported: ::libc::c_int,
    #[doc = "< Bitmask to be interpreted according to\n< hipFlushGPUDirectRDMAWritesOptions"]
    pub gpuDirectRDMAFlushWritesOptions: ::libc::c_uint,
    #[doc = "< value of hipGPUDirectRDMAWritesOrdering"]
    pub gpuDirectRDMAWritesOrdering: ::libc::c_int,
    #[doc = "< Bitmask of handle types support with mempool based IPC"]
    pub memoryPoolSupportedHandleTypes: ::libc::c_uint,
    #[doc = "< Device supports deferred mapping HIP arrays and HIP\n< mipmapped arrays"]
    pub deferredMappingHipArraySupported: ::libc::c_int,
    #[doc = "< Device supports IPC events"]
    pub ipcEventSupported: ::libc::c_int,
    #[doc = "< Device supports cluster launch"]
    pub clusterLaunch: ::libc::c_int,
    #[doc = "< Indicates device supports unified function pointers"]
    pub unifiedFunctionPointers: ::libc::c_int,
    #[doc = "< CUDA Reserved."]
    pub reserved: [::libc::c_int; 63usize],
    #[doc = "< Reserved for adding new entries for HIP/CUDA."]
    pub hipReserved: [::libc::c_int; 32usize],
    #[doc = "< AMD GCN Arch Name. HIP Only."]
    pub gcnArchName: [::libc::c_char; 256usize],
    #[doc = "< Maximum Shared Memory Per CU. HIP Only."]
    pub maxSharedMemoryPerMultiProcessor: usize,
    #[doc = "< Frequency in khz of the timer used by the device-side \"clock*\"\n< instructions.  New for HIP."]
    pub clockInstructionRate: ::libc::c_int,
    #[doc = "< Architectural feature flags.  New for HIP."]
    pub arch: hipDeviceArch_t,
    #[doc = "< Addres of HDP_MEM_COHERENCY_FLUSH_CNTL register"]
    pub hdpMemFlushCntl: *mut ::libc::c_uint,
    #[doc = "< Addres of HDP_REG_COHERENCY_FLUSH_CNTL register"]
    pub hdpRegFlushCntl: *mut ::libc::c_uint,
    #[doc = "< HIP device supports cooperative launch on\n< multiple"]
    pub cooperativeMultiDeviceUnmatchedFunc: ::libc::c_int,
    #[doc = "< HIP device supports cooperative launch on\n< multiple"]
    pub cooperativeMultiDeviceUnmatchedGridDim: ::libc::c_int,
    #[doc = "< HIP device supports cooperative launch on\n< multiple"]
    pub cooperativeMultiDeviceUnmatchedBlockDim: ::libc::c_int,
    #[doc = "< HIP device supports cooperative launch on\n< multiple"]
    pub cooperativeMultiDeviceUnmatchedSharedMem: ::libc::c_int,
    #[doc = "< 1: if it is a large PCI bar device, else 0"]
    pub isLargeBar: ::libc::c_int,
    #[doc = "< Revision of the GPU in this device"]
    pub asicRevision: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_hipDeviceProp_tR0600() {
    const UNINIT: ::std::mem::MaybeUninit<hipDeviceProp_tR0600> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipDeviceProp_tR0600>(),
        1472usize,
        concat!("Size of: ", stringify!(hipDeviceProp_tR0600))
    );
    assert_eq!(
        ::std::mem::align_of::<hipDeviceProp_tR0600>(),
        8usize,
        concat!("Alignment of ", stringify!(hipDeviceProp_tR0600))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uuid) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).luid) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(luid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).luidDeviceNodeMask) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(luidDeviceNodeMask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).totalGlobalMem) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(totalGlobalMem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sharedMemPerBlock) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(sharedMemPerBlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).regsPerBlock) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(regsPerBlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).warpSize) as usize - ptr as usize },
        308usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(warpSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memPitch) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(memPitch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxThreadsPerBlock) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(maxThreadsPerBlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxThreadsDim) as usize - ptr as usize },
        324usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(maxThreadsDim)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxGridSize) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(maxGridSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clockRate) as usize - ptr as usize },
        348usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(clockRate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).totalConstMem) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(totalConstMem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(major)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minor) as usize - ptr as usize },
        364usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(minor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).textureAlignment) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(textureAlignment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).texturePitchAlignment) as usize - ptr as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(texturePitchAlignment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deviceOverlap) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(deviceOverlap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).multiProcessorCount) as usize - ptr as usize },
        388usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(multiProcessorCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kernelExecTimeoutEnabled) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(kernelExecTimeoutEnabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).integrated) as usize - ptr as usize },
        396usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(integrated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).canMapHostMemory) as usize - ptr as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(canMapHostMemory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).computeMode) as usize - ptr as usize },
        404usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(computeMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxTexture1D) as usize - ptr as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(maxTexture1D)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxTexture1DMipmap) as usize - ptr as usize },
        412usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(maxTexture1DMipmap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxTexture1DLinear) as usize - ptr as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(maxTexture1DLinear)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxTexture2D) as usize - ptr as usize },
        420usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(maxTexture2D)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxTexture2DMipmap) as usize - ptr as usize },
        428usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(maxTexture2DMipmap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxTexture2DLinear) as usize - ptr as usize },
        436usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(maxTexture2DLinear)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxTexture2DGather) as usize - ptr as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(maxTexture2DGather)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxTexture3D) as usize - ptr as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(maxTexture3D)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxTexture3DAlt) as usize - ptr as usize },
        468usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(maxTexture3DAlt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxTextureCubemap) as usize - ptr as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(maxTextureCubemap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxTexture1DLayered) as usize - ptr as usize },
        484usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(maxTexture1DLayered)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxTexture2DLayered) as usize - ptr as usize },
        492usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(maxTexture2DLayered)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxTextureCubemapLayered) as usize - ptr as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(maxTextureCubemapLayered)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxSurface1D) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(maxSurface1D)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxSurface2D) as usize - ptr as usize },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(maxSurface2D)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxSurface3D) as usize - ptr as usize },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(maxSurface3D)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxSurface1DLayered) as usize - ptr as usize },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(maxSurface1DLayered)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxSurface2DLayered) as usize - ptr as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(maxSurface2DLayered)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxSurfaceCubemap) as usize - ptr as usize },
        556usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(maxSurfaceCubemap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxSurfaceCubemapLayered) as usize - ptr as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(maxSurfaceCubemapLayered)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).surfaceAlignment) as usize - ptr as usize },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(surfaceAlignment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).concurrentKernels) as usize - ptr as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(concurrentKernels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ECCEnabled) as usize - ptr as usize },
        580usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(ECCEnabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pciBusID) as usize - ptr as usize },
        584usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(pciBusID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pciDeviceID) as usize - ptr as usize },
        588usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(pciDeviceID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pciDomainID) as usize - ptr as usize },
        592usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(pciDomainID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tccDriver) as usize - ptr as usize },
        596usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(tccDriver)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).asyncEngineCount) as usize - ptr as usize },
        600usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(asyncEngineCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unifiedAddressing) as usize - ptr as usize },
        604usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(unifiedAddressing)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memoryClockRate) as usize - ptr as usize },
        608usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(memoryClockRate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memoryBusWidth) as usize - ptr as usize },
        612usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(memoryBusWidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l2CacheSize) as usize - ptr as usize },
        616usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(l2CacheSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).persistingL2CacheMaxSize) as usize - ptr as usize },
        620usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(persistingL2CacheMaxSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxThreadsPerMultiProcessor) as usize - ptr as usize },
        624usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(maxThreadsPerMultiProcessor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).streamPrioritiesSupported) as usize - ptr as usize },
        628usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(streamPrioritiesSupported)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).globalL1CacheSupported) as usize - ptr as usize },
        632usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(globalL1CacheSupported)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).localL1CacheSupported) as usize - ptr as usize },
        636usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(localL1CacheSupported)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sharedMemPerMultiprocessor) as usize - ptr as usize },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(sharedMemPerMultiprocessor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).regsPerMultiprocessor) as usize - ptr as usize },
        648usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(regsPerMultiprocessor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).managedMemory) as usize - ptr as usize },
        652usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(managedMemory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isMultiGpuBoard) as usize - ptr as usize },
        656usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(isMultiGpuBoard)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).multiGpuBoardGroupID) as usize - ptr as usize },
        660usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(multiGpuBoardGroupID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hostNativeAtomicSupported) as usize - ptr as usize },
        664usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(hostNativeAtomicSupported)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).singleToDoublePrecisionPerfRatio) as usize - ptr as usize
        },
        668usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(singleToDoublePrecisionPerfRatio)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pageableMemoryAccess) as usize - ptr as usize },
        672usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(pageableMemoryAccess)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).concurrentManagedAccess) as usize - ptr as usize },
        676usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(concurrentManagedAccess)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).computePreemptionSupported) as usize - ptr as usize },
        680usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(computePreemptionSupported)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).canUseHostPointerForRegisteredMem) as usize - ptr as usize
        },
        684usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(canUseHostPointerForRegisteredMem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cooperativeLaunch) as usize - ptr as usize },
        688usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(cooperativeLaunch)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).cooperativeMultiDeviceLaunch) as usize - ptr as usize
        },
        692usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(cooperativeMultiDeviceLaunch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sharedMemPerBlockOptin) as usize - ptr as usize },
        696usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(sharedMemPerBlockOptin)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).pageableMemoryAccessUsesHostPageTables) as usize
                - ptr as usize
        },
        704usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(pageableMemoryAccessUsesHostPageTables)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).directManagedMemAccessFromHost) as usize - ptr as usize
        },
        708usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(directManagedMemAccessFromHost)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxBlocksPerMultiProcessor) as usize - ptr as usize },
        712usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(maxBlocksPerMultiProcessor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).accessPolicyMaxWindowSize) as usize - ptr as usize },
        716usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(accessPolicyMaxWindowSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reservedSharedMemPerBlock) as usize - ptr as usize },
        720usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(reservedSharedMemPerBlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hostRegisterSupported) as usize - ptr as usize },
        728usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(hostRegisterSupported)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sparseHipArraySupported) as usize - ptr as usize },
        732usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(sparseHipArraySupported)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).hostRegisterReadOnlySupported) as usize - ptr as usize
        },
        736usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(hostRegisterReadOnlySupported)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).timelineSemaphoreInteropSupported) as usize - ptr as usize
        },
        740usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(timelineSemaphoreInteropSupported)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memoryPoolsSupported) as usize - ptr as usize },
        744usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(memoryPoolsSupported)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpuDirectRDMASupported) as usize - ptr as usize },
        748usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(gpuDirectRDMASupported)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).gpuDirectRDMAFlushWritesOptions) as usize - ptr as usize
        },
        752usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(gpuDirectRDMAFlushWritesOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpuDirectRDMAWritesOrdering) as usize - ptr as usize },
        756usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(gpuDirectRDMAWritesOrdering)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).memoryPoolSupportedHandleTypes) as usize - ptr as usize
        },
        760usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(memoryPoolSupportedHandleTypes)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).deferredMappingHipArraySupported) as usize - ptr as usize
        },
        764usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(deferredMappingHipArraySupported)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipcEventSupported) as usize - ptr as usize },
        768usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(ipcEventSupported)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clusterLaunch) as usize - ptr as usize },
        772usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(clusterLaunch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unifiedFunctionPointers) as usize - ptr as usize },
        776usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(unifiedFunctionPointers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        780usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hipReserved) as usize - ptr as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(hipReserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gcnArchName) as usize - ptr as usize },
        1160usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(gcnArchName)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).maxSharedMemoryPerMultiProcessor) as usize - ptr as usize
        },
        1416usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(maxSharedMemoryPerMultiProcessor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clockInstructionRate) as usize - ptr as usize },
        1424usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(clockInstructionRate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arch) as usize - ptr as usize },
        1428usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(arch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdpMemFlushCntl) as usize - ptr as usize },
        1432usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(hdpMemFlushCntl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdpRegFlushCntl) as usize - ptr as usize },
        1440usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(hdpRegFlushCntl)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).cooperativeMultiDeviceUnmatchedFunc) as usize - ptr as usize
        },
        1448usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(cooperativeMultiDeviceUnmatchedFunc)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).cooperativeMultiDeviceUnmatchedGridDim) as usize
                - ptr as usize
        },
        1452usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(cooperativeMultiDeviceUnmatchedGridDim)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).cooperativeMultiDeviceUnmatchedBlockDim) as usize
                - ptr as usize
        },
        1456usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(cooperativeMultiDeviceUnmatchedBlockDim)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).cooperativeMultiDeviceUnmatchedSharedMem) as usize
                - ptr as usize
        },
        1460usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(cooperativeMultiDeviceUnmatchedSharedMem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isLargeBar) as usize - ptr as usize },
        1464usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(isLargeBar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).asicRevision) as usize - ptr as usize },
        1468usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_tR0600),
            "::",
            stringify!(asicRevision)
        )
    );
}
impl Default for hipDeviceProp_tR0600 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " hipMemoryType (for pointer attributes)\n\n @note hipMemoryType enum values are combination of cudaMemoryType and cuMemoryType and AMD specific enum values.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipMemoryType {
    #[doc = "< Unregistered memory"]
    hipMemoryTypeUnregistered = 0,
    #[doc = "< Memory is physically located on host"]
    hipMemoryTypeHost = 1,
    #[doc = "< Memory is physically located on device. (see deviceId for\n< specific device)"]
    hipMemoryTypeDevice = 2,
    #[doc = "< Managed memory, automaticallly managed by the unified\n< memory system\n< place holder for new values."]
    hipMemoryTypeManaged = 3,
    #[doc = "< Array memory, physically located on device. (see deviceId for\n< specific device)"]
    hipMemoryTypeArray = 10,
    #[doc = "< unified address space"]
    hipMemoryTypeUnified = 11,
}
#[doc = " Pointer attributes"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipPointerAttribute_t {
    pub type_: hipMemoryType,
    pub device: ::libc::c_int,
    pub devicePointer: *mut ::libc::c_void,
    pub hostPointer: *mut ::libc::c_void,
    pub isManaged: ::libc::c_int,
    pub allocationFlags: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_hipPointerAttribute_t() {
    const UNINIT: ::std::mem::MaybeUninit<hipPointerAttribute_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipPointerAttribute_t>(),
        32usize,
        concat!("Size of: ", stringify!(hipPointerAttribute_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hipPointerAttribute_t>(),
        8usize,
        concat!("Alignment of ", stringify!(hipPointerAttribute_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipPointerAttribute_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).device) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hipPointerAttribute_t),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).devicePointer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipPointerAttribute_t),
            "::",
            stringify!(devicePointer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hostPointer) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hipPointerAttribute_t),
            "::",
            stringify!(hostPointer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isManaged) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hipPointerAttribute_t),
            "::",
            stringify!(isManaged)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocationFlags) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(hipPointerAttribute_t),
            "::",
            stringify!(allocationFlags)
        )
    );
}
impl Default for hipPointerAttribute_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl hipError_t {
    pub const hipErrorMemoryAllocation: hipError_t = hipError_t::hipErrorOutOfMemory;
}
impl hipError_t {
    pub const hipErrorInitializationError: hipError_t = hipError_t::hipErrorNotInitialized;
}
impl hipError_t {
    pub const hipErrorMapBufferObjectFailed: hipError_t = hipError_t::hipErrorMapFailed;
}
impl hipError_t {
    pub const hipErrorInvalidResourceHandle: hipError_t = hipError_t::hipErrorInvalidHandle;
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " HIP error type\n"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipError_t {
    #[doc = "< Successful completion."]
    hipSuccess = 0,
    #[doc = "< One or more of the parameters passed to the API call is NULL\n< or not in an acceptable range."]
    hipErrorInvalidValue = 1,
    #[doc = "< out of memory range."]
    hipErrorOutOfMemory = 2,
    #[doc = "< Invalid not initialized"]
    hipErrorNotInitialized = 3,
    #[doc = "< Deinitialized"]
    hipErrorDeinitialized = 4,
    hipErrorProfilerDisabled = 5,
    hipErrorProfilerNotInitialized = 6,
    hipErrorProfilerAlreadyStarted = 7,
    hipErrorProfilerAlreadyStopped = 8,
    #[doc = "< Invalide configuration"]
    hipErrorInvalidConfiguration = 9,
    #[doc = "< Invalid pitch value"]
    hipErrorInvalidPitchValue = 12,
    #[doc = "< Invalid symbol"]
    hipErrorInvalidSymbol = 13,
    #[doc = "< Invalid Device Pointer"]
    hipErrorInvalidDevicePointer = 17,
    #[doc = "< Invalid memory copy direction"]
    hipErrorInvalidMemcpyDirection = 21,
    hipErrorInsufficientDriver = 35,
    hipErrorMissingConfiguration = 52,
    hipErrorPriorLaunchFailure = 53,
    #[doc = "< Invalid device function"]
    hipErrorInvalidDeviceFunction = 98,
    #[doc = "< Call to hipGetDeviceCount returned 0 devices"]
    hipErrorNoDevice = 100,
    #[doc = "< DeviceID must be in range from 0 to compute-devices."]
    hipErrorInvalidDevice = 101,
    #[doc = "< Invalid image"]
    hipErrorInvalidImage = 200,
    #[doc = "< Produced when input context is invalid."]
    hipErrorInvalidContext = 201,
    hipErrorContextAlreadyCurrent = 202,
    hipErrorMapFailed = 205,
    hipErrorUnmapFailed = 206,
    hipErrorArrayIsMapped = 207,
    hipErrorAlreadyMapped = 208,
    hipErrorNoBinaryForGpu = 209,
    hipErrorAlreadyAcquired = 210,
    hipErrorNotMapped = 211,
    hipErrorNotMappedAsArray = 212,
    hipErrorNotMappedAsPointer = 213,
    hipErrorECCNotCorrectable = 214,
    #[doc = "< Unsupported limit"]
    hipErrorUnsupportedLimit = 215,
    #[doc = "< The context is already in use"]
    hipErrorContextAlreadyInUse = 216,
    hipErrorPeerAccessUnsupported = 217,
    #[doc = "< In CUDA DRV, it is CUDA_ERROR_INVALID_PTX"]
    hipErrorInvalidKernelFile = 218,
    hipErrorInvalidGraphicsContext = 219,
    #[doc = "< Invalid source."]
    hipErrorInvalidSource = 300,
    #[doc = "< the file is not found."]
    hipErrorFileNotFound = 301,
    hipErrorSharedObjectSymbolNotFound = 302,
    #[doc = "< Failed to initialize shared object."]
    hipErrorSharedObjectInitFailed = 303,
    #[doc = "< Not the correct operating system"]
    hipErrorOperatingSystem = 304,
    #[doc = "< Invalide handle"]
    hipErrorInvalidHandle = 400,
    #[doc = "< Resource required is not in a valid state to perform operation."]
    hipErrorIllegalState = 401,
    #[doc = "< Not found"]
    hipErrorNotFound = 500,
    #[doc = "< Indicates that asynchronous operations enqueued earlier are not\n< ready.  This is not actually an error, but is used to distinguish\n< from hipSuccess (which indicates completion).  APIs that return\n< this error include hipEventQuery and hipStreamQuery."]
    hipErrorNotReady = 600,
    hipErrorIllegalAddress = 700,
    #[doc = "< Out of resources error."]
    hipErrorLaunchOutOfResources = 701,
    #[doc = "< Timeout for the launch."]
    hipErrorLaunchTimeOut = 702,
    #[doc = "< Peer access was already enabled from the current\n< device."]
    hipErrorPeerAccessAlreadyEnabled = 704,
    #[doc = "< Peer access was never enabled from the current device."]
    hipErrorPeerAccessNotEnabled = 705,
    #[doc = "< The process is active."]
    hipErrorSetOnActiveProcess = 708,
    #[doc = "< The context is already destroyed"]
    hipErrorContextIsDestroyed = 709,
    #[doc = "< Produced when the kernel calls assert."]
    hipErrorAssert = 710,
    #[doc = "< Produced when trying to lock a page-locked\n< memory."]
    hipErrorHostMemoryAlreadyRegistered = 712,
    #[doc = "< Produced when trying to unlock a non-page-locked\n< memory."]
    hipErrorHostMemoryNotRegistered = 713,
    #[doc = "< An exception occurred on the device while executing a kernel."]
    hipErrorLaunchFailure = 719,
    #[doc = "< This error indicates that the number of blocks\n< launched per grid for a kernel that was launched\n< via cooperative launch APIs exceeds the maximum\n< number of allowed blocks for the current device."]
    hipErrorCooperativeLaunchTooLarge = 720,
    #[doc = "< Produced when the hip API is not supported/implemented"]
    hipErrorNotSupported = 801,
    #[doc = "< The operation is not permitted when the stream\n< is capturing."]
    hipErrorStreamCaptureUnsupported = 900,
    #[doc = "< The current capture sequence on the stream\n< has been invalidated due to a previous error."]
    hipErrorStreamCaptureInvalidated = 901,
    #[doc = "< The operation would have resulted in a merge of\n< two independent capture sequences."]
    hipErrorStreamCaptureMerge = 902,
    #[doc = "< The capture was not initiated in this stream."]
    hipErrorStreamCaptureUnmatched = 903,
    #[doc = "< The capture sequence contains a fork that was not\n< joined to the primary stream."]
    hipErrorStreamCaptureUnjoined = 904,
    #[doc = "< A dependency would have been created which crosses\n< the capture sequence boundary. Only implicit\n< in-stream ordering dependencies  are allowed\n< to cross the boundary"]
    hipErrorStreamCaptureIsolation = 905,
    #[doc = "< The operation would have resulted in a disallowed\n< implicit dependency on a current capture sequence\n< from hipStreamLegacy."]
    hipErrorStreamCaptureImplicit = 906,
    #[doc = "< The operation is not permitted on an event which was last\n< recorded in a capturing stream."]
    hipErrorCapturedEvent = 907,
    #[doc = "< A stream capture sequence not initiated with\n< the hipStreamCaptureModeRelaxed argument to\n< hipStreamBeginCapture was passed to\n< hipStreamEndCapture in a different thread."]
    hipErrorStreamCaptureWrongThread = 908,
    #[doc = "< This error indicates that the graph update\n< not performed because it included changes which\n< violated constraintsspecific to instantiated graph\n< update."]
    hipErrorGraphExecUpdateFailure = 910,
    #[doc = "< Invalid channel descriptor."]
    hipErrorInvalidChannelDescriptor = 911,
    #[doc = "< Invalid texture."]
    hipErrorInvalidTexture = 912,
    #[doc = "< Unknown error."]
    hipErrorUnknown = 999,
    #[doc = "< HSA runtime memory call returned error.  Typically not seen\n< in production systems."]
    hipErrorRuntimeMemory = 1052,
    #[doc = "< HSA runtime call other than memory returned error.  Typically\n< not seen in production systems."]
    hipErrorRuntimeOther = 1053,
    #[doc = "< Marker that more error codes are needed."]
    hipErrorTbd = 1054,
}
impl hipDeviceAttribute_t {
    pub const hipDeviceAttributeEccEnabled: hipDeviceAttribute_t =
        hipDeviceAttribute_t::hipDeviceAttributeCudaCompatibleBegin;
}
impl hipDeviceAttribute_t {
    pub const hipDeviceAttributeClockInstructionRate: hipDeviceAttribute_t =
        hipDeviceAttribute_t::hipDeviceAttributeAmdSpecificBegin;
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " hipDeviceAttribute_t\n hipDeviceAttributeUnused number: 5"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipDeviceAttribute_t {
    hipDeviceAttributeCudaCompatibleBegin = 0,
    #[doc = "< Cuda only. The maximum size of the window policy in bytes."]
    hipDeviceAttributeAccessPolicyMaxWindowSize = 1,
    #[doc = "< Asynchronous engines number."]
    hipDeviceAttributeAsyncEngineCount = 2,
    #[doc = "< Whether host memory can be mapped into device address space"]
    hipDeviceAttributeCanMapHostMemory = 3,
    #[doc = "< Device can access host registered memory\n< at the same virtual address as the CPU"]
    hipDeviceAttributeCanUseHostPointerForRegisteredMem = 4,
    #[doc = "< Peak clock frequency in kilohertz."]
    hipDeviceAttributeClockRate = 5,
    #[doc = "< Compute mode that device is currently in."]
    hipDeviceAttributeComputeMode = 6,
    #[doc = "< Device supports Compute Preemption."]
    hipDeviceAttributeComputePreemptionSupported = 7,
    #[doc = "< Device can possibly execute multiple kernels concurrently."]
    hipDeviceAttributeConcurrentKernels = 8,
    #[doc = "< Device can coherently access managed memory concurrently with the CPU"]
    hipDeviceAttributeConcurrentManagedAccess = 9,
    #[doc = "< Support cooperative launch"]
    hipDeviceAttributeCooperativeLaunch = 10,
    #[doc = "< Support cooperative launch on multiple devices"]
    hipDeviceAttributeCooperativeMultiDeviceLaunch = 11,
    #[doc = "< Device can concurrently copy memory and execute a kernel.\n< Deprecated. Use instead asyncEngineCount."]
    hipDeviceAttributeDeviceOverlap = 12,
    #[doc = "< Host can directly access managed memory on\n< the device without migration"]
    hipDeviceAttributeDirectManagedMemAccessFromHost = 13,
    #[doc = "< Device supports caching globals in L1"]
    hipDeviceAttributeGlobalL1CacheSupported = 14,
    #[doc = "< Link between the device and the host supports native atomic operations"]
    hipDeviceAttributeHostNativeAtomicSupported = 15,
    #[doc = "< Device is integrated GPU"]
    hipDeviceAttributeIntegrated = 16,
    #[doc = "< Multiple GPU devices."]
    hipDeviceAttributeIsMultiGpuBoard = 17,
    #[doc = "< Run time limit for kernels executed on the device"]
    hipDeviceAttributeKernelExecTimeout = 18,
    #[doc = "< Size of L2 cache in bytes. 0 if the device doesn't have L2 cache."]
    hipDeviceAttributeL2CacheSize = 19,
    #[doc = "< caching locals in L1 is supported"]
    hipDeviceAttributeLocalL1CacheSupported = 20,
    #[doc = "< 8-byte locally unique identifier in 8 bytes. Undefined on TCC and non-Windows platforms"]
    hipDeviceAttributeLuid = 21,
    #[doc = "< Luid device node mask. Undefined on TCC and non-Windows platforms"]
    hipDeviceAttributeLuidDeviceNodeMask = 22,
    #[doc = "< Major compute capability version number."]
    hipDeviceAttributeComputeCapabilityMajor = 23,
    #[doc = "< Device supports allocating managed memory on this system"]
    hipDeviceAttributeManagedMemory = 24,
    #[doc = "< Max block size per multiprocessor"]
    hipDeviceAttributeMaxBlocksPerMultiProcessor = 25,
    #[doc = "< Max block size in width."]
    hipDeviceAttributeMaxBlockDimX = 26,
    #[doc = "< Max block size in height."]
    hipDeviceAttributeMaxBlockDimY = 27,
    #[doc = "< Max block size in depth."]
    hipDeviceAttributeMaxBlockDimZ = 28,
    #[doc = "< Max grid size  in width."]
    hipDeviceAttributeMaxGridDimX = 29,
    #[doc = "< Max grid size  in height."]
    hipDeviceAttributeMaxGridDimY = 30,
    #[doc = "< Max grid size  in depth."]
    hipDeviceAttributeMaxGridDimZ = 31,
    #[doc = "< Maximum size of 1D surface."]
    hipDeviceAttributeMaxSurface1D = 32,
    #[doc = "< Cuda only. Maximum dimensions of 1D layered surface."]
    hipDeviceAttributeMaxSurface1DLayered = 33,
    #[doc = "< Maximum dimension (width, height) of 2D surface."]
    hipDeviceAttributeMaxSurface2D = 34,
    #[doc = "< Cuda only. Maximum dimensions of 2D layered surface."]
    hipDeviceAttributeMaxSurface2DLayered = 35,
    #[doc = "< Maximum dimension (width, height, depth) of 3D surface."]
    hipDeviceAttributeMaxSurface3D = 36,
    #[doc = "< Cuda only. Maximum dimensions of Cubemap surface."]
    hipDeviceAttributeMaxSurfaceCubemap = 37,
    #[doc = "< Cuda only. Maximum dimension of Cubemap layered surface."]
    hipDeviceAttributeMaxSurfaceCubemapLayered = 38,
    #[doc = "< Maximum size of 1D texture."]
    hipDeviceAttributeMaxTexture1DWidth = 39,
    #[doc = "< Maximum dimensions of 1D layered texture."]
    hipDeviceAttributeMaxTexture1DLayered = 40,
    #[doc = "< Maximum number of elements allocatable in a 1D linear texture.\n< Use cudaDeviceGetTexture1DLinearMaxWidth() instead on Cuda."]
    hipDeviceAttributeMaxTexture1DLinear = 41,
    #[doc = "< Maximum size of 1D mipmapped texture."]
    hipDeviceAttributeMaxTexture1DMipmap = 42,
    #[doc = "< Maximum dimension width of 2D texture."]
    hipDeviceAttributeMaxTexture2DWidth = 43,
    #[doc = "< Maximum dimension hight of 2D texture."]
    hipDeviceAttributeMaxTexture2DHeight = 44,
    #[doc = "< Maximum dimensions of 2D texture if gather operations  performed."]
    hipDeviceAttributeMaxTexture2DGather = 45,
    #[doc = "< Maximum dimensions of 2D layered texture."]
    hipDeviceAttributeMaxTexture2DLayered = 46,
    #[doc = "< Maximum dimensions (width, height, pitch) of 2D textures bound to pitched memory."]
    hipDeviceAttributeMaxTexture2DLinear = 47,
    #[doc = "< Maximum dimensions of 2D mipmapped texture."]
    hipDeviceAttributeMaxTexture2DMipmap = 48,
    #[doc = "< Maximum dimension width of 3D texture."]
    hipDeviceAttributeMaxTexture3DWidth = 49,
    #[doc = "< Maximum dimension height of 3D texture."]
    hipDeviceAttributeMaxTexture3DHeight = 50,
    #[doc = "< Maximum dimension depth of 3D texture."]
    hipDeviceAttributeMaxTexture3DDepth = 51,
    #[doc = "< Maximum dimensions of alternate 3D texture."]
    hipDeviceAttributeMaxTexture3DAlt = 52,
    #[doc = "< Maximum dimensions of Cubemap texture"]
    hipDeviceAttributeMaxTextureCubemap = 53,
    #[doc = "< Maximum dimensions of Cubemap layered texture."]
    hipDeviceAttributeMaxTextureCubemapLayered = 54,
    #[doc = "< Maximum dimension of a block"]
    hipDeviceAttributeMaxThreadsDim = 55,
    #[doc = "< Maximum number of threads per block."]
    hipDeviceAttributeMaxThreadsPerBlock = 56,
    #[doc = "< Maximum resident threads per multiprocessor."]
    hipDeviceAttributeMaxThreadsPerMultiProcessor = 57,
    #[doc = "< Maximum pitch in bytes allowed by memory copies"]
    hipDeviceAttributeMaxPitch = 58,
    #[doc = "< Global memory bus width in bits."]
    hipDeviceAttributeMemoryBusWidth = 59,
    #[doc = "< Peak memory clock frequency in kilohertz."]
    hipDeviceAttributeMemoryClockRate = 60,
    #[doc = "< Minor compute capability version number."]
    hipDeviceAttributeComputeCapabilityMinor = 61,
    #[doc = "< Unique ID of device group on the same multi-GPU board"]
    hipDeviceAttributeMultiGpuBoardGroupID = 62,
    #[doc = "< Number of multiprocessors on the device."]
    hipDeviceAttributeMultiprocessorCount = 63,
    #[doc = "< Previously hipDeviceAttributeName"]
    hipDeviceAttributeUnused1 = 64,
    #[doc = "< Device supports coherently accessing pageable memory\n< without calling hipHostRegister on it"]
    hipDeviceAttributePageableMemoryAccess = 65,
    #[doc = "< Device accesses pageable memory via the host's page tables"]
    hipDeviceAttributePageableMemoryAccessUsesHostPageTables = 66,
    #[doc = "< PCI Bus ID."]
    hipDeviceAttributePciBusId = 67,
    #[doc = "< PCI Device ID."]
    hipDeviceAttributePciDeviceId = 68,
    #[doc = "< PCI Domain ID."]
    hipDeviceAttributePciDomainID = 69,
    #[doc = "< Maximum l2 persisting lines capacity in bytes"]
    hipDeviceAttributePersistingL2CacheMaxSize = 70,
    #[doc = "< 32-bit registers available to a thread block. This number is shared\n< by all thread blocks simultaneously resident on a multiprocessor."]
    hipDeviceAttributeMaxRegistersPerBlock = 71,
    #[doc = "< 32-bit registers available per block."]
    hipDeviceAttributeMaxRegistersPerMultiprocessor = 72,
    #[doc = "< Shared memory reserved by CUDA driver per block."]
    hipDeviceAttributeReservedSharedMemPerBlock = 73,
    #[doc = "< Maximum shared memory available per block in bytes."]
    hipDeviceAttributeMaxSharedMemoryPerBlock = 74,
    #[doc = "< Maximum shared memory per block usable by special opt in."]
    hipDeviceAttributeSharedMemPerBlockOptin = 75,
    #[doc = "< Shared memory available per multiprocessor."]
    hipDeviceAttributeSharedMemPerMultiprocessor = 76,
    #[doc = "< Cuda only. Performance ratio of single precision to double precision."]
    hipDeviceAttributeSingleToDoublePrecisionPerfRatio = 77,
    #[doc = "< Whether to support stream priorities."]
    hipDeviceAttributeStreamPrioritiesSupported = 78,
    #[doc = "< Alignment requirement for surfaces"]
    hipDeviceAttributeSurfaceAlignment = 79,
    #[doc = "< Cuda only. Whether device is a Tesla device using TCC driver"]
    hipDeviceAttributeTccDriver = 80,
    #[doc = "< Alignment requirement for textures"]
    hipDeviceAttributeTextureAlignment = 81,
    #[doc = "< Pitch alignment requirement for 2D texture references bound to pitched memory;"]
    hipDeviceAttributeTexturePitchAlignment = 82,
    #[doc = "< Constant memory size in bytes."]
    hipDeviceAttributeTotalConstantMemory = 83,
    #[doc = "< Global memory available on devicice."]
    hipDeviceAttributeTotalGlobalMem = 84,
    #[doc = "< Cuda only. An unified address space shared with the host."]
    hipDeviceAttributeUnifiedAddressing = 85,
    #[doc = "< Previously hipDeviceAttributeUuid"]
    hipDeviceAttributeUnused2 = 86,
    #[doc = "< Warp size in threads."]
    hipDeviceAttributeWarpSize = 87,
    #[doc = "< Device supports HIP Stream Ordered Memory Allocator"]
    hipDeviceAttributeMemoryPoolsSupported = 88,
    #[doc = "< Device supports HIP virtual memory management"]
    hipDeviceAttributeVirtualMemoryManagementSupported = 89,
    #[doc = "< Can device support host memory registration via hipHostRegister"]
    hipDeviceAttributeHostRegisterSupported = 90,
    #[doc = "< Supported handle mask for HIP Stream Ordered Memory Allocator"]
    hipDeviceAttributeMemoryPoolSupportedHandleTypes = 91,
    hipDeviceAttributeCudaCompatibleEnd = 9999,
    hipDeviceAttributeAmdSpecificBegin = 10000,
    #[doc = "< Previously hipDeviceAttributeArch"]
    hipDeviceAttributeUnused3 = 10001,
    #[doc = "< Maximum Shared Memory PerMultiprocessor."]
    hipDeviceAttributeMaxSharedMemoryPerMultiprocessor = 10002,
    #[doc = "< Previously hipDeviceAttributeGcnArch"]
    hipDeviceAttributeUnused4 = 10003,
    #[doc = "< Previously hipDeviceAttributeGcnArchName"]
    hipDeviceAttributeUnused5 = 10004,
    #[doc = "< Address of the HDP_MEM_COHERENCY_FLUSH_CNTL register"]
    hipDeviceAttributeHdpMemFlushCntl = 10005,
    #[doc = "< Address of the HDP_REG_COHERENCY_FLUSH_CNTL register"]
    hipDeviceAttributeHdpRegFlushCntl = 10006,
    #[doc = "< Supports cooperative launch on multiple\n< devices with unmatched functions"]
    hipDeviceAttributeCooperativeMultiDeviceUnmatchedFunc = 10007,
    #[doc = "< Supports cooperative launch on multiple\n< devices with unmatched grid dimensions"]
    hipDeviceAttributeCooperativeMultiDeviceUnmatchedGridDim = 10008,
    #[doc = "< Supports cooperative launch on multiple\n< devices with unmatched block dimensions"]
    hipDeviceAttributeCooperativeMultiDeviceUnmatchedBlockDim = 10009,
    #[doc = "< Supports cooperative launch on multiple\n< devices with unmatched shared memories"]
    hipDeviceAttributeCooperativeMultiDeviceUnmatchedSharedMem = 10010,
    #[doc = "< Whether it is LargeBar"]
    hipDeviceAttributeIsLargeBar = 10011,
    #[doc = "< Revision of the GPU in this device"]
    hipDeviceAttributeAsicRevision = 10012,
    #[doc = "< '1' if Device supports hipStreamWaitValue32() and\n< hipStreamWaitValue64(), '0' otherwise."]
    hipDeviceAttributeCanUseStreamWaitValue = 10013,
    #[doc = "< '1' if Device supports image, '0' otherwise."]
    hipDeviceAttributeImageSupport = 10014,
    #[doc = "< All available physical compute\n< units for the device"]
    hipDeviceAttributePhysicalMultiProcessorCount = 10015,
    #[doc = "< '1' if Device supports fine grain, '0' otherwise"]
    hipDeviceAttributeFineGrainSupport = 10016,
    #[doc = "< Constant frequency of wall clock in kilohertz."]
    hipDeviceAttributeWallClockRate = 10017,
    hipDeviceAttributeAmdSpecificEnd = 19999,
    hipDeviceAttributeVendorSpecificBegin = 20000,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipDriverProcAddressQueryResult {
    HIP_GET_PROC_ADDRESS_SUCCESS = 0,
    HIP_GET_PROC_ADDRESS_SYMBOL_NOT_FOUND = 1,
    HIP_GET_PROC_ADDRESS_VERSION_NOT_SUFFICIENT = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipComputeMode {
    hipComputeModeDefault = 0,
    hipComputeModeExclusive = 1,
    hipComputeModeProhibited = 2,
    hipComputeModeExclusiveProcess = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipFlushGPUDirectRDMAWritesOptions {
    hipFlushGPUDirectRDMAWritesOptionHost = 1,
    hipFlushGPUDirectRDMAWritesOptionMemOps = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipGPUDirectRDMAWritesOrdering {
    hipGPUDirectRDMAWritesOrderingNone = 0,
    hipGPUDirectRDMAWritesOrderingOwner = 100,
    hipGPUDirectRDMAWritesOrderingAllDevices = 200,
}
#[doc = "  @defgroup DriverTypes Driver Types\n  @{\n  This section describes the driver data types.\n"]
pub type hipDeviceptr_t = *mut ::libc::c_void;
#[repr(u32)]
#[non_exhaustive]
#[doc = " HIP channel format kinds"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipChannelFormatKind {
    #[doc = "< Signed channel format"]
    hipChannelFormatKindSigned = 0,
    #[doc = "< Unsigned channel format"]
    hipChannelFormatKindUnsigned = 1,
    #[doc = "< Float channel format"]
    hipChannelFormatKindFloat = 2,
    #[doc = "< No channel format"]
    hipChannelFormatKindNone = 3,
}
#[doc = " HIP channel format descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipChannelFormatDesc {
    pub x: ::libc::c_int,
    pub y: ::libc::c_int,
    pub z: ::libc::c_int,
    pub w: ::libc::c_int,
    #[doc = "< Channel format kind"]
    pub f: hipChannelFormatKind,
}
#[test]
fn bindgen_test_layout_hipChannelFormatDesc() {
    const UNINIT: ::std::mem::MaybeUninit<hipChannelFormatDesc> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipChannelFormatDesc>(),
        20usize,
        concat!("Size of: ", stringify!(hipChannelFormatDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<hipChannelFormatDesc>(),
        4usize,
        concat!("Alignment of ", stringify!(hipChannelFormatDesc))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipChannelFormatDesc),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hipChannelFormatDesc),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipChannelFormatDesc),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hipChannelFormatDesc),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hipChannelFormatDesc),
            "::",
            stringify!(f)
        )
    );
}
impl Default for hipChannelFormatDesc {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipArray {
    _unused: [u8; 0],
}
pub type hipArray_t = *mut hipArray;
pub type hipArray_const_t = *const hipArray;
#[repr(u32)]
#[non_exhaustive]
#[doc = " HIP array format"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipArray_Format {
    #[doc = "< Unsigned 8-bit array format"]
    HIP_AD_FORMAT_UNSIGNED_INT8 = 1,
    #[doc = "< Unsigned 16-bit array format"]
    HIP_AD_FORMAT_UNSIGNED_INT16 = 2,
    #[doc = "< Unsigned 32-bit array format"]
    HIP_AD_FORMAT_UNSIGNED_INT32 = 3,
    #[doc = "< Signed 8-bit array format"]
    HIP_AD_FORMAT_SIGNED_INT8 = 8,
    #[doc = "< Signed 16-bit array format"]
    HIP_AD_FORMAT_SIGNED_INT16 = 9,
    #[doc = "< Signed 32-bit array format"]
    HIP_AD_FORMAT_SIGNED_INT32 = 10,
    #[doc = "< Half array format"]
    HIP_AD_FORMAT_HALF = 16,
    #[doc = "< Float array format"]
    HIP_AD_FORMAT_FLOAT = 32,
}
#[doc = " HIP array descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct HIP_ARRAY_DESCRIPTOR {
    #[doc = "< Width of the array"]
    pub Width: usize,
    #[doc = "< Height of the array"]
    pub Height: usize,
    #[doc = "< Format of the array"]
    pub Format: hipArray_Format,
    #[doc = "< Number of channels of the array"]
    pub NumChannels: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_HIP_ARRAY_DESCRIPTOR() {
    const UNINIT: ::std::mem::MaybeUninit<HIP_ARRAY_DESCRIPTOR> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HIP_ARRAY_DESCRIPTOR>(),
        24usize,
        concat!("Size of: ", stringify!(HIP_ARRAY_DESCRIPTOR))
    );
    assert_eq!(
        ::std::mem::align_of::<HIP_ARRAY_DESCRIPTOR>(),
        8usize,
        concat!("Alignment of ", stringify!(HIP_ARRAY_DESCRIPTOR))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_ARRAY_DESCRIPTOR),
            "::",
            stringify!(Width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Height) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_ARRAY_DESCRIPTOR),
            "::",
            stringify!(Height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Format) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_ARRAY_DESCRIPTOR),
            "::",
            stringify!(Format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumChannels) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_ARRAY_DESCRIPTOR),
            "::",
            stringify!(NumChannels)
        )
    );
}
impl Default for HIP_ARRAY_DESCRIPTOR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " HIP 3D array descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct HIP_ARRAY3D_DESCRIPTOR {
    #[doc = "< Width of the array"]
    pub Width: usize,
    #[doc = "< Height of the array"]
    pub Height: usize,
    #[doc = "< Depth of the array"]
    pub Depth: usize,
    #[doc = "< Format of the array"]
    pub Format: hipArray_Format,
    #[doc = "< Number of channels of the array"]
    pub NumChannels: ::libc::c_uint,
    #[doc = "< Flags of the array"]
    pub Flags: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_HIP_ARRAY3D_DESCRIPTOR() {
    const UNINIT: ::std::mem::MaybeUninit<HIP_ARRAY3D_DESCRIPTOR> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HIP_ARRAY3D_DESCRIPTOR>(),
        40usize,
        concat!("Size of: ", stringify!(HIP_ARRAY3D_DESCRIPTOR))
    );
    assert_eq!(
        ::std::mem::align_of::<HIP_ARRAY3D_DESCRIPTOR>(),
        8usize,
        concat!("Alignment of ", stringify!(HIP_ARRAY3D_DESCRIPTOR))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_ARRAY3D_DESCRIPTOR),
            "::",
            stringify!(Width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Height) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_ARRAY3D_DESCRIPTOR),
            "::",
            stringify!(Height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Depth) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_ARRAY3D_DESCRIPTOR),
            "::",
            stringify!(Depth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Format) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_ARRAY3D_DESCRIPTOR),
            "::",
            stringify!(Format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumChannels) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_ARRAY3D_DESCRIPTOR),
            "::",
            stringify!(NumChannels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_ARRAY3D_DESCRIPTOR),
            "::",
            stringify!(Flags)
        )
    );
}
impl Default for HIP_ARRAY3D_DESCRIPTOR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " HIP 2D memory copy parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hip_Memcpy2D {
    #[doc = "< Source width in bytes"]
    pub srcXInBytes: usize,
    #[doc = "< Source height"]
    pub srcY: usize,
    #[doc = "< Source memory type"]
    pub srcMemoryType: hipMemoryType,
    #[doc = "< Source pointer"]
    pub srcHost: *const ::libc::c_void,
    #[doc = "< Source device"]
    pub srcDevice: hipDeviceptr_t,
    #[doc = "< Source array"]
    pub srcArray: hipArray_t,
    #[doc = "< Source pitch"]
    pub srcPitch: usize,
    #[doc = "< Destination width in bytes"]
    pub dstXInBytes: usize,
    #[doc = "< Destination height"]
    pub dstY: usize,
    #[doc = "< Destination memory type"]
    pub dstMemoryType: hipMemoryType,
    #[doc = "< Destination pointer"]
    pub dstHost: *mut ::libc::c_void,
    #[doc = "< Destination device"]
    pub dstDevice: hipDeviceptr_t,
    #[doc = "< Destination array"]
    pub dstArray: hipArray_t,
    #[doc = "< Destination pitch"]
    pub dstPitch: usize,
    #[doc = "< Width in bytes of the 2D memory copy"]
    pub WidthInBytes: usize,
    #[doc = "< Height of the 2D memory copy"]
    pub Height: usize,
}
#[test]
fn bindgen_test_layout_hip_Memcpy2D() {
    const UNINIT: ::std::mem::MaybeUninit<hip_Memcpy2D> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hip_Memcpy2D>(),
        128usize,
        concat!("Size of: ", stringify!(hip_Memcpy2D))
    );
    assert_eq!(
        ::std::mem::align_of::<hip_Memcpy2D>(),
        8usize,
        concat!("Alignment of ", stringify!(hip_Memcpy2D))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcXInBytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hip_Memcpy2D),
            "::",
            stringify!(srcXInBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcY) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hip_Memcpy2D),
            "::",
            stringify!(srcY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcMemoryType) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hip_Memcpy2D),
            "::",
            stringify!(srcMemoryType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcHost) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hip_Memcpy2D),
            "::",
            stringify!(srcHost)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcDevice) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hip_Memcpy2D),
            "::",
            stringify!(srcDevice)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcArray) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hip_Memcpy2D),
            "::",
            stringify!(srcArray)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcPitch) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hip_Memcpy2D),
            "::",
            stringify!(srcPitch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstXInBytes) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(hip_Memcpy2D),
            "::",
            stringify!(dstXInBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstY) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(hip_Memcpy2D),
            "::",
            stringify!(dstY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstMemoryType) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(hip_Memcpy2D),
            "::",
            stringify!(dstMemoryType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstHost) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(hip_Memcpy2D),
            "::",
            stringify!(dstHost)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstDevice) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(hip_Memcpy2D),
            "::",
            stringify!(dstDevice)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstArray) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(hip_Memcpy2D),
            "::",
            stringify!(dstArray)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstPitch) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(hip_Memcpy2D),
            "::",
            stringify!(dstPitch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).WidthInBytes) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(hip_Memcpy2D),
            "::",
            stringify!(WidthInBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Height) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(hip_Memcpy2D),
            "::",
            stringify!(Height)
        )
    );
}
impl Default for hip_Memcpy2D {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " HIP mipmapped array"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipMipmappedArray {
    #[doc = "< Data pointer of the mipmapped array"]
    pub data: *mut ::libc::c_void,
    #[doc = "< Description of the mipmapped array"]
    pub desc: hipChannelFormatDesc,
    #[doc = "< Type of the mipmapped array"]
    pub type_: ::libc::c_uint,
    #[doc = "< Width of the mipmapped array"]
    pub width: ::libc::c_uint,
    #[doc = "< Height of the mipmapped array"]
    pub height: ::libc::c_uint,
    #[doc = "< Depth of the mipmapped array"]
    pub depth: ::libc::c_uint,
    #[doc = "< Minimum level of the mipmapped array"]
    pub min_mipmap_level: ::libc::c_uint,
    #[doc = "< Maximum level of the mipmapped array"]
    pub max_mipmap_level: ::libc::c_uint,
    #[doc = "< Flags of the mipmapped array"]
    pub flags: ::libc::c_uint,
    #[doc = "< Format of the mipmapped array"]
    pub format: hipArray_Format,
    #[doc = "< Number of channels of the mipmapped array"]
    pub num_channels: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_hipMipmappedArray() {
    const UNINIT: ::std::mem::MaybeUninit<hipMipmappedArray> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipMipmappedArray>(),
        64usize,
        concat!("Size of: ", stringify!(hipMipmappedArray))
    );
    assert_eq!(
        ::std::mem::align_of::<hipMipmappedArray>(),
        8usize,
        concat!("Alignment of ", stringify!(hipMipmappedArray))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMipmappedArray),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).desc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMipmappedArray),
            "::",
            stringify!(desc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMipmappedArray),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMipmappedArray),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMipmappedArray),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).depth) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMipmappedArray),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_mipmap_level) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMipmappedArray),
            "::",
            stringify!(min_mipmap_level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_mipmap_level) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMipmappedArray),
            "::",
            stringify!(max_mipmap_level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMipmappedArray),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMipmappedArray),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_channels) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMipmappedArray),
            "::",
            stringify!(num_channels)
        )
    );
}
impl Default for hipMipmappedArray {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " HIP mipmapped array pointer"]
pub type hipMipmappedArray_t = *mut hipMipmappedArray;
pub type hipmipmappedArray = hipMipmappedArray_t;
pub type hipMipmappedArray_const_t = *const hipMipmappedArray;
#[repr(u32)]
#[non_exhaustive]
#[doc = " HIP resource types"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipResourceType {
    #[doc = "< Array resource"]
    hipResourceTypeArray = 0,
    #[doc = "< Mipmapped array resource"]
    hipResourceTypeMipmappedArray = 1,
    #[doc = "< Linear resource"]
    hipResourceTypeLinear = 2,
    #[doc = "< Pitch 2D resource"]
    hipResourceTypePitch2D = 3,
}
#[doc = "< Array resource"]
pub const HIPresourcetype_enum_HIP_RESOURCE_TYPE_ARRAY: HIPresourcetype_enum = 0;
#[doc = "< Mipmapped array resource"]
pub const HIPresourcetype_enum_HIP_RESOURCE_TYPE_MIPMAPPED_ARRAY: HIPresourcetype_enum = 1;
#[doc = "< Linear resource"]
pub const HIPresourcetype_enum_HIP_RESOURCE_TYPE_LINEAR: HIPresourcetype_enum = 2;
#[doc = "< Pitch 2D resource"]
pub const HIPresourcetype_enum_HIP_RESOURCE_TYPE_PITCH2D: HIPresourcetype_enum = 3;
pub type HIPresourcetype_enum = ::libc::c_uint;
pub use self::HIPresourcetype_enum as HIPresourcetype;
pub use self::HIPresourcetype_enum as hipResourcetype;
#[doc = "< Wrap address mode"]
pub const HIPaddress_mode_enum_HIP_TR_ADDRESS_MODE_WRAP: HIPaddress_mode_enum = 0;
#[doc = "< Clamp address mode"]
pub const HIPaddress_mode_enum_HIP_TR_ADDRESS_MODE_CLAMP: HIPaddress_mode_enum = 1;
#[doc = "< Mirror address mode"]
pub const HIPaddress_mode_enum_HIP_TR_ADDRESS_MODE_MIRROR: HIPaddress_mode_enum = 2;
#[doc = "< Border address mode"]
pub const HIPaddress_mode_enum_HIP_TR_ADDRESS_MODE_BORDER: HIPaddress_mode_enum = 3;
#[doc = " HIP texture address modes"]
pub type HIPaddress_mode_enum = ::libc::c_uint;
#[doc = " HIP texture address modes"]
pub use self::HIPaddress_mode_enum as HIPaddress_mode;
#[doc = "< Filter mode point"]
pub const HIPfilter_mode_enum_HIP_TR_FILTER_MODE_POINT: HIPfilter_mode_enum = 0;
#[doc = "< Filter mode linear"]
pub const HIPfilter_mode_enum_HIP_TR_FILTER_MODE_LINEAR: HIPfilter_mode_enum = 1;
#[doc = " HIP filter modes"]
pub type HIPfilter_mode_enum = ::libc::c_uint;
#[doc = " HIP filter modes"]
pub use self::HIPfilter_mode_enum as HIPfilter_mode;
#[doc = " HIP texture descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, PartialEq)]
pub struct HIP_TEXTURE_DESC_st {
    #[doc = "< Address modes"]
    pub addressMode: [HIPaddress_mode; 3usize],
    #[doc = "< Filter mode"]
    pub filterMode: HIPfilter_mode,
    #[doc = "< Flags"]
    pub flags: ::libc::c_uint,
    #[doc = "< Maximum anisotropy ratio"]
    pub maxAnisotropy: ::libc::c_uint,
    #[doc = "< Mipmap filter mode"]
    pub mipmapFilterMode: HIPfilter_mode,
    #[doc = "< Mipmap level bias"]
    pub mipmapLevelBias: f32,
    #[doc = "< Mipmap minimum level clamp"]
    pub minMipmapLevelClamp: f32,
    #[doc = "< Mipmap maximum level clamp"]
    pub maxMipmapLevelClamp: f32,
    #[doc = "< Border Color"]
    pub borderColor: [f32; 4usize],
    pub reserved: [::libc::c_int; 12usize],
}
#[test]
fn bindgen_test_layout_HIP_TEXTURE_DESC_st() {
    const UNINIT: ::std::mem::MaybeUninit<HIP_TEXTURE_DESC_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HIP_TEXTURE_DESC_st>(),
        104usize,
        concat!("Size of: ", stringify!(HIP_TEXTURE_DESC_st))
    );
    assert_eq!(
        ::std::mem::align_of::<HIP_TEXTURE_DESC_st>(),
        4usize,
        concat!("Alignment of ", stringify!(HIP_TEXTURE_DESC_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addressMode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_TEXTURE_DESC_st),
            "::",
            stringify!(addressMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filterMode) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_TEXTURE_DESC_st),
            "::",
            stringify!(filterMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_TEXTURE_DESC_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxAnisotropy) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_TEXTURE_DESC_st),
            "::",
            stringify!(maxAnisotropy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mipmapFilterMode) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_TEXTURE_DESC_st),
            "::",
            stringify!(mipmapFilterMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mipmapLevelBias) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_TEXTURE_DESC_st),
            "::",
            stringify!(mipmapLevelBias)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minMipmapLevelClamp) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_TEXTURE_DESC_st),
            "::",
            stringify!(minMipmapLevelClamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxMipmapLevelClamp) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_TEXTURE_DESC_st),
            "::",
            stringify!(maxMipmapLevelClamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).borderColor) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_TEXTURE_DESC_st),
            "::",
            stringify!(borderColor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_TEXTURE_DESC_st),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for HIP_TEXTURE_DESC_st {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " HIP texture descriptor"]
pub type HIP_TEXTURE_DESC = HIP_TEXTURE_DESC_st;
#[repr(u32)]
#[non_exhaustive]
#[doc = " HIP texture resource view formats"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipResourceViewFormat {
    #[doc = "< No resource view format (use underlying resource format)"]
    hipResViewFormatNone = 0,
    #[doc = "< 1 channel, unsigned 8-bit integers"]
    hipResViewFormatUnsignedChar1 = 1,
    #[doc = "< 2 channels, unsigned 8-bit integers"]
    hipResViewFormatUnsignedChar2 = 2,
    #[doc = "< 4 channels, unsigned 8-bit integers"]
    hipResViewFormatUnsignedChar4 = 3,
    #[doc = "< 1 channel, signed 8-bit integers"]
    hipResViewFormatSignedChar1 = 4,
    #[doc = "< 2 channels, signed 8-bit integers"]
    hipResViewFormatSignedChar2 = 5,
    #[doc = "< 4 channels, signed 8-bit integers"]
    hipResViewFormatSignedChar4 = 6,
    #[doc = "< 1 channel, unsigned 16-bit integers"]
    hipResViewFormatUnsignedShort1 = 7,
    #[doc = "< 2 channels, unsigned 16-bit integers"]
    hipResViewFormatUnsignedShort2 = 8,
    #[doc = "< 4 channels, unsigned 16-bit integers"]
    hipResViewFormatUnsignedShort4 = 9,
    #[doc = "< 1 channel, signed 16-bit integers"]
    hipResViewFormatSignedShort1 = 10,
    #[doc = "< 2 channels, signed 16-bit integers"]
    hipResViewFormatSignedShort2 = 11,
    #[doc = "< 4 channels, signed 16-bit integers"]
    hipResViewFormatSignedShort4 = 12,
    #[doc = "< 1 channel, unsigned 32-bit integers"]
    hipResViewFormatUnsignedInt1 = 13,
    #[doc = "< 2 channels, unsigned 32-bit integers"]
    hipResViewFormatUnsignedInt2 = 14,
    #[doc = "< 4 channels, unsigned 32-bit integers"]
    hipResViewFormatUnsignedInt4 = 15,
    #[doc = "< 1 channel, signed 32-bit integers"]
    hipResViewFormatSignedInt1 = 16,
    #[doc = "< 2 channels, signed 32-bit integers"]
    hipResViewFormatSignedInt2 = 17,
    #[doc = "< 4 channels, signed 32-bit integers"]
    hipResViewFormatSignedInt4 = 18,
    #[doc = "< 1 channel, 16-bit floating point"]
    hipResViewFormatHalf1 = 19,
    #[doc = "< 2 channels, 16-bit floating point"]
    hipResViewFormatHalf2 = 20,
    #[doc = "< 4 channels, 16-bit floating point"]
    hipResViewFormatHalf4 = 21,
    #[doc = "< 1 channel, 32-bit floating point"]
    hipResViewFormatFloat1 = 22,
    #[doc = "< 2 channels, 32-bit floating point"]
    hipResViewFormatFloat2 = 23,
    #[doc = "< 4 channels, 32-bit floating point"]
    hipResViewFormatFloat4 = 24,
    #[doc = "< Block-compressed 1"]
    hipResViewFormatUnsignedBlockCompressed1 = 25,
    #[doc = "< Block-compressed 2"]
    hipResViewFormatUnsignedBlockCompressed2 = 26,
    #[doc = "< Block-compressed 3"]
    hipResViewFormatUnsignedBlockCompressed3 = 27,
    #[doc = "< Block-compressed 4 unsigned"]
    hipResViewFormatUnsignedBlockCompressed4 = 28,
    #[doc = "< Block-compressed 4 signed"]
    hipResViewFormatSignedBlockCompressed4 = 29,
    #[doc = "< Block-compressed 5 unsigned"]
    hipResViewFormatUnsignedBlockCompressed5 = 30,
    #[doc = "< Block-compressed 5 signed"]
    hipResViewFormatSignedBlockCompressed5 = 31,
    #[doc = "< Block-compressed 6 unsigned half-float"]
    hipResViewFormatUnsignedBlockCompressed6H = 32,
    #[doc = "< Block-compressed 6 signed half-float"]
    hipResViewFormatSignedBlockCompressed6H = 33,
    #[doc = "< Block-compressed 7"]
    hipResViewFormatUnsignedBlockCompressed7 = 34,
}
#[doc = "< No resource view format (use underlying resource format)"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_NONE: HIPresourceViewFormat_enum = 0;
#[doc = "< 1 channel, unsigned 8-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UINT_1X8: HIPresourceViewFormat_enum = 1;
#[doc = "< 2 channels, unsigned 8-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UINT_2X8: HIPresourceViewFormat_enum = 2;
#[doc = "< 4 channels, unsigned 8-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UINT_4X8: HIPresourceViewFormat_enum = 3;
#[doc = "< 1 channel, signed 8-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_SINT_1X8: HIPresourceViewFormat_enum = 4;
#[doc = "< 2 channels, signed 8-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_SINT_2X8: HIPresourceViewFormat_enum = 5;
#[doc = "< 4 channels, signed 8-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_SINT_4X8: HIPresourceViewFormat_enum = 6;
#[doc = "< 1 channel, unsigned 16-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UINT_1X16: HIPresourceViewFormat_enum = 7;
#[doc = "< 2 channels, unsigned 16-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UINT_2X16: HIPresourceViewFormat_enum = 8;
#[doc = "< 4 channels, unsigned 16-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UINT_4X16: HIPresourceViewFormat_enum = 9;
#[doc = "< 1 channel, signed 16-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_SINT_1X16: HIPresourceViewFormat_enum = 10;
#[doc = "< 2 channels, signed 16-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_SINT_2X16: HIPresourceViewFormat_enum = 11;
#[doc = "< 4 channels, signed 16-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_SINT_4X16: HIPresourceViewFormat_enum = 12;
#[doc = "< 1 channel, unsigned 32-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UINT_1X32: HIPresourceViewFormat_enum = 13;
#[doc = "< 2 channels, unsigned 32-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UINT_2X32: HIPresourceViewFormat_enum = 14;
#[doc = "< 4 channels, unsigned 32-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UINT_4X32: HIPresourceViewFormat_enum = 15;
#[doc = "< 1 channel, signed 32-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_SINT_1X32: HIPresourceViewFormat_enum = 16;
#[doc = "< 2 channels, signed 32-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_SINT_2X32: HIPresourceViewFormat_enum = 17;
#[doc = "< 4 channels, signed 32-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_SINT_4X32: HIPresourceViewFormat_enum = 18;
#[doc = "< 1 channel, 16-bit floating point"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_FLOAT_1X16: HIPresourceViewFormat_enum =
    19;
#[doc = "< 2 channels, 16-bit floating point"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_FLOAT_2X16: HIPresourceViewFormat_enum =
    20;
#[doc = "< 4 channels, 16-bit floating point"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_FLOAT_4X16: HIPresourceViewFormat_enum =
    21;
#[doc = "< 1 channel, 32-bit floating point"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_FLOAT_1X32: HIPresourceViewFormat_enum =
    22;
#[doc = "< 2 channels, 32-bit floating point"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_FLOAT_2X32: HIPresourceViewFormat_enum =
    23;
#[doc = "< 4 channels, 32-bit floating point"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_FLOAT_4X32: HIPresourceViewFormat_enum =
    24;
#[doc = "< Block-compressed 1"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UNSIGNED_BC1: HIPresourceViewFormat_enum =
    25;
#[doc = "< Block-compressed 2"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UNSIGNED_BC2: HIPresourceViewFormat_enum =
    26;
#[doc = "< Block-compressed 3"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UNSIGNED_BC3: HIPresourceViewFormat_enum =
    27;
#[doc = "< Block-compressed 4 unsigned"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UNSIGNED_BC4: HIPresourceViewFormat_enum =
    28;
#[doc = "< Block-compressed 4 signed"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_SIGNED_BC4: HIPresourceViewFormat_enum =
    29;
#[doc = "< Block-compressed 5 unsigned"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UNSIGNED_BC5: HIPresourceViewFormat_enum =
    30;
#[doc = "< Block-compressed 5 signed"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_SIGNED_BC5: HIPresourceViewFormat_enum =
    31;
#[doc = "< Block-compressed 6 unsigned half-float"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UNSIGNED_BC6H: HIPresourceViewFormat_enum =
    32;
#[doc = "< Block-compressed 6 signed half-float"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_SIGNED_BC6H: HIPresourceViewFormat_enum =
    33;
#[doc = "< Block-compressed 7"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UNSIGNED_BC7: HIPresourceViewFormat_enum =
    34;
#[doc = " HIP texture resource view formats"]
pub type HIPresourceViewFormat_enum = ::libc::c_uint;
#[doc = " HIP texture resource view formats"]
pub use self::HIPresourceViewFormat_enum as HIPresourceViewFormat;
#[doc = " HIP resource descriptor"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hipResourceDesc {
    #[doc = "< Resource type"]
    pub resType: hipResourceType,
    pub res: hipResourceDesc__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hipResourceDesc__bindgen_ty_1 {
    pub array: hipResourceDesc__bindgen_ty_1__bindgen_ty_1,
    pub mipmap: hipResourceDesc__bindgen_ty_1__bindgen_ty_2,
    pub linear: hipResourceDesc__bindgen_ty_1__bindgen_ty_3,
    pub pitch2D: hipResourceDesc__bindgen_ty_1__bindgen_ty_4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipResourceDesc__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< HIP array"]
    pub array: hipArray_t,
}
#[test]
fn bindgen_test_layout_hipResourceDesc__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<hipResourceDesc__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipResourceDesc__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hipResourceDesc__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hipResourceDesc__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hipResourceDesc__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).array) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceDesc__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(array)
        )
    );
}
impl Default for hipResourceDesc__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipResourceDesc__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "< HIP mipmapped array"]
    pub mipmap: hipMipmappedArray_t,
}
#[test]
fn bindgen_test_layout_hipResourceDesc__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<hipResourceDesc__bindgen_ty_1__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipResourceDesc__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hipResourceDesc__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hipResourceDesc__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hipResourceDesc__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mipmap) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceDesc__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(mipmap)
        )
    );
}
impl Default for hipResourceDesc__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipResourceDesc__bindgen_ty_1__bindgen_ty_3 {
    #[doc = "< Device pointer"]
    pub devPtr: *mut ::libc::c_void,
    #[doc = "< Channel format description"]
    pub desc: hipChannelFormatDesc,
    #[doc = "< Size in bytes"]
    pub sizeInBytes: usize,
}
#[test]
fn bindgen_test_layout_hipResourceDesc__bindgen_ty_1__bindgen_ty_3() {
    const UNINIT: ::std::mem::MaybeUninit<hipResourceDesc__bindgen_ty_1__bindgen_ty_3> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipResourceDesc__bindgen_ty_1__bindgen_ty_3>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(hipResourceDesc__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hipResourceDesc__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hipResourceDesc__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).devPtr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceDesc__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(devPtr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).desc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceDesc__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(desc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sizeInBytes) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceDesc__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(sizeInBytes)
        )
    );
}
impl Default for hipResourceDesc__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipResourceDesc__bindgen_ty_1__bindgen_ty_4 {
    #[doc = "< Device pointer"]
    pub devPtr: *mut ::libc::c_void,
    #[doc = "< Channel format description"]
    pub desc: hipChannelFormatDesc,
    #[doc = "< Width of the array in elements"]
    pub width: usize,
    #[doc = "< Height of the array in elements"]
    pub height: usize,
    #[doc = "< Pitch between two rows in bytes"]
    pub pitchInBytes: usize,
}
#[test]
fn bindgen_test_layout_hipResourceDesc__bindgen_ty_1__bindgen_ty_4() {
    const UNINIT: ::std::mem::MaybeUninit<hipResourceDesc__bindgen_ty_1__bindgen_ty_4> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipResourceDesc__bindgen_ty_1__bindgen_ty_4>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(hipResourceDesc__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hipResourceDesc__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hipResourceDesc__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).devPtr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceDesc__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(devPtr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).desc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceDesc__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(desc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceDesc__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceDesc__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pitchInBytes) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceDesc__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(pitchInBytes)
        )
    );
}
impl Default for hipResourceDesc__bindgen_ty_1__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_hipResourceDesc__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<hipResourceDesc__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipResourceDesc__bindgen_ty_1>(),
        56usize,
        concat!("Size of: ", stringify!(hipResourceDesc__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<hipResourceDesc__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(hipResourceDesc__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).array) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceDesc__bindgen_ty_1),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mipmap) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceDesc__bindgen_ty_1),
            "::",
            stringify!(mipmap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).linear) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceDesc__bindgen_ty_1),
            "::",
            stringify!(linear)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pitch2D) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceDesc__bindgen_ty_1),
            "::",
            stringify!(pitch2D)
        )
    );
}
impl Default for hipResourceDesc__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_hipResourceDesc() {
    const UNINIT: ::std::mem::MaybeUninit<hipResourceDesc> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipResourceDesc>(),
        64usize,
        concat!("Size of: ", stringify!(hipResourceDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<hipResourceDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(hipResourceDesc))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceDesc),
            "::",
            stringify!(resType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).res) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceDesc),
            "::",
            stringify!(res)
        )
    );
}
impl Default for hipResourceDesc {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " HIP resource view descriptor struct"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct HIP_RESOURCE_DESC_st {
    #[doc = "< Resource type"]
    pub resType: HIPresourcetype,
    pub res: HIP_RESOURCE_DESC_st__bindgen_ty_1,
    #[doc = "< Flags (must be zero)"]
    pub flags: ::libc::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union HIP_RESOURCE_DESC_st__bindgen_ty_1 {
    pub array: HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1,
    pub mipmap: HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2,
    pub linear: HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3,
    pub pitch2D: HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4,
    pub reserved: HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< HIP array"]
    pub hArray: hipArray_t,
}
#[test]
fn bindgen_test_layout_HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hArray) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(hArray)
        )
    );
}
impl Default for HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "< HIP mipmapped array"]
    pub hMipmappedArray: hipMipmappedArray_t,
}
#[test]
fn bindgen_test_layout_HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hMipmappedArray) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(hMipmappedArray)
        )
    );
}
impl Default for HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3 {
    #[doc = "< Device pointer"]
    pub devPtr: hipDeviceptr_t,
    #[doc = "< Array format"]
    pub format: hipArray_Format,
    #[doc = "< Channels per array element"]
    pub numChannels: ::libc::c_uint,
    #[doc = "< Size in bytes"]
    pub sizeInBytes: usize,
}
#[test]
fn bindgen_test_layout_HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3() {
    const UNINIT: ::std::mem::MaybeUninit<HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).devPtr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(devPtr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numChannels) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(numChannels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sizeInBytes) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(sizeInBytes)
        )
    );
}
impl Default for HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4 {
    #[doc = "< Device pointer"]
    pub devPtr: hipDeviceptr_t,
    #[doc = "< Array format"]
    pub format: hipArray_Format,
    #[doc = "< Channels per array element"]
    pub numChannels: ::libc::c_uint,
    #[doc = "< Width of the array in elements"]
    pub width: usize,
    #[doc = "< Height of the array in elements"]
    pub height: usize,
    #[doc = "< Pitch between two rows in bytes"]
    pub pitchInBytes: usize,
}
#[test]
fn bindgen_test_layout_HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4() {
    const UNINIT: ::std::mem::MaybeUninit<HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).devPtr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(devPtr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numChannels) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(numChannels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pitchInBytes) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(pitchInBytes)
        )
    );
}
impl Default for HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5 {
    pub reserved: [::libc::c_int; 32usize],
}
#[test]
fn bindgen_test_layout_HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5() {
    const UNINIT: ::std::mem::MaybeUninit<HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_HIP_RESOURCE_DESC_st__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<HIP_RESOURCE_DESC_st__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HIP_RESOURCE_DESC_st__bindgen_ty_1>(),
        128usize,
        concat!("Size of: ", stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<HIP_RESOURCE_DESC_st__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).array) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mipmap) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(mipmap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).linear) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(linear)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pitch2D) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(pitch2D)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for HIP_RESOURCE_DESC_st__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_HIP_RESOURCE_DESC_st() {
    const UNINIT: ::std::mem::MaybeUninit<HIP_RESOURCE_DESC_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HIP_RESOURCE_DESC_st>(),
        144usize,
        concat!("Size of: ", stringify!(HIP_RESOURCE_DESC_st))
    );
    assert_eq!(
        ::std::mem::align_of::<HIP_RESOURCE_DESC_st>(),
        8usize,
        concat!("Alignment of ", stringify!(HIP_RESOURCE_DESC_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st),
            "::",
            stringify!(resType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).res) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st),
            "::",
            stringify!(res)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for HIP_RESOURCE_DESC_st {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " HIP resource view descriptor struct"]
pub type HIP_RESOURCE_DESC = HIP_RESOURCE_DESC_st;
#[doc = " HIP resource view descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipResourceViewDesc {
    #[doc = "< Resource view format"]
    pub format: hipResourceViewFormat,
    #[doc = "< Width of the resource view"]
    pub width: usize,
    #[doc = "< Height of the resource view"]
    pub height: usize,
    #[doc = "< Depth of the resource view"]
    pub depth: usize,
    #[doc = "< First defined mipmap level"]
    pub firstMipmapLevel: ::libc::c_uint,
    #[doc = "< Last defined mipmap level"]
    pub lastMipmapLevel: ::libc::c_uint,
    #[doc = "< First layer index"]
    pub firstLayer: ::libc::c_uint,
    #[doc = "< Last layer index"]
    pub lastLayer: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_hipResourceViewDesc() {
    const UNINIT: ::std::mem::MaybeUninit<hipResourceViewDesc> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipResourceViewDesc>(),
        48usize,
        concat!("Size of: ", stringify!(hipResourceViewDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<hipResourceViewDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(hipResourceViewDesc))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceViewDesc),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceViewDesc),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceViewDesc),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).depth) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceViewDesc),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).firstMipmapLevel) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceViewDesc),
            "::",
            stringify!(firstMipmapLevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lastMipmapLevel) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceViewDesc),
            "::",
            stringify!(lastMipmapLevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).firstLayer) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceViewDesc),
            "::",
            stringify!(firstLayer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lastLayer) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceViewDesc),
            "::",
            stringify!(lastLayer)
        )
    );
}
impl Default for hipResourceViewDesc {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Resource view descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct HIP_RESOURCE_VIEW_DESC_st {
    #[doc = "< Resource view format"]
    pub format: HIPresourceViewFormat,
    #[doc = "< Width of the resource view"]
    pub width: usize,
    #[doc = "< Height of the resource view"]
    pub height: usize,
    #[doc = "< Depth of the resource view"]
    pub depth: usize,
    #[doc = "< First defined mipmap level"]
    pub firstMipmapLevel: ::libc::c_uint,
    #[doc = "< Last defined mipmap level"]
    pub lastMipmapLevel: ::libc::c_uint,
    #[doc = "< First layer index"]
    pub firstLayer: ::libc::c_uint,
    #[doc = "< Last layer index"]
    pub lastLayer: ::libc::c_uint,
    pub reserved: [::libc::c_uint; 16usize],
}
#[test]
fn bindgen_test_layout_HIP_RESOURCE_VIEW_DESC_st() {
    const UNINIT: ::std::mem::MaybeUninit<HIP_RESOURCE_VIEW_DESC_st> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HIP_RESOURCE_VIEW_DESC_st>(),
        112usize,
        concat!("Size of: ", stringify!(HIP_RESOURCE_VIEW_DESC_st))
    );
    assert_eq!(
        ::std::mem::align_of::<HIP_RESOURCE_VIEW_DESC_st>(),
        8usize,
        concat!("Alignment of ", stringify!(HIP_RESOURCE_VIEW_DESC_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).depth) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).firstMipmapLevel) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(firstMipmapLevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lastMipmapLevel) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(lastMipmapLevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).firstLayer) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(firstLayer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lastLayer) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(lastLayer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for HIP_RESOURCE_VIEW_DESC_st {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Resource view descriptor"]
pub type HIP_RESOURCE_VIEW_DESC = HIP_RESOURCE_VIEW_DESC_st;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipMemcpyKind {
    #[doc = "< Host-to-Host Copy"]
    hipMemcpyHostToHost = 0,
    #[doc = "< Host-to-Device Copy"]
    hipMemcpyHostToDevice = 1,
    #[doc = "< Device-to-Host Copy"]
    hipMemcpyDeviceToHost = 2,
    #[doc = "< Device-to-Device Copy"]
    hipMemcpyDeviceToDevice = 3,
    #[doc = "< Runtime will automatically determine\n<copy-kind based on virtual addresses."]
    hipMemcpyDefault = 4,
    #[doc = "< Device-to-Device Copy without using compute units"]
    hipMemcpyDeviceToDeviceNoCU = 1024,
}
#[doc = " HIP pithed pointer"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipPitchedPtr {
    #[doc = "< Pointer to the allocated memory"]
    pub ptr: *mut ::libc::c_void,
    #[doc = "< Pitch in bytes"]
    pub pitch: usize,
    #[doc = "< Logical size of the first dimension of allocation in elements"]
    pub xsize: usize,
    #[doc = "< Logical size of the second dimension of allocation in elements"]
    pub ysize: usize,
}
#[test]
fn bindgen_test_layout_hipPitchedPtr() {
    const UNINIT: ::std::mem::MaybeUninit<hipPitchedPtr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipPitchedPtr>(),
        32usize,
        concat!("Size of: ", stringify!(hipPitchedPtr))
    );
    assert_eq!(
        ::std::mem::align_of::<hipPitchedPtr>(),
        8usize,
        concat!("Alignment of ", stringify!(hipPitchedPtr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipPitchedPtr),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pitch) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipPitchedPtr),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xsize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hipPitchedPtr),
            "::",
            stringify!(xsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ysize) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hipPitchedPtr),
            "::",
            stringify!(ysize)
        )
    );
}
impl Default for hipPitchedPtr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " HIP extent"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipExtent {
    pub width: usize,
    pub height: usize,
    pub depth: usize,
}
#[test]
fn bindgen_test_layout_hipExtent() {
    const UNINIT: ::std::mem::MaybeUninit<hipExtent> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipExtent>(),
        24usize,
        concat!("Size of: ", stringify!(hipExtent))
    );
    assert_eq!(
        ::std::mem::align_of::<hipExtent>(),
        8usize,
        concat!("Alignment of ", stringify!(hipExtent))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExtent),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExtent),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).depth) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExtent),
            "::",
            stringify!(depth)
        )
    );
}
#[doc = "  HIP position"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipPos {
    #[doc = "< X coordinate"]
    pub x: usize,
    #[doc = "< Y coordinate"]
    pub y: usize,
    #[doc = "< Z coordinate"]
    pub z: usize,
}
#[test]
fn bindgen_test_layout_hipPos() {
    const UNINIT: ::std::mem::MaybeUninit<hipPos> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipPos>(),
        24usize,
        concat!("Size of: ", stringify!(hipPos))
    );
    assert_eq!(
        ::std::mem::align_of::<hipPos>(),
        8usize,
        concat!("Alignment of ", stringify!(hipPos))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(hipPos), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(hipPos), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        16usize,
        concat!("Offset of field: ", stringify!(hipPos), "::", stringify!(z))
    );
}
#[doc = " HIP 3D memory copy parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipMemcpy3DParms {
    #[doc = "< Source array"]
    pub srcArray: hipArray_t,
    #[doc = "< Source position"]
    pub srcPos: hipPos,
    #[doc = "< Source pointer"]
    pub srcPtr: hipPitchedPtr,
    #[doc = "< Destination array"]
    pub dstArray: hipArray_t,
    #[doc = "< Destination position"]
    pub dstPos: hipPos,
    #[doc = "< Destination pointer"]
    pub dstPtr: hipPitchedPtr,
    #[doc = "< Extent of 3D memory copy"]
    pub extent: hipExtent,
    #[doc = "< Kind of 3D memory copy"]
    pub kind: hipMemcpyKind,
}
#[test]
fn bindgen_test_layout_hipMemcpy3DParms() {
    const UNINIT: ::std::mem::MaybeUninit<hipMemcpy3DParms> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipMemcpy3DParms>(),
        160usize,
        concat!("Size of: ", stringify!(hipMemcpy3DParms))
    );
    assert_eq!(
        ::std::mem::align_of::<hipMemcpy3DParms>(),
        8usize,
        concat!("Alignment of ", stringify!(hipMemcpy3DParms))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcArray) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMemcpy3DParms),
            "::",
            stringify!(srcArray)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcPos) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMemcpy3DParms),
            "::",
            stringify!(srcPos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcPtr) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMemcpy3DParms),
            "::",
            stringify!(srcPtr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstArray) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMemcpy3DParms),
            "::",
            stringify!(dstArray)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstPos) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMemcpy3DParms),
            "::",
            stringify!(dstPos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstPtr) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMemcpy3DParms),
            "::",
            stringify!(dstPtr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extent) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMemcpy3DParms),
            "::",
            stringify!(extent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kind) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMemcpy3DParms),
            "::",
            stringify!(kind)
        )
    );
}
impl Default for hipMemcpy3DParms {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " HIP 3D memory copy"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct HIP_MEMCPY3D {
    #[doc = "< Source X in bytes"]
    pub srcXInBytes: usize,
    #[doc = "< Source Y"]
    pub srcY: usize,
    #[doc = "< Source Z"]
    pub srcZ: usize,
    #[doc = "< Source LOD"]
    pub srcLOD: usize,
    #[doc = "< Source memory type"]
    pub srcMemoryType: hipMemoryType,
    #[doc = "< Source host pointer"]
    pub srcHost: *const ::libc::c_void,
    #[doc = "< Source device"]
    pub srcDevice: hipDeviceptr_t,
    #[doc = "< Source array"]
    pub srcArray: hipArray_t,
    #[doc = "< Source pitch"]
    pub srcPitch: usize,
    #[doc = "< Source height"]
    pub srcHeight: usize,
    #[doc = "< Destination X in bytes"]
    pub dstXInBytes: usize,
    #[doc = "< Destination Y"]
    pub dstY: usize,
    #[doc = "< Destination Z"]
    pub dstZ: usize,
    #[doc = "< Destination LOD"]
    pub dstLOD: usize,
    #[doc = "< Destination memory type"]
    pub dstMemoryType: hipMemoryType,
    #[doc = "< Destination host pointer"]
    pub dstHost: *mut ::libc::c_void,
    #[doc = "< Destination device"]
    pub dstDevice: hipDeviceptr_t,
    #[doc = "< Destination array"]
    pub dstArray: hipArray_t,
    #[doc = "< Destination pitch"]
    pub dstPitch: usize,
    #[doc = "< Destination height"]
    pub dstHeight: usize,
    #[doc = "< Width in bytes of 3D memory copy"]
    pub WidthInBytes: usize,
    #[doc = "< Height in bytes of 3D memory copy"]
    pub Height: usize,
    #[doc = "< Depth in bytes of 3D memory copy"]
    pub Depth: usize,
}
#[test]
fn bindgen_test_layout_HIP_MEMCPY3D() {
    const UNINIT: ::std::mem::MaybeUninit<HIP_MEMCPY3D> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HIP_MEMCPY3D>(),
        184usize,
        concat!("Size of: ", stringify!(HIP_MEMCPY3D))
    );
    assert_eq!(
        ::std::mem::align_of::<HIP_MEMCPY3D>(),
        8usize,
        concat!("Alignment of ", stringify!(HIP_MEMCPY3D))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcXInBytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(srcXInBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcY) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(srcY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcZ) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(srcZ)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcLOD) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(srcLOD)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcMemoryType) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(srcMemoryType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcHost) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(srcHost)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcDevice) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(srcDevice)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcArray) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(srcArray)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcPitch) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(srcPitch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srcHeight) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(srcHeight)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstXInBytes) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(dstXInBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstY) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(dstY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstZ) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(dstZ)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstLOD) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(dstLOD)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstMemoryType) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(dstMemoryType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstHost) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(dstHost)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstDevice) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(dstDevice)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstArray) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(dstArray)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstPitch) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(dstPitch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstHeight) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(dstHeight)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).WidthInBytes) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(WidthInBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Height) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(Height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Depth) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(Depth)
        )
    );
}
impl Default for HIP_MEMCPY3D {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipFunction_attribute {
    #[doc = "< The maximum number of threads per block. Depends on function and device."]
    HIP_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK = 0,
    #[doc = "< The statically allocated shared memory size in bytes per block required by the function."]
    HIP_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES = 1,
    #[doc = "< The user-allocated constant memory by the function in bytes."]
    HIP_FUNC_ATTRIBUTE_CONST_SIZE_BYTES = 2,
    #[doc = "< The local memory usage of each thread by this function in bytes."]
    HIP_FUNC_ATTRIBUTE_LOCAL_SIZE_BYTES = 3,
    #[doc = "< The number of registers used by each thread of this function."]
    HIP_FUNC_ATTRIBUTE_NUM_REGS = 4,
    #[doc = "< PTX version"]
    HIP_FUNC_ATTRIBUTE_PTX_VERSION = 5,
    #[doc = "< Binary version"]
    HIP_FUNC_ATTRIBUTE_BINARY_VERSION = 6,
    #[doc = "< Cache mode"]
    HIP_FUNC_ATTRIBUTE_CACHE_MODE_CA = 7,
    #[doc = "< The maximum dynamic shared memory per block for this function in bytes."]
    HIP_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES = 8,
    #[doc = "< The shared memory carveout preference in percent of the maximum shared memory."]
    HIP_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT = 9,
    HIP_FUNC_ATTRIBUTE_MAX = 10,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipPointer_attribute {
    #[doc = "< The context on which a pointer was allocated\n< @warning This attribute is not supported in HIP"]
    HIP_POINTER_ATTRIBUTE_CONTEXT = 1,
    #[doc = "< memory type describing the location of a pointer"]
    HIP_POINTER_ATTRIBUTE_MEMORY_TYPE = 2,
    #[doc = "< address at which the pointer is allocated on the device"]
    HIP_POINTER_ATTRIBUTE_DEVICE_POINTER = 3,
    #[doc = "< address at which the pointer is allocated on the host"]
    HIP_POINTER_ATTRIBUTE_HOST_POINTER = 4,
    #[doc = "< A pair of tokens for use with Linux kernel interface\n< @warning This attribute is not supported in HIP"]
    HIP_POINTER_ATTRIBUTE_P2P_TOKENS = 5,
    #[doc = "< Synchronize every synchronous memory operation\n< initiated on this region"]
    HIP_POINTER_ATTRIBUTE_SYNC_MEMOPS = 6,
    #[doc = "< Unique ID for an allocated memory region"]
    HIP_POINTER_ATTRIBUTE_BUFFER_ID = 7,
    #[doc = "< Indicates if the pointer points to managed memory"]
    HIP_POINTER_ATTRIBUTE_IS_MANAGED = 8,
    #[doc = "< device ordinal of a device on which a pointer\n< was allocated or registered"]
    HIP_POINTER_ATTRIBUTE_DEVICE_ORDINAL = 9,
    #[doc = "< if this pointer maps to an allocation\n< that is suitable for hipIpcGetMemHandle\n< @warning This attribute is not supported in HIP"]
    HIP_POINTER_ATTRIBUTE_IS_LEGACY_HIP_IPC_CAPABLE = 10,
    #[doc = "< Starting address for this requested pointer"]
    HIP_POINTER_ATTRIBUTE_RANGE_START_ADDR = 11,
    #[doc = "< Size of the address range for this requested pointer"]
    HIP_POINTER_ATTRIBUTE_RANGE_SIZE = 12,
    #[doc = "< tells if this pointer is in a valid address range\n< that is mapped to a backing allocation"]
    HIP_POINTER_ATTRIBUTE_MAPPED = 13,
    #[doc = "< Bitmask of allowed hipmemAllocationHandleType\n< for this allocation @warning This attribute is not supported in HIP"]
    HIP_POINTER_ATTRIBUTE_ALLOWED_HANDLE_TYPES = 14,
    #[doc = "< returns if the memory referenced by\n< this pointer can be used with the GPUDirect RDMA API\n< @warning This attribute is not supported in HIP"]
    HIP_POINTER_ATTRIBUTE_IS_GPU_DIRECT_RDMA_CAPABLE = 15,
    #[doc = "< Returns the access flags the device associated with\n< for the corresponding memory referenced by the ptr"]
    HIP_POINTER_ATTRIBUTE_ACCESS_FLAGS = 16,
    #[doc = "< Returns the mempool handle for the allocation if\n< it was allocated from a mempool\n< @warning This attribute is not supported in HIP"]
    HIP_POINTER_ATTRIBUTE_MEMPOOL_HANDLE = 17,
}
extern "C" {
    pub fn hipCreateChannelDesc(
        x: ::libc::c_int,
        y: ::libc::c_int,
        z: ::libc::c_int,
        w: ::libc::c_int,
        f: hipChannelFormatKind,
    ) -> hipChannelFormatDesc;
}
#[doc = " An opaque value that represents a hip texture object"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __hip_texture {
    _unused: [u8; 0],
}
pub type hipTextureObject_t = *mut __hip_texture;
#[repr(u32)]
#[non_exhaustive]
#[doc = " hip texture address modes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipTextureAddressMode {
    hipAddressModeWrap = 0,
    hipAddressModeClamp = 1,
    hipAddressModeMirror = 2,
    hipAddressModeBorder = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " hip texture filter modes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipTextureFilterMode {
    hipFilterModePoint = 0,
    hipFilterModeLinear = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " hip texture read modes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipTextureReadMode {
    hipReadModeElementType = 0,
    hipReadModeNormalizedFloat = 1,
}
#[doc = " hip texture reference"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, PartialEq)]
pub struct textureReference {
    pub normalized: ::libc::c_int,
    pub readMode: hipTextureReadMode,
    pub filterMode: hipTextureFilterMode,
    pub addressMode: [hipTextureAddressMode; 3usize],
    pub channelDesc: hipChannelFormatDesc,
    pub sRGB: ::libc::c_int,
    pub maxAnisotropy: ::libc::c_uint,
    pub mipmapFilterMode: hipTextureFilterMode,
    pub mipmapLevelBias: f32,
    pub minMipmapLevelClamp: f32,
    pub maxMipmapLevelClamp: f32,
    pub textureObject: hipTextureObject_t,
    pub numChannels: ::libc::c_int,
    pub format: hipArray_Format,
}
#[test]
fn bindgen_test_layout_textureReference() {
    const UNINIT: ::std::mem::MaybeUninit<textureReference> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<textureReference>(),
        88usize,
        concat!("Size of: ", stringify!(textureReference))
    );
    assert_eq!(
        ::std::mem::align_of::<textureReference>(),
        8usize,
        concat!("Alignment of ", stringify!(textureReference))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).normalized) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(textureReference),
            "::",
            stringify!(normalized)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).readMode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(textureReference),
            "::",
            stringify!(readMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filterMode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(textureReference),
            "::",
            stringify!(filterMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addressMode) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(textureReference),
            "::",
            stringify!(addressMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channelDesc) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(textureReference),
            "::",
            stringify!(channelDesc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sRGB) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(textureReference),
            "::",
            stringify!(sRGB)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxAnisotropy) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(textureReference),
            "::",
            stringify!(maxAnisotropy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mipmapFilterMode) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(textureReference),
            "::",
            stringify!(mipmapFilterMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mipmapLevelBias) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(textureReference),
            "::",
            stringify!(mipmapLevelBias)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minMipmapLevelClamp) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(textureReference),
            "::",
            stringify!(minMipmapLevelClamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxMipmapLevelClamp) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(textureReference),
            "::",
            stringify!(maxMipmapLevelClamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).textureObject) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(textureReference),
            "::",
            stringify!(textureObject)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numChannels) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(textureReference),
            "::",
            stringify!(numChannels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(textureReference),
            "::",
            stringify!(format)
        )
    );
}
impl Default for textureReference {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " hip texture descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, PartialEq)]
pub struct hipTextureDesc {
    pub addressMode: [hipTextureAddressMode; 3usize],
    pub filterMode: hipTextureFilterMode,
    pub readMode: hipTextureReadMode,
    pub sRGB: ::libc::c_int,
    pub borderColor: [f32; 4usize],
    pub normalizedCoords: ::libc::c_int,
    pub maxAnisotropy: ::libc::c_uint,
    pub mipmapFilterMode: hipTextureFilterMode,
    pub mipmapLevelBias: f32,
    pub minMipmapLevelClamp: f32,
    pub maxMipmapLevelClamp: f32,
}
#[test]
fn bindgen_test_layout_hipTextureDesc() {
    const UNINIT: ::std::mem::MaybeUninit<hipTextureDesc> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipTextureDesc>(),
        64usize,
        concat!("Size of: ", stringify!(hipTextureDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<hipTextureDesc>(),
        4usize,
        concat!("Alignment of ", stringify!(hipTextureDesc))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addressMode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipTextureDesc),
            "::",
            stringify!(addressMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filterMode) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hipTextureDesc),
            "::",
            stringify!(filterMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).readMode) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hipTextureDesc),
            "::",
            stringify!(readMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sRGB) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(hipTextureDesc),
            "::",
            stringify!(sRGB)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).borderColor) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hipTextureDesc),
            "::",
            stringify!(borderColor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).normalizedCoords) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hipTextureDesc),
            "::",
            stringify!(normalizedCoords)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxAnisotropy) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(hipTextureDesc),
            "::",
            stringify!(maxAnisotropy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mipmapFilterMode) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hipTextureDesc),
            "::",
            stringify!(mipmapFilterMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mipmapLevelBias) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(hipTextureDesc),
            "::",
            stringify!(mipmapLevelBias)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minMipmapLevelClamp) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(hipTextureDesc),
            "::",
            stringify!(minMipmapLevelClamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxMipmapLevelClamp) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(hipTextureDesc),
            "::",
            stringify!(maxMipmapLevelClamp)
        )
    );
}
impl Default for hipTextureDesc {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type hipTexRef = *mut textureReference;
#[doc = " An opaque value that represents a hip surface object"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __hip_surface {
    _unused: [u8; 0],
}
pub type hipSurfaceObject_t = *mut __hip_surface;
#[repr(u32)]
#[non_exhaustive]
#[doc = " hip surface boundary modes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipSurfaceBoundaryMode {
    hipBoundaryModeZero = 0,
    hipBoundaryModeTrap = 1,
    hipBoundaryModeClamp = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ihipCtx_t {
    _unused: [u8; 0],
}
pub type hipCtx_t = *mut ihipCtx_t;
pub type hipDevice_t = ::libc::c_int;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipDeviceP2PAttr {
    hipDevP2PAttrPerformanceRank = 0,
    hipDevP2PAttrAccessSupported = 1,
    hipDevP2PAttrNativeAtomicSupported = 2,
    hipDevP2PAttrHipArrayAccessSupported = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ihipStream_t {
    _unused: [u8; 0],
}
pub type hipStream_t = *mut ihipStream_t;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipIpcMemHandle_st {
    pub reserved: [::libc::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_hipIpcMemHandle_st() {
    const UNINIT: ::std::mem::MaybeUninit<hipIpcMemHandle_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipIpcMemHandle_st>(),
        64usize,
        concat!("Size of: ", stringify!(hipIpcMemHandle_st))
    );
    assert_eq!(
        ::std::mem::align_of::<hipIpcMemHandle_st>(),
        1usize,
        concat!("Alignment of ", stringify!(hipIpcMemHandle_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipIpcMemHandle_st),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for hipIpcMemHandle_st {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type hipIpcMemHandle_t = hipIpcMemHandle_st;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipIpcEventHandle_st {
    pub reserved: [::libc::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_hipIpcEventHandle_st() {
    const UNINIT: ::std::mem::MaybeUninit<hipIpcEventHandle_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipIpcEventHandle_st>(),
        64usize,
        concat!("Size of: ", stringify!(hipIpcEventHandle_st))
    );
    assert_eq!(
        ::std::mem::align_of::<hipIpcEventHandle_st>(),
        1usize,
        concat!("Alignment of ", stringify!(hipIpcEventHandle_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipIpcEventHandle_st),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for hipIpcEventHandle_st {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type hipIpcEventHandle_t = hipIpcEventHandle_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ihipModule_t {
    _unused: [u8; 0],
}
pub type hipModule_t = *mut ihipModule_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ihipModuleSymbol_t {
    _unused: [u8; 0],
}
pub type hipFunction_t = *mut ihipModuleSymbol_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ihipLinkState_t {
    _unused: [u8; 0],
}
pub type hipLinkState_t = *mut ihipLinkState_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ihipMemPoolHandle_t {
    _unused: [u8; 0],
}
#[doc = " HIP memory pool"]
pub type hipMemPool_t = *mut ihipMemPoolHandle_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipFuncAttributes {
    pub binaryVersion: ::libc::c_int,
    pub cacheModeCA: ::libc::c_int,
    pub constSizeBytes: usize,
    pub localSizeBytes: usize,
    pub maxDynamicSharedSizeBytes: ::libc::c_int,
    pub maxThreadsPerBlock: ::libc::c_int,
    pub numRegs: ::libc::c_int,
    pub preferredShmemCarveout: ::libc::c_int,
    pub ptxVersion: ::libc::c_int,
    pub sharedSizeBytes: usize,
}
#[test]
fn bindgen_test_layout_hipFuncAttributes() {
    const UNINIT: ::std::mem::MaybeUninit<hipFuncAttributes> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipFuncAttributes>(),
        56usize,
        concat!("Size of: ", stringify!(hipFuncAttributes))
    );
    assert_eq!(
        ::std::mem::align_of::<hipFuncAttributes>(),
        8usize,
        concat!("Alignment of ", stringify!(hipFuncAttributes))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).binaryVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipFuncAttributes),
            "::",
            stringify!(binaryVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cacheModeCA) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hipFuncAttributes),
            "::",
            stringify!(cacheModeCA)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).constSizeBytes) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipFuncAttributes),
            "::",
            stringify!(constSizeBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).localSizeBytes) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hipFuncAttributes),
            "::",
            stringify!(localSizeBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxDynamicSharedSizeBytes) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hipFuncAttributes),
            "::",
            stringify!(maxDynamicSharedSizeBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxThreadsPerBlock) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(hipFuncAttributes),
            "::",
            stringify!(maxThreadsPerBlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numRegs) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hipFuncAttributes),
            "::",
            stringify!(numRegs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).preferredShmemCarveout) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(hipFuncAttributes),
            "::",
            stringify!(preferredShmemCarveout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptxVersion) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hipFuncAttributes),
            "::",
            stringify!(ptxVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sharedSizeBytes) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hipFuncAttributes),
            "::",
            stringify!(sharedSizeBytes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ihipEvent_t {
    _unused: [u8; 0],
}
pub type hipEvent_t = *mut ihipEvent_t;
#[repr(u32)]
#[non_exhaustive]
#[doc = " hipLimit\n\n @note In HIP device limit-related APIs, any input limit value other than those defined in the\n enum is treated as \"UnsupportedLimit\" by default."]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipLimit_t {
    #[doc = "< Limit of stack size in bytes on the current device, per\n< thread. The size is in units of 256 dwords, up to the\n< limit of (128K - 16)"]
    hipLimitStackSize = 0,
    #[doc = "< Size limit in bytes of fifo used by printf call on the\n< device. Currently not supported"]
    hipLimitPrintfFifoSize = 1,
    #[doc = "< Limit of heap size in bytes on the current device, should\n< be less than the global memory size on the device"]
    hipLimitMallocHeapSize = 2,
    #[doc = "< Supported limit range"]
    hipLimitRange = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Operations for hipStreamBatchMemOp"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipStreamBatchMemOpType {
    hipStreamMemOpWaitValue32 = 1,
    hipStreamMemOpWriteValue32 = 2,
    hipStreamMemOpWaitValue64 = 4,
    hipStreamMemOpWriteValue64 = 5,
    #[doc = "< Currently not supported"]
    hipStreamMemOpBarrier = 6,
    #[doc = "< Currently not supported"]
    hipStreamMemOpFlushRemoteWrites = 3,
}
#[doc = " @brief Union representing batch memory operation parameters for HIP streams.\n\n hipStreamBatchMemOpParams is used to specify the parameters for batch memory\n operations in a HIP stream. This union supports various operations including\n waiting for a specific value, writing a value, and different flags for wait conditions.\n\n @details\n The union includes fields for different types of operations defined in the\n enum hipStreamBatchMemOpType:\n - hipStreamMemOpWaitValue32:  Wait for a 32-bit value.\n - hipStreamMemOpWriteValue32: Write a 32-bit value.\n - hipStreamMemOpWaitValue64:  Wait for a 64-bit value.\n - hipStreamMemOpWriteValue64: Write a 64-bit value.\n\n Each operation type includes an address, the value to wait for or write, flags, and an\n optional alias that is not relevant on AMD GPUs. Flags can be used to specify different\n wait conditions such as equality, bitwise AND, greater than or equal, and bitwise NOR.\n\n Example usage:\n @code\n hipStreamBatchMemOpParams myArray[2];\n myArray[0].operation = hipStreamMemOpWaitValue32;\n myArray[0].waitValue.address = waitAddr1;\n myArray[0].waitValue.value = 0x1;\n myArray[0].waitValue.flags = CU_STREAM_WAIT_VALUE_EQ;\n\n myArray[1].operation = hipStreamMemOpWriteValue32;\n myArray[1].writeValue.address = writeAddr1;\n myArray[1].writeValue.value = 0x1;\n myArray[1].writeValue.flags = 0x0;\n\n result = hipStreamBatchMemOp(stream, 2, myArray, 0);\n @endcode"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union hipStreamBatchMemOpParams_union {
    pub operation: hipStreamBatchMemOpType,
    pub waitValue: hipStreamBatchMemOpParams_union_hipStreamMemOpWaitValueParams_t,
    pub writeValue: hipStreamBatchMemOpParams_union_hipStreamMemOpWriteValueParams_t,
    #[doc = "< Currently not supported on AMD"]
    pub flushRemoteWrites: hipStreamBatchMemOpParams_union_hipStreamMemOpFlushRemoteWritesParams_t,
    #[doc = "< Currently not supported on AMD"]
    pub memoryBarrier: hipStreamBatchMemOpParams_union_hipStreamMemOpMemoryBarrierParams_t,
    pub pad: [u64; 6usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hipStreamBatchMemOpParams_union_hipStreamMemOpWaitValueParams_t {
    pub operation: hipStreamBatchMemOpType,
    pub address: hipDeviceptr_t,
    pub __bindgen_anon_1:
        hipStreamBatchMemOpParams_union_hipStreamMemOpWaitValueParams_t__bindgen_ty_1,
    pub flags: ::libc::c_uint,
    #[doc = "< Not valid for AMD backend. Initial value is unimportant"]
    pub alias: hipDeviceptr_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hipStreamBatchMemOpParams_union_hipStreamMemOpWaitValueParams_t__bindgen_ty_1 {
    pub value: u32,
    pub value64: u64,
}
#[test]
fn bindgen_test_layout_hipStreamBatchMemOpParams_union_hipStreamMemOpWaitValueParams_t__bindgen_ty_1(
) {
    const UNINIT: ::std::mem::MaybeUninit<
        hipStreamBatchMemOpParams_union_hipStreamMemOpWaitValueParams_t__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<
            hipStreamBatchMemOpParams_union_hipStreamMemOpWaitValueParams_t__bindgen_ty_1,
        >(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(
                hipStreamBatchMemOpParams_union_hipStreamMemOpWaitValueParams_t__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            hipStreamBatchMemOpParams_union_hipStreamMemOpWaitValueParams_t__bindgen_ty_1,
        >(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(
                hipStreamBatchMemOpParams_union_hipStreamMemOpWaitValueParams_t__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(
                hipStreamBatchMemOpParams_union_hipStreamMemOpWaitValueParams_t__bindgen_ty_1
            ),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(
                hipStreamBatchMemOpParams_union_hipStreamMemOpWaitValueParams_t__bindgen_ty_1
            ),
            "::",
            stringify!(value64)
        )
    );
}
impl Default for hipStreamBatchMemOpParams_union_hipStreamMemOpWaitValueParams_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_hipStreamBatchMemOpParams_union_hipStreamMemOpWaitValueParams_t() {
    const UNINIT: ::std::mem::MaybeUninit<
        hipStreamBatchMemOpParams_union_hipStreamMemOpWaitValueParams_t,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipStreamBatchMemOpParams_union_hipStreamMemOpWaitValueParams_t>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(hipStreamBatchMemOpParams_union_hipStreamMemOpWaitValueParams_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hipStreamBatchMemOpParams_union_hipStreamMemOpWaitValueParams_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hipStreamBatchMemOpParams_union_hipStreamMemOpWaitValueParams_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).operation) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipStreamBatchMemOpParams_union_hipStreamMemOpWaitValueParams_t),
            "::",
            stringify!(operation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipStreamBatchMemOpParams_union_hipStreamMemOpWaitValueParams_t),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hipStreamBatchMemOpParams_union_hipStreamMemOpWaitValueParams_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alias) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hipStreamBatchMemOpParams_union_hipStreamMemOpWaitValueParams_t),
            "::",
            stringify!(alias)
        )
    );
}
impl Default for hipStreamBatchMemOpParams_union_hipStreamMemOpWaitValueParams_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hipStreamBatchMemOpParams_union_hipStreamMemOpWriteValueParams_t {
    pub operation: hipStreamBatchMemOpType,
    pub address: hipDeviceptr_t,
    pub __bindgen_anon_1:
        hipStreamBatchMemOpParams_union_hipStreamMemOpWriteValueParams_t__bindgen_ty_1,
    pub flags: ::libc::c_uint,
    #[doc = "< Not valid for AMD backend. Initial value is unimportant"]
    pub alias: hipDeviceptr_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hipStreamBatchMemOpParams_union_hipStreamMemOpWriteValueParams_t__bindgen_ty_1 {
    pub value: u32,
    pub value64: u64,
}
#[test]
fn bindgen_test_layout_hipStreamBatchMemOpParams_union_hipStreamMemOpWriteValueParams_t__bindgen_ty_1(
) {
    const UNINIT: ::std::mem::MaybeUninit<
        hipStreamBatchMemOpParams_union_hipStreamMemOpWriteValueParams_t__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<
            hipStreamBatchMemOpParams_union_hipStreamMemOpWriteValueParams_t__bindgen_ty_1,
        >(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(
                hipStreamBatchMemOpParams_union_hipStreamMemOpWriteValueParams_t__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            hipStreamBatchMemOpParams_union_hipStreamMemOpWriteValueParams_t__bindgen_ty_1,
        >(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(
                hipStreamBatchMemOpParams_union_hipStreamMemOpWriteValueParams_t__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(
                hipStreamBatchMemOpParams_union_hipStreamMemOpWriteValueParams_t__bindgen_ty_1
            ),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(
                hipStreamBatchMemOpParams_union_hipStreamMemOpWriteValueParams_t__bindgen_ty_1
            ),
            "::",
            stringify!(value64)
        )
    );
}
impl Default for hipStreamBatchMemOpParams_union_hipStreamMemOpWriteValueParams_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_hipStreamBatchMemOpParams_union_hipStreamMemOpWriteValueParams_t() {
    const UNINIT: ::std::mem::MaybeUninit<
        hipStreamBatchMemOpParams_union_hipStreamMemOpWriteValueParams_t,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipStreamBatchMemOpParams_union_hipStreamMemOpWriteValueParams_t>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(hipStreamBatchMemOpParams_union_hipStreamMemOpWriteValueParams_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hipStreamBatchMemOpParams_union_hipStreamMemOpWriteValueParams_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hipStreamBatchMemOpParams_union_hipStreamMemOpWriteValueParams_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).operation) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipStreamBatchMemOpParams_union_hipStreamMemOpWriteValueParams_t),
            "::",
            stringify!(operation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipStreamBatchMemOpParams_union_hipStreamMemOpWriteValueParams_t),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hipStreamBatchMemOpParams_union_hipStreamMemOpWriteValueParams_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alias) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hipStreamBatchMemOpParams_union_hipStreamMemOpWriteValueParams_t),
            "::",
            stringify!(alias)
        )
    );
}
impl Default for hipStreamBatchMemOpParams_union_hipStreamMemOpWriteValueParams_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipStreamBatchMemOpParams_union_hipStreamMemOpFlushRemoteWritesParams_t {
    pub operation: hipStreamBatchMemOpType,
    pub flags: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_hipStreamBatchMemOpParams_union_hipStreamMemOpFlushRemoteWritesParams_t() {
    const UNINIT: ::std::mem::MaybeUninit<
        hipStreamBatchMemOpParams_union_hipStreamMemOpFlushRemoteWritesParams_t,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<
            hipStreamBatchMemOpParams_union_hipStreamMemOpFlushRemoteWritesParams_t,
        >(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hipStreamBatchMemOpParams_union_hipStreamMemOpFlushRemoteWritesParams_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            hipStreamBatchMemOpParams_union_hipStreamMemOpFlushRemoteWritesParams_t,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(hipStreamBatchMemOpParams_union_hipStreamMemOpFlushRemoteWritesParams_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).operation) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipStreamBatchMemOpParams_union_hipStreamMemOpFlushRemoteWritesParams_t),
            "::",
            stringify!(operation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hipStreamBatchMemOpParams_union_hipStreamMemOpFlushRemoteWritesParams_t),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for hipStreamBatchMemOpParams_union_hipStreamMemOpFlushRemoteWritesParams_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipStreamBatchMemOpParams_union_hipStreamMemOpMemoryBarrierParams_t {
    pub operation: hipStreamBatchMemOpType,
    pub flags: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_hipStreamBatchMemOpParams_union_hipStreamMemOpMemoryBarrierParams_t() {
    const UNINIT: ::std::mem::MaybeUninit<
        hipStreamBatchMemOpParams_union_hipStreamMemOpMemoryBarrierParams_t,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipStreamBatchMemOpParams_union_hipStreamMemOpMemoryBarrierParams_t>(
        ),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hipStreamBatchMemOpParams_union_hipStreamMemOpMemoryBarrierParams_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hipStreamBatchMemOpParams_union_hipStreamMemOpMemoryBarrierParams_t>(
        ),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(hipStreamBatchMemOpParams_union_hipStreamMemOpMemoryBarrierParams_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).operation) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipStreamBatchMemOpParams_union_hipStreamMemOpMemoryBarrierParams_t),
            "::",
            stringify!(operation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hipStreamBatchMemOpParams_union_hipStreamMemOpMemoryBarrierParams_t),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for hipStreamBatchMemOpParams_union_hipStreamMemOpMemoryBarrierParams_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_hipStreamBatchMemOpParams_union() {
    const UNINIT: ::std::mem::MaybeUninit<hipStreamBatchMemOpParams_union> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipStreamBatchMemOpParams_union>(),
        48usize,
        concat!("Size of: ", stringify!(hipStreamBatchMemOpParams_union))
    );
    assert_eq!(
        ::std::mem::align_of::<hipStreamBatchMemOpParams_union>(),
        8usize,
        concat!("Alignment of ", stringify!(hipStreamBatchMemOpParams_union))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).operation) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipStreamBatchMemOpParams_union),
            "::",
            stringify!(operation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).waitValue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipStreamBatchMemOpParams_union),
            "::",
            stringify!(waitValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).writeValue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipStreamBatchMemOpParams_union),
            "::",
            stringify!(writeValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flushRemoteWrites) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipStreamBatchMemOpParams_union),
            "::",
            stringify!(flushRemoteWrites)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memoryBarrier) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipStreamBatchMemOpParams_union),
            "::",
            stringify!(memoryBarrier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipStreamBatchMemOpParams_union),
            "::",
            stringify!(pad)
        )
    );
}
impl Default for hipStreamBatchMemOpParams_union {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Union representing batch memory operation parameters for HIP streams.\n\n hipStreamBatchMemOpParams is used to specify the parameters for batch memory\n operations in a HIP stream. This union supports various operations including\n waiting for a specific value, writing a value, and different flags for wait conditions.\n\n @details\n The union includes fields for different types of operations defined in the\n enum hipStreamBatchMemOpType:\n - hipStreamMemOpWaitValue32:  Wait for a 32-bit value.\n - hipStreamMemOpWriteValue32: Write a 32-bit value.\n - hipStreamMemOpWaitValue64:  Wait for a 64-bit value.\n - hipStreamMemOpWriteValue64: Write a 64-bit value.\n\n Each operation type includes an address, the value to wait for or write, flags, and an\n optional alias that is not relevant on AMD GPUs. Flags can be used to specify different\n wait conditions such as equality, bitwise AND, greater than or equal, and bitwise NOR.\n\n Example usage:\n @code\n hipStreamBatchMemOpParams myArray[2];\n myArray[0].operation = hipStreamMemOpWaitValue32;\n myArray[0].waitValue.address = waitAddr1;\n myArray[0].waitValue.value = 0x1;\n myArray[0].waitValue.flags = CU_STREAM_WAIT_VALUE_EQ;\n\n myArray[1].operation = hipStreamMemOpWriteValue32;\n myArray[1].writeValue.address = writeAddr1;\n myArray[1].writeValue.value = 0x1;\n myArray[1].writeValue.flags = 0x0;\n\n result = hipStreamBatchMemOp(stream, 2, myArray, 0);\n @endcode"]
pub type hipStreamBatchMemOpParams = hipStreamBatchMemOpParams_union;
#[doc = " @brief Structure representing node parameters for batch memory operations in HIP graphs.\n\n hipBatchMemOpNodeParams is used to specify the parameters for batch memory\n operations in HIP graphs. This struct includes the context to use for the operations, the\n number of operations, and an array of hipStreamBatchMemOpParams that describe the operations.\n\n @details\n The structure includes the following fields:\n - ctx: The HIP context to use for the operations.\n - count: The number of operations in the paramArray.\n - paramArray: A pointer to an array of hipStreamBatchMemOpParams.\n - flags: Flags to control the node.\n\n Example usage:\n @code\n hipBatchMemOpNodeParams nodeParams;\n nodeParams.ctx = context;\n nodeParams.count = ARRAY_SIZE;\n nodeParams.paramArray = myArray;\n nodeParams.flags = 0;\n\n Pass nodeParams to a HIP graph APIs hipGraphAddBatchMemOpNode, hipGraphBatchMemOpNodeGetParams,\n hipGraphBatchMemOpNodeSetParams, hipGraphExecBatchMemOpNodeSetParams\n @endcode"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipBatchMemOpNodeParams {
    pub ctx: hipCtx_t,
    pub count: ::libc::c_uint,
    pub paramArray: *mut hipStreamBatchMemOpParams,
    pub flags: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_hipBatchMemOpNodeParams() {
    const UNINIT: ::std::mem::MaybeUninit<hipBatchMemOpNodeParams> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipBatchMemOpNodeParams>(),
        32usize,
        concat!("Size of: ", stringify!(hipBatchMemOpNodeParams))
    );
    assert_eq!(
        ::std::mem::align_of::<hipBatchMemOpNodeParams>(),
        8usize,
        concat!("Alignment of ", stringify!(hipBatchMemOpNodeParams))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipBatchMemOpNodeParams),
            "::",
            stringify!(ctx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipBatchMemOpNodeParams),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).paramArray) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hipBatchMemOpNodeParams),
            "::",
            stringify!(paramArray)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hipBatchMemOpNodeParams),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for hipBatchMemOpNodeParams {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " HIP Memory Advise values\n\n @note This memory advise enumeration is used on Linux, not Windows."]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipMemoryAdvise {
    #[doc = "< Data will mostly be read and only occassionally\n< be written to"]
    hipMemAdviseSetReadMostly = 1,
    #[doc = "< Undo the effect of hipMemAdviseSetReadMostly"]
    hipMemAdviseUnsetReadMostly = 2,
    #[doc = "< Set the preferred location for the data as\n< the specified device"]
    hipMemAdviseSetPreferredLocation = 3,
    #[doc = "< Clear the preferred location for the data"]
    hipMemAdviseUnsetPreferredLocation = 4,
    #[doc = "< Data will be accessed by the specified device\n< so prevent page faults as much as possible"]
    hipMemAdviseSetAccessedBy = 5,
    #[doc = "< Let HIP to decide on the page faulting policy\n< for the specified device"]
    hipMemAdviseUnsetAccessedBy = 6,
    #[doc = "< The default memory model is fine-grain. That allows\n< coherent operations between host and device, while\n< executing kernels. The coarse-grain can be used\n< for data that only needs to be coherent at dispatch\n< boundaries for better performance"]
    hipMemAdviseSetCoarseGrain = 100,
    #[doc = "< Restores cache coherency policy back to fine-grain"]
    hipMemAdviseUnsetCoarseGrain = 101,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " HIP Coherency Mode"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipMemRangeCoherencyMode {
    #[doc = "< Updates to memory with this attribute can be\n< done coherently from all devices"]
    hipMemRangeCoherencyModeFineGrain = 0,
    #[doc = "< Writes to memory with this attribute can be\n< performed by a single device at a time"]
    hipMemRangeCoherencyModeCoarseGrain = 1,
    #[doc = "< Memory region queried contains subregions with\n< both hipMemRangeCoherencyModeFineGrain and\n< hipMemRangeCoherencyModeCoarseGrain attributes"]
    hipMemRangeCoherencyModeIndeterminate = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " HIP range attributes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipMemRangeAttribute {
    #[doc = "< Whether the range will mostly be read and\n< only occassionally be written to"]
    hipMemRangeAttributeReadMostly = 1,
    #[doc = "< The preferred location of the range"]
    hipMemRangeAttributePreferredLocation = 2,
    #[doc = "< Memory range has hipMemAdviseSetAccessedBy\n< set for the specified device"]
    hipMemRangeAttributeAccessedBy = 3,
    #[doc = "< The last location to where the range was\n< prefetched"]
    hipMemRangeAttributeLastPrefetchLocation = 4,
    #[doc = "< Returns coherency mode\n< @ref hipMemRangeCoherencyMode for the range"]
    hipMemRangeAttributeCoherencyMode = 100,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " HIP memory pool attributes"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipMemPoolAttr {
    #[doc = " (value type = int)\n Allow @p hipMemAllocAsync to use memory asynchronously freed\n in another streams as long as a stream ordering dependency\n of the allocating stream on the free action exists.\n hip events and null stream interactions can create the required\n stream ordered dependencies. (default enabled)"]
    hipMemPoolReuseFollowEventDependencies = 1,
    #[doc = " (value type = int)\n Allow reuse of already completed frees when there is no dependency\n between the free and allocation. (default enabled)"]
    hipMemPoolReuseAllowOpportunistic = 2,
    #[doc = " (value type = int)\n Allow @p hipMemAllocAsync to insert new stream dependencies\n in order to establish the stream ordering required to reuse\n a piece of memory released by cuFreeAsync (default enabled)."]
    hipMemPoolReuseAllowInternalDependencies = 3,
    #[doc = " (value type = uint64_t)\n Amount of reserved memory in bytes to hold onto before trying\n to release memory back to the OS. When more than the release\n threshold bytes of memory are held by the memory pool, the\n allocator will try to release memory back to the OS on the\n next call to stream, event or context synchronize. (default 0)"]
    hipMemPoolAttrReleaseThreshold = 4,
    #[doc = " (value type = uint64_t)\n Amount of backing memory currently allocated for the mempool."]
    hipMemPoolAttrReservedMemCurrent = 5,
    #[doc = " (value type = uint64_t)\n High watermark of backing memory allocated for the mempool since the\n last time it was reset. High watermark can only be reset to zero."]
    hipMemPoolAttrReservedMemHigh = 6,
    #[doc = " (value type = uint64_t)\n Amount of memory from the pool that is currently in use by the application."]
    hipMemPoolAttrUsedMemCurrent = 7,
    #[doc = " (value type = uint64_t)\n High watermark of the amount of memory from the pool that was in use by the application since\n the last time it was reset. High watermark can only be reset to zero."]
    hipMemPoolAttrUsedMemHigh = 8,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Specifies the type of location"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipMemLocationType {
    hipMemLocationTypeInvalid = 0,
    #[doc = "< Device location, thus it's HIP device ID"]
    hipMemLocationTypeDevice = 1,
}
#[doc = " Specifies a memory location.\n\n To specify a gpu, set type = @p hipMemLocationTypeDevice and set id = the gpu's device ID"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipMemLocation {
    #[doc = "< Specifies the location type, which describes the meaning of id"]
    pub type_: hipMemLocationType,
    #[doc = "< Identifier for the provided location type @p hipMemLocationType"]
    pub id: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_hipMemLocation() {
    const UNINIT: ::std::mem::MaybeUninit<hipMemLocation> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipMemLocation>(),
        8usize,
        concat!("Size of: ", stringify!(hipMemLocation))
    );
    assert_eq!(
        ::std::mem::align_of::<hipMemLocation>(),
        4usize,
        concat!("Alignment of ", stringify!(hipMemLocation))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMemLocation),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMemLocation),
            "::",
            stringify!(id)
        )
    );
}
impl Default for hipMemLocation {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Specifies the memory protection flags for mapping\n"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipMemAccessFlags {
    #[doc = "< Default, make the address range not accessible"]
    hipMemAccessFlagsProtNone = 0,
    #[doc = "< Set the address range read accessible"]
    hipMemAccessFlagsProtRead = 1,
    #[doc = "< Set the address range read-write accessible"]
    hipMemAccessFlagsProtReadWrite = 3,
}
#[doc = " Memory access descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipMemAccessDesc {
    #[doc = "< Location on which the accessibility has to change"]
    pub location: hipMemLocation,
    #[doc = "< Accessibility flags to set"]
    pub flags: hipMemAccessFlags,
}
#[test]
fn bindgen_test_layout_hipMemAccessDesc() {
    const UNINIT: ::std::mem::MaybeUninit<hipMemAccessDesc> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipMemAccessDesc>(),
        12usize,
        concat!("Size of: ", stringify!(hipMemAccessDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<hipMemAccessDesc>(),
        4usize,
        concat!("Alignment of ", stringify!(hipMemAccessDesc))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).location) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMemAccessDesc),
            "::",
            stringify!(location)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMemAccessDesc),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for hipMemAccessDesc {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Defines the allocation types"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipMemAllocationType {
    hipMemAllocationTypeInvalid = 0,
    #[doc = " This allocation type is 'pinned', i.e. cannot migrate from its current\n location while the application is actively using it"]
    hipMemAllocationTypePinned = 1,
    #[doc = " This allocation type is 'pinned', i.e. cannot migrate from its current\n location while the application is actively using it"]
    hipMemAllocationTypeMax = 2147483647,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Flags for specifying handle types for memory pool allocations\n"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipMemAllocationHandleType {
    #[doc = "< Does not allow any export mechanism"]
    hipMemHandleTypeNone = 0,
    #[doc = "< Allows a file descriptor for exporting. Permitted only on POSIX systems"]
    hipMemHandleTypePosixFileDescriptor = 1,
    #[doc = "< Allows a Win32 NT handle for exporting. (HANDLE)"]
    hipMemHandleTypeWin32 = 2,
    #[doc = "< Allows a Win32 KMT handle for exporting. (D3DKMT_HANDLE)"]
    hipMemHandleTypeWin32Kmt = 4,
}
#[doc = " Specifies the properties of allocations made from the pool."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipMemPoolProps {
    #[doc = "< Allocation type. Currently must be specified as @p hipMemAllocationTypePinned"]
    pub allocType: hipMemAllocationType,
    #[doc = "< Handle types that will be supported by allocations from the pool"]
    pub handleTypes: hipMemAllocationHandleType,
    #[doc = "< Location where allocations should reside"]
    pub location: hipMemLocation,
    #[doc = " Windows-specific LPSECURITYATTRIBUTES required when @p hipMemHandleTypeWin32 is specified"]
    pub win32SecurityAttributes: *mut ::libc::c_void,
    #[doc = "< Maximum pool size. When set to 0, defaults to a system dependent value"]
    pub maxSize: usize,
    #[doc = "< Reserved for future use, must be 0"]
    pub reserved: [::libc::c_uchar; 56usize],
}
#[test]
fn bindgen_test_layout_hipMemPoolProps() {
    const UNINIT: ::std::mem::MaybeUninit<hipMemPoolProps> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipMemPoolProps>(),
        88usize,
        concat!("Size of: ", stringify!(hipMemPoolProps))
    );
    assert_eq!(
        ::std::mem::align_of::<hipMemPoolProps>(),
        8usize,
        concat!("Alignment of ", stringify!(hipMemPoolProps))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMemPoolProps),
            "::",
            stringify!(allocType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handleTypes) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMemPoolProps),
            "::",
            stringify!(handleTypes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).location) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMemPoolProps),
            "::",
            stringify!(location)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).win32SecurityAttributes) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMemPoolProps),
            "::",
            stringify!(win32SecurityAttributes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxSize) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMemPoolProps),
            "::",
            stringify!(maxSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMemPoolProps),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for hipMemPoolProps {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Opaque data structure for exporting a pool allocation"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipMemPoolPtrExportData {
    pub reserved: [::libc::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout_hipMemPoolPtrExportData() {
    const UNINIT: ::std::mem::MaybeUninit<hipMemPoolPtrExportData> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipMemPoolPtrExportData>(),
        64usize,
        concat!("Size of: ", stringify!(hipMemPoolPtrExportData))
    );
    assert_eq!(
        ::std::mem::align_of::<hipMemPoolPtrExportData>(),
        1usize,
        concat!("Alignment of ", stringify!(hipMemPoolPtrExportData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMemPoolPtrExportData),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for hipMemPoolPtrExportData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " @warning On AMD devices and some Nvidia devices, these hints and controls are ignored."]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipFuncAttribute {
    hipFuncAttributeMaxDynamicSharedMemorySize = 8,
    hipFuncAttributePreferredSharedMemoryCarveout = 9,
    hipFuncAttributeMax = 10,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " @warning On AMD devices and some Nvidia devices, these hints and controls are ignored."]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipFuncCache_t {
    #[doc = "< no preference for shared memory or L1 (default)"]
    hipFuncCachePreferNone = 0,
    #[doc = "< prefer larger shared memory and smaller L1 cache"]
    hipFuncCachePreferShared = 1,
    #[doc = "< prefer larger L1 cache and smaller shared memory"]
    hipFuncCachePreferL1 = 2,
    #[doc = "< prefer equal size L1 cache and shared memory"]
    hipFuncCachePreferEqual = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " @warning On AMD devices and some Nvidia devices, these hints and controls are ignored."]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipSharedMemConfig {
    #[doc = "< The compiler selects a device-specific value for the banking."]
    hipSharedMemBankSizeDefault = 0,
    #[doc = "< Shared mem is banked at 4-bytes intervals and performs best\n< when adjacent threads access data 4 bytes apart."]
    hipSharedMemBankSizeFourByte = 1,
    #[doc = "< Shared mem is banked at 8-byte intervals and performs best\n< when adjacent threads access data 4 bytes apart."]
    hipSharedMemBankSizeEightByte = 2,
}
#[doc = " Struct for data in 3D"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct dim3 {
    #[doc = "< x"]
    pub x: u32,
    #[doc = "< y"]
    pub y: u32,
    #[doc = "< z"]
    pub z: u32,
}
#[test]
fn bindgen_test_layout_dim3() {
    const UNINIT: ::std::mem::MaybeUninit<dim3> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<dim3>(),
        12usize,
        concat!("Size of: ", stringify!(dim3))
    );
    assert_eq!(
        ::std::mem::align_of::<dim3>(),
        4usize,
        concat!("Alignment of ", stringify!(dim3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(dim3), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!("Offset of field: ", stringify!(dim3), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(dim3), "::", stringify!(z))
    );
}
#[doc = " struct hipLaunchParams_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipLaunchParams_t {
    #[doc = "< Device function symbol"]
    pub func: *mut ::libc::c_void,
    #[doc = "< Grid dimensions"]
    pub gridDim: dim3,
    #[doc = "< Block dimensions"]
    pub blockDim: dim3,
    #[doc = "< Arguments"]
    pub args: *mut *mut ::libc::c_void,
    #[doc = "< Shared memory"]
    pub sharedMem: usize,
    #[doc = "< Stream identifier"]
    pub stream: hipStream_t,
}
#[test]
fn bindgen_test_layout_hipLaunchParams_t() {
    const UNINIT: ::std::mem::MaybeUninit<hipLaunchParams_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipLaunchParams_t>(),
        56usize,
        concat!("Size of: ", stringify!(hipLaunchParams_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hipLaunchParams_t>(),
        8usize,
        concat!("Alignment of ", stringify!(hipLaunchParams_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipLaunchParams_t),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gridDim) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipLaunchParams_t),
            "::",
            stringify!(gridDim)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blockDim) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(hipLaunchParams_t),
            "::",
            stringify!(blockDim)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).args) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hipLaunchParams_t),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sharedMem) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hipLaunchParams_t),
            "::",
            stringify!(sharedMem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stream) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hipLaunchParams_t),
            "::",
            stringify!(stream)
        )
    );
}
impl Default for hipLaunchParams_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " struct hipLaunchParams_t"]
pub type hipLaunchParams = hipLaunchParams_t;
#[doc = " struct hipFunctionLaunchParams_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipFunctionLaunchParams_t {
    #[doc = "< Kernel to launch"]
    pub function: hipFunction_t,
    #[doc = "< Width(X) of grid in blocks"]
    pub gridDimX: ::libc::c_uint,
    #[doc = "< Height(Y) of grid in blocks"]
    pub gridDimY: ::libc::c_uint,
    #[doc = "< Depth(Z) of grid in blocks"]
    pub gridDimZ: ::libc::c_uint,
    #[doc = "< X dimension of each thread block"]
    pub blockDimX: ::libc::c_uint,
    #[doc = "< Y dimension of each thread block"]
    pub blockDimY: ::libc::c_uint,
    #[doc = "< Z dimension of each thread block"]
    pub blockDimZ: ::libc::c_uint,
    #[doc = "< Shared memory"]
    pub sharedMemBytes: ::libc::c_uint,
    #[doc = "< Stream identifier"]
    pub hStream: hipStream_t,
    #[doc = "< Kernel parameters"]
    pub kernelParams: *mut *mut ::libc::c_void,
}
#[test]
fn bindgen_test_layout_hipFunctionLaunchParams_t() {
    const UNINIT: ::std::mem::MaybeUninit<hipFunctionLaunchParams_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipFunctionLaunchParams_t>(),
        56usize,
        concat!("Size of: ", stringify!(hipFunctionLaunchParams_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hipFunctionLaunchParams_t>(),
        8usize,
        concat!("Alignment of ", stringify!(hipFunctionLaunchParams_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).function) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipFunctionLaunchParams_t),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gridDimX) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipFunctionLaunchParams_t),
            "::",
            stringify!(gridDimX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gridDimY) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hipFunctionLaunchParams_t),
            "::",
            stringify!(gridDimY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gridDimZ) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hipFunctionLaunchParams_t),
            "::",
            stringify!(gridDimZ)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blockDimX) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(hipFunctionLaunchParams_t),
            "::",
            stringify!(blockDimX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blockDimY) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hipFunctionLaunchParams_t),
            "::",
            stringify!(blockDimY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blockDimZ) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(hipFunctionLaunchParams_t),
            "::",
            stringify!(blockDimZ)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sharedMemBytes) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hipFunctionLaunchParams_t),
            "::",
            stringify!(sharedMemBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hStream) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hipFunctionLaunchParams_t),
            "::",
            stringify!(hStream)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kernelParams) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hipFunctionLaunchParams_t),
            "::",
            stringify!(kernelParams)
        )
    );
}
impl Default for hipFunctionLaunchParams_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " struct hipFunctionLaunchParams_t"]
pub type hipFunctionLaunchParams = hipFunctionLaunchParams_t;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipExternalMemoryHandleType_enum {
    hipExternalMemoryHandleTypeOpaqueFd = 1,
    hipExternalMemoryHandleTypeOpaqueWin32 = 2,
    hipExternalMemoryHandleTypeOpaqueWin32Kmt = 3,
    hipExternalMemoryHandleTypeD3D12Heap = 4,
    hipExternalMemoryHandleTypeD3D12Resource = 5,
    hipExternalMemoryHandleTypeD3D11Resource = 6,
    hipExternalMemoryHandleTypeD3D11ResourceKmt = 7,
    hipExternalMemoryHandleTypeNvSciBuf = 8,
}
pub use self::hipExternalMemoryHandleType_enum as hipExternalMemoryHandleType;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hipExternalMemoryHandleDesc_st {
    pub type_: hipExternalMemoryHandleType,
    pub handle: hipExternalMemoryHandleDesc_st__bindgen_ty_1,
    pub size: ::libc::c_ulonglong,
    pub flags: ::libc::c_uint,
    pub reserved: [::libc::c_uint; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hipExternalMemoryHandleDesc_st__bindgen_ty_1 {
    pub fd: ::libc::c_int,
    pub win32: hipExternalMemoryHandleDesc_st__bindgen_ty_1__bindgen_ty_1,
    pub nvSciBufObject: *const ::libc::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipExternalMemoryHandleDesc_st__bindgen_ty_1__bindgen_ty_1 {
    pub handle: *mut ::libc::c_void,
    pub name: *const ::libc::c_void,
}
#[test]
fn bindgen_test_layout_hipExternalMemoryHandleDesc_st__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        hipExternalMemoryHandleDesc_st__bindgen_ty_1__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipExternalMemoryHandleDesc_st__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(hipExternalMemoryHandleDesc_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hipExternalMemoryHandleDesc_st__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hipExternalMemoryHandleDesc_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExternalMemoryHandleDesc_st__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExternalMemoryHandleDesc_st__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(name)
        )
    );
}
impl Default for hipExternalMemoryHandleDesc_st__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_hipExternalMemoryHandleDesc_st__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<hipExternalMemoryHandleDesc_st__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipExternalMemoryHandleDesc_st__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(hipExternalMemoryHandleDesc_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hipExternalMemoryHandleDesc_st__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hipExternalMemoryHandleDesc_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExternalMemoryHandleDesc_st__bindgen_ty_1),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).win32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExternalMemoryHandleDesc_st__bindgen_ty_1),
            "::",
            stringify!(win32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nvSciBufObject) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExternalMemoryHandleDesc_st__bindgen_ty_1),
            "::",
            stringify!(nvSciBufObject)
        )
    );
}
impl Default for hipExternalMemoryHandleDesc_st__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_hipExternalMemoryHandleDesc_st() {
    const UNINIT: ::std::mem::MaybeUninit<hipExternalMemoryHandleDesc_st> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipExternalMemoryHandleDesc_st>(),
        104usize,
        concat!("Size of: ", stringify!(hipExternalMemoryHandleDesc_st))
    );
    assert_eq!(
        ::std::mem::align_of::<hipExternalMemoryHandleDesc_st>(),
        8usize,
        concat!("Alignment of ", stringify!(hipExternalMemoryHandleDesc_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExternalMemoryHandleDesc_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExternalMemoryHandleDesc_st),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExternalMemoryHandleDesc_st),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExternalMemoryHandleDesc_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExternalMemoryHandleDesc_st),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for hipExternalMemoryHandleDesc_st {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type hipExternalMemoryHandleDesc = hipExternalMemoryHandleDesc_st;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipExternalMemoryBufferDesc_st {
    pub offset: ::libc::c_ulonglong,
    pub size: ::libc::c_ulonglong,
    pub flags: ::libc::c_uint,
    pub reserved: [::libc::c_uint; 16usize],
}
#[test]
fn bindgen_test_layout_hipExternalMemoryBufferDesc_st() {
    const UNINIT: ::std::mem::MaybeUninit<hipExternalMemoryBufferDesc_st> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipExternalMemoryBufferDesc_st>(),
        88usize,
        concat!("Size of: ", stringify!(hipExternalMemoryBufferDesc_st))
    );
    assert_eq!(
        ::std::mem::align_of::<hipExternalMemoryBufferDesc_st>(),
        8usize,
        concat!("Alignment of ", stringify!(hipExternalMemoryBufferDesc_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExternalMemoryBufferDesc_st),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExternalMemoryBufferDesc_st),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExternalMemoryBufferDesc_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExternalMemoryBufferDesc_st),
            "::",
            stringify!(reserved)
        )
    );
}
pub type hipExternalMemoryBufferDesc = hipExternalMemoryBufferDesc_st;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipExternalMemoryMipmappedArrayDesc_st {
    pub offset: ::libc::c_ulonglong,
    pub formatDesc: hipChannelFormatDesc,
    pub extent: hipExtent,
    pub flags: ::libc::c_uint,
    pub numLevels: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_hipExternalMemoryMipmappedArrayDesc_st() {
    const UNINIT: ::std::mem::MaybeUninit<hipExternalMemoryMipmappedArrayDesc_st> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipExternalMemoryMipmappedArrayDesc_st>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(hipExternalMemoryMipmappedArrayDesc_st)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hipExternalMemoryMipmappedArrayDesc_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hipExternalMemoryMipmappedArrayDesc_st)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExternalMemoryMipmappedArrayDesc_st),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).formatDesc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExternalMemoryMipmappedArrayDesc_st),
            "::",
            stringify!(formatDesc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extent) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExternalMemoryMipmappedArrayDesc_st),
            "::",
            stringify!(extent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExternalMemoryMipmappedArrayDesc_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numLevels) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExternalMemoryMipmappedArrayDesc_st),
            "::",
            stringify!(numLevels)
        )
    );
}
impl Default for hipExternalMemoryMipmappedArrayDesc_st {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type hipExternalMemoryMipmappedArrayDesc = hipExternalMemoryMipmappedArrayDesc_st;
pub type hipExternalMemory_t = *mut ::libc::c_void;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipExternalSemaphoreHandleType_enum {
    hipExternalSemaphoreHandleTypeOpaqueFd = 1,
    hipExternalSemaphoreHandleTypeOpaqueWin32 = 2,
    hipExternalSemaphoreHandleTypeOpaqueWin32Kmt = 3,
    hipExternalSemaphoreHandleTypeD3D12Fence = 4,
    hipExternalSemaphoreHandleTypeD3D11Fence = 5,
    hipExternalSemaphoreHandleTypeNvSciSync = 6,
    hipExternalSemaphoreHandleTypeKeyedMutex = 7,
    hipExternalSemaphoreHandleTypeKeyedMutexKmt = 8,
    hipExternalSemaphoreHandleTypeTimelineSemaphoreFd = 9,
    hipExternalSemaphoreHandleTypeTimelineSemaphoreWin32 = 10,
}
pub use self::hipExternalSemaphoreHandleType_enum as hipExternalSemaphoreHandleType;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hipExternalSemaphoreHandleDesc_st {
    pub type_: hipExternalSemaphoreHandleType,
    pub handle: hipExternalSemaphoreHandleDesc_st__bindgen_ty_1,
    pub flags: ::libc::c_uint,
    pub reserved: [::libc::c_uint; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hipExternalSemaphoreHandleDesc_st__bindgen_ty_1 {
    pub fd: ::libc::c_int,
    pub win32: hipExternalSemaphoreHandleDesc_st__bindgen_ty_1__bindgen_ty_1,
    pub NvSciSyncObj: *const ::libc::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipExternalSemaphoreHandleDesc_st__bindgen_ty_1__bindgen_ty_1 {
    pub handle: *mut ::libc::c_void,
    pub name: *const ::libc::c_void,
}
#[test]
fn bindgen_test_layout_hipExternalSemaphoreHandleDesc_st__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        hipExternalSemaphoreHandleDesc_st__bindgen_ty_1__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipExternalSemaphoreHandleDesc_st__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(hipExternalSemaphoreHandleDesc_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hipExternalSemaphoreHandleDesc_st__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hipExternalSemaphoreHandleDesc_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExternalSemaphoreHandleDesc_st__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExternalSemaphoreHandleDesc_st__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(name)
        )
    );
}
impl Default for hipExternalSemaphoreHandleDesc_st__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_hipExternalSemaphoreHandleDesc_st__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<hipExternalSemaphoreHandleDesc_st__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipExternalSemaphoreHandleDesc_st__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(hipExternalSemaphoreHandleDesc_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hipExternalSemaphoreHandleDesc_st__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hipExternalSemaphoreHandleDesc_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExternalSemaphoreHandleDesc_st__bindgen_ty_1),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).win32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExternalSemaphoreHandleDesc_st__bindgen_ty_1),
            "::",
            stringify!(win32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NvSciSyncObj) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExternalSemaphoreHandleDesc_st__bindgen_ty_1),
            "::",
            stringify!(NvSciSyncObj)
        )
    );
}
impl Default for hipExternalSemaphoreHandleDesc_st__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_hipExternalSemaphoreHandleDesc_st() {
    const UNINIT: ::std::mem::MaybeUninit<hipExternalSemaphoreHandleDesc_st> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipExternalSemaphoreHandleDesc_st>(),
        96usize,
        concat!("Size of: ", stringify!(hipExternalSemaphoreHandleDesc_st))
    );
    assert_eq!(
        ::std::mem::align_of::<hipExternalSemaphoreHandleDesc_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hipExternalSemaphoreHandleDesc_st)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExternalSemaphoreHandleDesc_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExternalSemaphoreHandleDesc_st),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExternalSemaphoreHandleDesc_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExternalSemaphoreHandleDesc_st),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for hipExternalSemaphoreHandleDesc_st {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type hipExternalSemaphoreHandleDesc = hipExternalSemaphoreHandleDesc_st;
pub type hipExternalSemaphore_t = *mut ::libc::c_void;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hipExternalSemaphoreSignalParams_st {
    pub params: hipExternalSemaphoreSignalParams_st__bindgen_ty_1,
    pub flags: ::libc::c_uint,
    pub reserved: [::libc::c_uint; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hipExternalSemaphoreSignalParams_st__bindgen_ty_1 {
    pub fence: hipExternalSemaphoreSignalParams_st__bindgen_ty_1__bindgen_ty_1,
    pub nvSciSync: hipExternalSemaphoreSignalParams_st__bindgen_ty_1__bindgen_ty_2,
    pub keyedMutex: hipExternalSemaphoreSignalParams_st__bindgen_ty_1__bindgen_ty_3,
    pub reserved: [::libc::c_uint; 12usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipExternalSemaphoreSignalParams_st__bindgen_ty_1__bindgen_ty_1 {
    pub value: ::libc::c_ulonglong,
}
#[test]
fn bindgen_test_layout_hipExternalSemaphoreSignalParams_st__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        hipExternalSemaphoreSignalParams_st__bindgen_ty_1__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipExternalSemaphoreSignalParams_st__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hipExternalSemaphoreSignalParams_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hipExternalSemaphoreSignalParams_st__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hipExternalSemaphoreSignalParams_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExternalSemaphoreSignalParams_st__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hipExternalSemaphoreSignalParams_st__bindgen_ty_1__bindgen_ty_2 {
    pub fence: *mut ::libc::c_void,
    pub reserved: ::libc::c_ulonglong,
}
#[test]
fn bindgen_test_layout_hipExternalSemaphoreSignalParams_st__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<
        hipExternalSemaphoreSignalParams_st__bindgen_ty_1__bindgen_ty_2,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipExternalSemaphoreSignalParams_st__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hipExternalSemaphoreSignalParams_st__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hipExternalSemaphoreSignalParams_st__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hipExternalSemaphoreSignalParams_st__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExternalSemaphoreSignalParams_st__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(fence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExternalSemaphoreSignalParams_st__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for hipExternalSemaphoreSignalParams_st__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipExternalSemaphoreSignalParams_st__bindgen_ty_1__bindgen_ty_3 {
    pub key: ::libc::c_ulonglong,
}
#[test]
fn bindgen_test_layout_hipExternalSemaphoreSignalParams_st__bindgen_ty_1__bindgen_ty_3() {
    const UNINIT: ::std::mem::MaybeUninit<
        hipExternalSemaphoreSignalParams_st__bindgen_ty_1__bindgen_ty_3,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipExternalSemaphoreSignalParams_st__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hipExternalSemaphoreSignalParams_st__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hipExternalSemaphoreSignalParams_st__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hipExternalSemaphoreSignalParams_st__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExternalSemaphoreSignalParams_st__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(key)
        )
    );
}
#[test]
fn bindgen_test_layout_hipExternalSemaphoreSignalParams_st__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<hipExternalSemaphoreSignalParams_st__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipExternalSemaphoreSignalParams_st__bindgen_ty_1>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(hipExternalSemaphoreSignalParams_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hipExternalSemaphoreSignalParams_st__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hipExternalSemaphoreSignalParams_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExternalSemaphoreSignalParams_st__bindgen_ty_1),
            "::",
            stringify!(fence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nvSciSync) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExternalSemaphoreSignalParams_st__bindgen_ty_1),
            "::",
            stringify!(nvSciSync)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keyedMutex) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExternalSemaphoreSignalParams_st__bindgen_ty_1),
            "::",
            stringify!(keyedMutex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExternalSemaphoreSignalParams_st__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for hipExternalSemaphoreSignalParams_st__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_hipExternalSemaphoreSignalParams_st() {
    const UNINIT: ::std::mem::MaybeUninit<hipExternalSemaphoreSignalParams_st> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipExternalSemaphoreSignalParams_st>(),
        144usize,
        concat!("Size of: ", stringify!(hipExternalSemaphoreSignalParams_st))
    );
    assert_eq!(
        ::std::mem::align_of::<hipExternalSemaphoreSignalParams_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hipExternalSemaphoreSignalParams_st)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).params) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExternalSemaphoreSignalParams_st),
            "::",
            stringify!(params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExternalSemaphoreSignalParams_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExternalSemaphoreSignalParams_st),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for hipExternalSemaphoreSignalParams_st {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type hipExternalSemaphoreSignalParams = hipExternalSemaphoreSignalParams_st;
#[doc = " External semaphore wait parameters, compatible with driver type"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hipExternalSemaphoreWaitParams_st {
    pub params: hipExternalSemaphoreWaitParams_st__bindgen_ty_1,
    pub flags: ::libc::c_uint,
    pub reserved: [::libc::c_uint; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hipExternalSemaphoreWaitParams_st__bindgen_ty_1 {
    pub fence: hipExternalSemaphoreWaitParams_st__bindgen_ty_1__bindgen_ty_1,
    pub nvSciSync: hipExternalSemaphoreWaitParams_st__bindgen_ty_1__bindgen_ty_2,
    pub keyedMutex: hipExternalSemaphoreWaitParams_st__bindgen_ty_1__bindgen_ty_3,
    pub reserved: [::libc::c_uint; 10usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipExternalSemaphoreWaitParams_st__bindgen_ty_1__bindgen_ty_1 {
    pub value: ::libc::c_ulonglong,
}
#[test]
fn bindgen_test_layout_hipExternalSemaphoreWaitParams_st__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        hipExternalSemaphoreWaitParams_st__bindgen_ty_1__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipExternalSemaphoreWaitParams_st__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hipExternalSemaphoreWaitParams_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hipExternalSemaphoreWaitParams_st__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hipExternalSemaphoreWaitParams_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExternalSemaphoreWaitParams_st__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hipExternalSemaphoreWaitParams_st__bindgen_ty_1__bindgen_ty_2 {
    pub fence: *mut ::libc::c_void,
    pub reserved: ::libc::c_ulonglong,
}
#[test]
fn bindgen_test_layout_hipExternalSemaphoreWaitParams_st__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<
        hipExternalSemaphoreWaitParams_st__bindgen_ty_1__bindgen_ty_2,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipExternalSemaphoreWaitParams_st__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hipExternalSemaphoreWaitParams_st__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hipExternalSemaphoreWaitParams_st__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hipExternalSemaphoreWaitParams_st__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExternalSemaphoreWaitParams_st__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(fence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExternalSemaphoreWaitParams_st__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for hipExternalSemaphoreWaitParams_st__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipExternalSemaphoreWaitParams_st__bindgen_ty_1__bindgen_ty_3 {
    pub key: ::libc::c_ulonglong,
    pub timeoutMs: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_hipExternalSemaphoreWaitParams_st__bindgen_ty_1__bindgen_ty_3() {
    const UNINIT: ::std::mem::MaybeUninit<
        hipExternalSemaphoreWaitParams_st__bindgen_ty_1__bindgen_ty_3,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipExternalSemaphoreWaitParams_st__bindgen_ty_1__bindgen_ty_3>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(hipExternalSemaphoreWaitParams_st__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hipExternalSemaphoreWaitParams_st__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hipExternalSemaphoreWaitParams_st__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExternalSemaphoreWaitParams_st__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeoutMs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExternalSemaphoreWaitParams_st__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(timeoutMs)
        )
    );
}
#[test]
fn bindgen_test_layout_hipExternalSemaphoreWaitParams_st__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<hipExternalSemaphoreWaitParams_st__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipExternalSemaphoreWaitParams_st__bindgen_ty_1>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(hipExternalSemaphoreWaitParams_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hipExternalSemaphoreWaitParams_st__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hipExternalSemaphoreWaitParams_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExternalSemaphoreWaitParams_st__bindgen_ty_1),
            "::",
            stringify!(fence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nvSciSync) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExternalSemaphoreWaitParams_st__bindgen_ty_1),
            "::",
            stringify!(nvSciSync)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keyedMutex) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExternalSemaphoreWaitParams_st__bindgen_ty_1),
            "::",
            stringify!(keyedMutex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExternalSemaphoreWaitParams_st__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for hipExternalSemaphoreWaitParams_st__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_hipExternalSemaphoreWaitParams_st() {
    const UNINIT: ::std::mem::MaybeUninit<hipExternalSemaphoreWaitParams_st> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipExternalSemaphoreWaitParams_st>(),
        144usize,
        concat!("Size of: ", stringify!(hipExternalSemaphoreWaitParams_st))
    );
    assert_eq!(
        ::std::mem::align_of::<hipExternalSemaphoreWaitParams_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hipExternalSemaphoreWaitParams_st)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).params) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExternalSemaphoreWaitParams_st),
            "::",
            stringify!(params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExternalSemaphoreWaitParams_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExternalSemaphoreWaitParams_st),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for hipExternalSemaphoreWaitParams_st {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " External semaphore wait parameters, compatible with driver type"]
pub type hipExternalSemaphoreWaitParams = hipExternalSemaphoreWaitParams_st;
#[repr(u32)]
#[non_exhaustive]
#[doc = " HIP Access falgs for Interop resources."]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipGraphicsRegisterFlags {
    hipGraphicsRegisterFlagsNone = 0,
    #[doc = "< HIP will not write to this registered resource"]
    hipGraphicsRegisterFlagsReadOnly = 1,
    hipGraphicsRegisterFlagsWriteDiscard = 2,
    #[doc = "< HIP will bind this resource to a surface"]
    hipGraphicsRegisterFlagsSurfaceLoadStore = 4,
    hipGraphicsRegisterFlagsTextureGather = 8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _hipGraphicsResource {
    _unused: [u8; 0],
}
pub type hipGraphicsResource = _hipGraphicsResource;
pub type hipGraphicsResource_t = *mut hipGraphicsResource;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ihipGraph {
    _unused: [u8; 0],
}
#[doc = " An opaque value that represents a hip graph"]
pub type hipGraph_t = *mut ihipGraph;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipGraphNode {
    _unused: [u8; 0],
}
#[doc = " An opaque value that represents a hip graph node"]
pub type hipGraphNode_t = *mut hipGraphNode;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipGraphExec {
    _unused: [u8; 0],
}
#[doc = " An opaque value that represents a hip graph Exec"]
pub type hipGraphExec_t = *mut hipGraphExec;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipUserObject {
    _unused: [u8; 0],
}
#[doc = " An opaque value that represents a user obj"]
pub type hipUserObject_t = *mut hipUserObject;
#[repr(u32)]
#[non_exhaustive]
#[doc = " hipGraphNodeType"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipGraphNodeType {
    #[doc = "< GPU kernel node"]
    hipGraphNodeTypeKernel = 0,
    #[doc = "< Memcpy node"]
    hipGraphNodeTypeMemcpy = 1,
    #[doc = "< Memset node"]
    hipGraphNodeTypeMemset = 2,
    #[doc = "< Host (executable) node"]
    hipGraphNodeTypeHost = 3,
    #[doc = "< Node which executes an embedded graph"]
    hipGraphNodeTypeGraph = 4,
    #[doc = "< Empty (no-op) node"]
    hipGraphNodeTypeEmpty = 5,
    #[doc = "< External event wait node"]
    hipGraphNodeTypeWaitEvent = 6,
    #[doc = "< External event record node"]
    hipGraphNodeTypeEventRecord = 7,
    #[doc = "< External Semaphore signal node"]
    hipGraphNodeTypeExtSemaphoreSignal = 8,
    #[doc = "< External Semaphore wait node"]
    hipGraphNodeTypeExtSemaphoreWait = 9,
    #[doc = "< Memory alloc node"]
    hipGraphNodeTypeMemAlloc = 10,
    #[doc = "< Memory free node"]
    hipGraphNodeTypeMemFree = 11,
    #[doc = "< MemcpyFromSymbol node"]
    hipGraphNodeTypeMemcpyFromSymbol = 12,
    #[doc = "< MemcpyToSymbol node"]
    hipGraphNodeTypeMemcpyToSymbol = 13,
    #[doc = "< BatchMemOp node"]
    hipGraphNodeTypeBatchMemOp = 14,
    hipGraphNodeTypeCount = 15,
}
pub type hipHostFn_t = ::std::option::Option<unsafe extern "C" fn(userData: *mut ::libc::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipHostNodeParams {
    pub fn_: hipHostFn_t,
    pub userData: *mut ::libc::c_void,
}
#[test]
fn bindgen_test_layout_hipHostNodeParams() {
    const UNINIT: ::std::mem::MaybeUninit<hipHostNodeParams> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipHostNodeParams>(),
        16usize,
        concat!("Size of: ", stringify!(hipHostNodeParams))
    );
    assert_eq!(
        ::std::mem::align_of::<hipHostNodeParams>(),
        8usize,
        concat!("Alignment of ", stringify!(hipHostNodeParams))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fn_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipHostNodeParams),
            "::",
            stringify!(fn_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).userData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipHostNodeParams),
            "::",
            stringify!(userData)
        )
    );
}
impl Default for hipHostNodeParams {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipKernelNodeParams {
    pub blockDim: dim3,
    pub extra: *mut *mut ::libc::c_void,
    pub func: *mut ::libc::c_void,
    pub gridDim: dim3,
    pub kernelParams: *mut *mut ::libc::c_void,
    pub sharedMemBytes: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_hipKernelNodeParams() {
    const UNINIT: ::std::mem::MaybeUninit<hipKernelNodeParams> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipKernelNodeParams>(),
        64usize,
        concat!("Size of: ", stringify!(hipKernelNodeParams))
    );
    assert_eq!(
        ::std::mem::align_of::<hipKernelNodeParams>(),
        8usize,
        concat!("Alignment of ", stringify!(hipKernelNodeParams))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blockDim) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipKernelNodeParams),
            "::",
            stringify!(blockDim)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extra) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hipKernelNodeParams),
            "::",
            stringify!(extra)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hipKernelNodeParams),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gridDim) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hipKernelNodeParams),
            "::",
            stringify!(gridDim)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kernelParams) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hipKernelNodeParams),
            "::",
            stringify!(kernelParams)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sharedMemBytes) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(hipKernelNodeParams),
            "::",
            stringify!(sharedMemBytes)
        )
    );
}
impl Default for hipKernelNodeParams {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipMemsetParams {
    pub dst: *mut ::libc::c_void,
    pub elementSize: ::libc::c_uint,
    pub height: usize,
    pub pitch: usize,
    pub value: ::libc::c_uint,
    pub width: usize,
}
#[test]
fn bindgen_test_layout_hipMemsetParams() {
    const UNINIT: ::std::mem::MaybeUninit<hipMemsetParams> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipMemsetParams>(),
        48usize,
        concat!("Size of: ", stringify!(hipMemsetParams))
    );
    assert_eq!(
        ::std::mem::align_of::<hipMemsetParams>(),
        8usize,
        concat!("Alignment of ", stringify!(hipMemsetParams))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dst) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMemsetParams),
            "::",
            stringify!(dst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).elementSize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMemsetParams),
            "::",
            stringify!(elementSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMemsetParams),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pitch) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMemsetParams),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMemsetParams),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMemsetParams),
            "::",
            stringify!(width)
        )
    );
}
impl Default for hipMemsetParams {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipMemAllocNodeParams {
    #[doc = "< Pool properties, which contain where\n< the location should reside"]
    pub poolProps: hipMemPoolProps,
    #[doc = "< The number of memory access descriptors."]
    pub accessDescs: *const hipMemAccessDesc,
    #[doc = "< The number of access descriptors.\n< Must not be bigger than the number of GPUs"]
    pub accessDescCount: usize,
    #[doc = "< The size of the requested allocation in bytes"]
    pub bytesize: usize,
    #[doc = "< Returned device address of the allocation"]
    pub dptr: *mut ::libc::c_void,
}
#[test]
fn bindgen_test_layout_hipMemAllocNodeParams() {
    const UNINIT: ::std::mem::MaybeUninit<hipMemAllocNodeParams> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipMemAllocNodeParams>(),
        120usize,
        concat!("Size of: ", stringify!(hipMemAllocNodeParams))
    );
    assert_eq!(
        ::std::mem::align_of::<hipMemAllocNodeParams>(),
        8usize,
        concat!("Alignment of ", stringify!(hipMemAllocNodeParams))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).poolProps) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMemAllocNodeParams),
            "::",
            stringify!(poolProps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).accessDescs) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMemAllocNodeParams),
            "::",
            stringify!(accessDescs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).accessDescCount) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMemAllocNodeParams),
            "::",
            stringify!(accessDescCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytesize) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMemAllocNodeParams),
            "::",
            stringify!(bytesize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dptr) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMemAllocNodeParams),
            "::",
            stringify!(dptr)
        )
    );
}
impl Default for hipMemAllocNodeParams {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipAccessProperty {
    hipAccessPropertyNormal = 0,
    hipAccessPropertyStreaming = 1,
    hipAccessPropertyPersisting = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, PartialEq)]
pub struct hipAccessPolicyWindow {
    pub base_ptr: *mut ::libc::c_void,
    pub hitProp: hipAccessProperty,
    pub hitRatio: f32,
    pub missProp: hipAccessProperty,
    pub num_bytes: usize,
}
#[test]
fn bindgen_test_layout_hipAccessPolicyWindow() {
    const UNINIT: ::std::mem::MaybeUninit<hipAccessPolicyWindow> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipAccessPolicyWindow>(),
        32usize,
        concat!("Size of: ", stringify!(hipAccessPolicyWindow))
    );
    assert_eq!(
        ::std::mem::align_of::<hipAccessPolicyWindow>(),
        8usize,
        concat!("Alignment of ", stringify!(hipAccessPolicyWindow))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipAccessPolicyWindow),
            "::",
            stringify!(base_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hitProp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipAccessPolicyWindow),
            "::",
            stringify!(hitProp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hitRatio) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hipAccessPolicyWindow),
            "::",
            stringify!(hitRatio)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).missProp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hipAccessPolicyWindow),
            "::",
            stringify!(missProp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_bytes) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hipAccessPolicyWindow),
            "::",
            stringify!(num_bytes)
        )
    );
}
impl Default for hipAccessPolicyWindow {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[non_exhaustive]
#[doc = "  Launch Attribute ID"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipLaunchAttributeID {
    #[doc = "< Valid for Streams, graph nodes, launches"]
    hipLaunchAttributeAccessPolicyWindow = 1,
    #[doc = "< Valid for graph nodes, launches"]
    hipLaunchAttributeCooperative = 2,
    #[doc = "< Valid for graph node, streams, launches"]
    hipLaunchAttributePriority = 8,
}
#[doc = "  Launch Attribute Value"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union hipLaunchAttributeValue {
    #[doc = "< Value of launch attribute::\nhipLaunchAttributePolicyWindow."]
    pub accessPolicyWindow: hipAccessPolicyWindow,
    #[doc = "< Value of launch attribute ::hipLaunchAttributeCooperative"]
    pub cooperative: ::libc::c_int,
    #[doc = "< Value of launch attribute :: hipLaunchAttributePriority. Execution\npriority of kernel."]
    pub priority: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_hipLaunchAttributeValue() {
    const UNINIT: ::std::mem::MaybeUninit<hipLaunchAttributeValue> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipLaunchAttributeValue>(),
        32usize,
        concat!("Size of: ", stringify!(hipLaunchAttributeValue))
    );
    assert_eq!(
        ::std::mem::align_of::<hipLaunchAttributeValue>(),
        8usize,
        concat!("Alignment of ", stringify!(hipLaunchAttributeValue))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).accessPolicyWindow) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipLaunchAttributeValue),
            "::",
            stringify!(accessPolicyWindow)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cooperative) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipLaunchAttributeValue),
            "::",
            stringify!(cooperative)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priority) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipLaunchAttributeValue),
            "::",
            stringify!(priority)
        )
    );
}
impl Default for hipLaunchAttributeValue {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Memset node params"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct HIP_MEMSET_NODE_PARAMS {
    #[doc = "< Destination pointer on device"]
    pub dst: hipDeviceptr_t,
    #[doc = "< Destination device pointer pitch. Unused if height equals 1"]
    pub pitch: usize,
    #[doc = "< Value of memset to be set"]
    pub value: ::libc::c_uint,
    #[doc = "< Element in bytes. Must be 1, 2, or 4."]
    pub elementSize: ::libc::c_uint,
    #[doc = "< Width of a row"]
    pub width: usize,
    #[doc = "< Number of rows"]
    pub height: usize,
}
#[test]
fn bindgen_test_layout_HIP_MEMSET_NODE_PARAMS() {
    const UNINIT: ::std::mem::MaybeUninit<HIP_MEMSET_NODE_PARAMS> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HIP_MEMSET_NODE_PARAMS>(),
        40usize,
        concat!("Size of: ", stringify!(HIP_MEMSET_NODE_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<HIP_MEMSET_NODE_PARAMS>(),
        8usize,
        concat!("Alignment of ", stringify!(HIP_MEMSET_NODE_PARAMS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dst) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMSET_NODE_PARAMS),
            "::",
            stringify!(dst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pitch) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMSET_NODE_PARAMS),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMSET_NODE_PARAMS),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).elementSize) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMSET_NODE_PARAMS),
            "::",
            stringify!(elementSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMSET_NODE_PARAMS),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMSET_NODE_PARAMS),
            "::",
            stringify!(height)
        )
    );
}
impl Default for HIP_MEMSET_NODE_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Graph execution update result"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipGraphExecUpdateResult {
    #[doc = "< The update succeeded"]
    hipGraphExecUpdateSuccess = 0,
    #[doc = "< The update failed for an unexpected reason which is described\n< in the return value of the function"]
    hipGraphExecUpdateError = 1,
    #[doc = "< The update failed because the topology changed"]
    hipGraphExecUpdateErrorTopologyChanged = 2,
    #[doc = "< The update failed because a node type changed"]
    hipGraphExecUpdateErrorNodeTypeChanged = 3,
    hipGraphExecUpdateErrorFunctionChanged = 4,
    hipGraphExecUpdateErrorParametersChanged = 5,
    hipGraphExecUpdateErrorNotSupported = 6,
    hipGraphExecUpdateErrorUnsupportedFunctionChange = 7,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipStreamCaptureMode {
    hipStreamCaptureModeGlobal = 0,
    hipStreamCaptureModeThreadLocal = 1,
    hipStreamCaptureModeRelaxed = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipStreamCaptureStatus {
    #[doc = "< Stream is not capturing"]
    hipStreamCaptureStatusNone = 0,
    #[doc = "< Stream is actively capturing"]
    hipStreamCaptureStatusActive = 1,
    #[doc = "< Stream is part of a capture sequence that has been\n< invalidated, but not terminated"]
    hipStreamCaptureStatusInvalidated = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipStreamUpdateCaptureDependenciesFlags {
    #[doc = "< Add new nodes to the dependency set"]
    hipStreamAddCaptureDependencies = 0,
    #[doc = "< Replace the dependency set with the new nodes"]
    hipStreamSetCaptureDependencies = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipGraphMemAttributeType {
    #[doc = "< Amount of memory, in bytes, currently associated with graphs"]
    hipGraphMemAttrUsedMemCurrent = 0,
    #[doc = "< High watermark of memory, in bytes, associated with graphs since the last time."]
    hipGraphMemAttrUsedMemHigh = 1,
    #[doc = "< Amount of memory, in bytes, currently allocated for graphs."]
    hipGraphMemAttrReservedMemCurrent = 2,
    #[doc = "< High watermark of memory, in bytes, currently allocated for graphs"]
    hipGraphMemAttrReservedMemHigh = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipUserObjectFlags {
    #[doc = "< Destructor execution is not synchronized."]
    hipUserObjectNoDestructorSync = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipUserObjectRetainFlags {
    #[doc = "< Add new reference or retain."]
    hipGraphUserObjectMove = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipGraphInstantiateFlags {
    hipGraphInstantiateFlagAutoFreeOnLaunch = 1,
    hipGraphInstantiateFlagUpload = 2,
    hipGraphInstantiateFlagDeviceLaunch = 4,
    hipGraphInstantiateFlagUseNodePriority = 8,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipGraphDebugDotFlags {
    hipGraphDebugDotFlagsVerbose = 1,
    #[doc = "< Adds hipKernelNodeParams to output"]
    hipGraphDebugDotFlagsKernelNodeParams = 4,
    #[doc = "< Adds hipMemcpy3DParms to output"]
    hipGraphDebugDotFlagsMemcpyNodeParams = 8,
    #[doc = "< Adds hipMemsetParams to output"]
    hipGraphDebugDotFlagsMemsetNodeParams = 16,
    #[doc = "< Adds hipHostNodeParams to output"]
    hipGraphDebugDotFlagsHostNodeParams = 32,
    hipGraphDebugDotFlagsEventNodeParams = 64,
    hipGraphDebugDotFlagsExtSemasSignalNodeParams = 128,
    hipGraphDebugDotFlagsExtSemasWaitNodeParams = 256,
    hipGraphDebugDotFlagsKernelNodeAttributes = 512,
    hipGraphDebugDotFlagsHandles = 1024,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " hipGraphInstantiateWithParams results"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipGraphInstantiateResult {
    #[doc = "< Instantiation Success"]
    hipGraphInstantiateSuccess = 0,
    #[doc = "< Instantiation failed for an\nunexpected reason which is described in the return value of the function"]
    hipGraphInstantiateError = 1,
    #[doc = "< Instantiation failed due\nto invalid structure, such as cycles"]
    hipGraphInstantiateInvalidStructure = 2,
    #[doc = "< Instantiation for device launch failed\nbecause the graph contained an unsupported operation"]
    hipGraphInstantiateNodeOperationNotSupported = 3,
    #[doc = "< Instantiation for device launch failed\ndue to the nodes belonging to different contexts"]
    hipGraphInstantiateMultipleDevicesNotSupported = 4,
}
#[doc = " Graph Instantiation parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipGraphInstantiateParams {
    #[doc = "< The node which caused instantiation to fail, if any"]
    pub errNode_out: hipGraphNode_t,
    #[doc = "< Instantiation flags"]
    pub flags: ::libc::c_ulonglong,
    #[doc = "< Whether instantiation was successful.\nIf it failed, the reason why"]
    pub result_out: hipGraphInstantiateResult,
    #[doc = "< Upload stream"]
    pub uploadStream: hipStream_t,
}
#[test]
fn bindgen_test_layout_hipGraphInstantiateParams() {
    const UNINIT: ::std::mem::MaybeUninit<hipGraphInstantiateParams> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipGraphInstantiateParams>(),
        32usize,
        concat!("Size of: ", stringify!(hipGraphInstantiateParams))
    );
    assert_eq!(
        ::std::mem::align_of::<hipGraphInstantiateParams>(),
        8usize,
        concat!("Alignment of ", stringify!(hipGraphInstantiateParams))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).errNode_out) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipGraphInstantiateParams),
            "::",
            stringify!(errNode_out)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipGraphInstantiateParams),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).result_out) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hipGraphInstantiateParams),
            "::",
            stringify!(result_out)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uploadStream) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hipGraphInstantiateParams),
            "::",
            stringify!(uploadStream)
        )
    );
}
impl Default for hipGraphInstantiateParams {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Memory allocation properties"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipMemAllocationProp {
    #[doc = "< Memory allocation type"]
    pub type_: hipMemAllocationType,
    #[doc = "< Requested handle type"]
    pub requestedHandleType: hipMemAllocationHandleType,
    #[doc = "< Memory location"]
    pub location: hipMemLocation,
    #[doc = "< Metadata for Win32 handles"]
    pub win32HandleMetaData: *mut ::libc::c_void,
    pub allocFlags: hipMemAllocationProp__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipMemAllocationProp__bindgen_ty_1 {
    #[doc = "< Compression type"]
    pub compressionType: ::libc::c_uchar,
    #[doc = "< RDMA capable"]
    pub gpuDirectRDMACapable: ::libc::c_uchar,
    #[doc = "< Usage"]
    pub usage: ::libc::c_ushort,
}
#[test]
fn bindgen_test_layout_hipMemAllocationProp__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<hipMemAllocationProp__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipMemAllocationProp__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(hipMemAllocationProp__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<hipMemAllocationProp__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(hipMemAllocationProp__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).compressionType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMemAllocationProp__bindgen_ty_1),
            "::",
            stringify!(compressionType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpuDirectRDMACapable) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMemAllocationProp__bindgen_ty_1),
            "::",
            stringify!(gpuDirectRDMACapable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).usage) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMemAllocationProp__bindgen_ty_1),
            "::",
            stringify!(usage)
        )
    );
}
#[test]
fn bindgen_test_layout_hipMemAllocationProp() {
    const UNINIT: ::std::mem::MaybeUninit<hipMemAllocationProp> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipMemAllocationProp>(),
        32usize,
        concat!("Size of: ", stringify!(hipMemAllocationProp))
    );
    assert_eq!(
        ::std::mem::align_of::<hipMemAllocationProp>(),
        8usize,
        concat!("Alignment of ", stringify!(hipMemAllocationProp))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMemAllocationProp),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).requestedHandleType) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMemAllocationProp),
            "::",
            stringify!(requestedHandleType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).location) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMemAllocationProp),
            "::",
            stringify!(location)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).win32HandleMetaData) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMemAllocationProp),
            "::",
            stringify!(win32HandleMetaData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocFlags) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMemAllocationProp),
            "::",
            stringify!(allocFlags)
        )
    );
}
impl Default for hipMemAllocationProp {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " External semaphore signal node parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipExternalSemaphoreSignalNodeParams {
    pub extSemArray: *mut hipExternalSemaphore_t,
    pub paramsArray: *const hipExternalSemaphoreSignalParams,
    pub numExtSems: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_hipExternalSemaphoreSignalNodeParams() {
    const UNINIT: ::std::mem::MaybeUninit<hipExternalSemaphoreSignalNodeParams> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipExternalSemaphoreSignalNodeParams>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(hipExternalSemaphoreSignalNodeParams)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hipExternalSemaphoreSignalNodeParams>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hipExternalSemaphoreSignalNodeParams)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extSemArray) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExternalSemaphoreSignalNodeParams),
            "::",
            stringify!(extSemArray)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).paramsArray) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExternalSemaphoreSignalNodeParams),
            "::",
            stringify!(paramsArray)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numExtSems) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExternalSemaphoreSignalNodeParams),
            "::",
            stringify!(numExtSems)
        )
    );
}
impl Default for hipExternalSemaphoreSignalNodeParams {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " External semaphore wait node parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipExternalSemaphoreWaitNodeParams {
    pub extSemArray: *mut hipExternalSemaphore_t,
    pub paramsArray: *const hipExternalSemaphoreWaitParams,
    pub numExtSems: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_hipExternalSemaphoreWaitNodeParams() {
    const UNINIT: ::std::mem::MaybeUninit<hipExternalSemaphoreWaitNodeParams> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipExternalSemaphoreWaitNodeParams>(),
        24usize,
        concat!("Size of: ", stringify!(hipExternalSemaphoreWaitNodeParams))
    );
    assert_eq!(
        ::std::mem::align_of::<hipExternalSemaphoreWaitNodeParams>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hipExternalSemaphoreWaitNodeParams)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extSemArray) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExternalSemaphoreWaitNodeParams),
            "::",
            stringify!(extSemArray)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).paramsArray) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExternalSemaphoreWaitNodeParams),
            "::",
            stringify!(paramsArray)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numExtSems) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExternalSemaphoreWaitNodeParams),
            "::",
            stringify!(numExtSems)
        )
    );
}
impl Default for hipExternalSemaphoreWaitNodeParams {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ihipMemGenericAllocationHandle {
    _unused: [u8; 0],
}
#[doc = " Generic handle for memory allocation"]
pub type hipMemGenericAllocationHandle_t = *mut ihipMemGenericAllocationHandle;
#[repr(u32)]
#[non_exhaustive]
#[doc = " Flags for granularity"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipMemAllocationGranularity_flags {
    #[doc = "< Minimum granularity"]
    hipMemAllocationGranularityMinimum = 0,
    #[doc = "< Recommended granularity for performance"]
    hipMemAllocationGranularityRecommended = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Memory handle type"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipMemHandleType {
    #[doc = "< Generic handle type"]
    hipMemHandleTypeGeneric = 0,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Memory operation types"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipMemOperationType {
    #[doc = "< Map operation"]
    hipMemOperationTypeMap = 1,
    #[doc = "< Unmap operation"]
    hipMemOperationTypeUnmap = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Subresource types for sparse arrays"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipArraySparseSubresourceType {
    #[doc = "< Sparse level"]
    hipArraySparseSubresourceTypeSparseLevel = 0,
    #[doc = "< Miptail"]
    hipArraySparseSubresourceTypeMiptail = 1,
}
#[doc = " Map info for arrays"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hipArrayMapInfo {
    #[doc = "< Resource type"]
    pub resourceType: hipResourceType,
    pub resource: hipArrayMapInfo__bindgen_ty_1,
    #[doc = "< Sparse subresource type"]
    pub subresourceType: hipArraySparseSubresourceType,
    pub subresource: hipArrayMapInfo__bindgen_ty_2,
    #[doc = "< Memory operation type"]
    pub memOperationType: hipMemOperationType,
    #[doc = "< Memory handle type"]
    pub memHandleType: hipMemHandleType,
    pub memHandle: hipArrayMapInfo__bindgen_ty_3,
    #[doc = "< Offset within the memory"]
    pub offset: ::libc::c_ulonglong,
    #[doc = "< Device ordinal bit mask"]
    pub deviceBitMask: ::libc::c_uint,
    #[doc = "< flags for future use, must be zero now."]
    pub flags: ::libc::c_uint,
    #[doc = "< Reserved for future use, must be zero now."]
    pub reserved: [::libc::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hipArrayMapInfo__bindgen_ty_1 {
    pub mipmap: hipMipmappedArray,
    pub array: hipArray_t,
}
#[test]
fn bindgen_test_layout_hipArrayMapInfo__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<hipArrayMapInfo__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipArrayMapInfo__bindgen_ty_1>(),
        64usize,
        concat!("Size of: ", stringify!(hipArrayMapInfo__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<hipArrayMapInfo__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(hipArrayMapInfo__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mipmap) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipArrayMapInfo__bindgen_ty_1),
            "::",
            stringify!(mipmap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).array) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipArrayMapInfo__bindgen_ty_1),
            "::",
            stringify!(array)
        )
    );
}
impl Default for hipArrayMapInfo__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hipArrayMapInfo__bindgen_ty_2 {
    pub sparseLevel: hipArrayMapInfo__bindgen_ty_2__bindgen_ty_1,
    pub miptail: hipArrayMapInfo__bindgen_ty_2__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipArrayMapInfo__bindgen_ty_2__bindgen_ty_1 {
    #[doc = "< For mipmapped arrays must be a valid mipmap level. For arrays must be zero"]
    pub level: ::libc::c_uint,
    #[doc = "< For layered arrays must be a valid layer index. Otherwise, must be zero"]
    pub layer: ::libc::c_uint,
    #[doc = "< X offset in elements"]
    pub offsetX: ::libc::c_uint,
    #[doc = "< Y offset in elements"]
    pub offsetY: ::libc::c_uint,
    #[doc = "< Z offset in elements"]
    pub offsetZ: ::libc::c_uint,
    #[doc = "< Width in elements"]
    pub extentWidth: ::libc::c_uint,
    #[doc = "< Height in elements"]
    pub extentHeight: ::libc::c_uint,
    #[doc = "< Depth in elements"]
    pub extentDepth: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_hipArrayMapInfo__bindgen_ty_2__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<hipArrayMapInfo__bindgen_ty_2__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipArrayMapInfo__bindgen_ty_2__bindgen_ty_1>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(hipArrayMapInfo__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hipArrayMapInfo__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(hipArrayMapInfo__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).level) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipArrayMapInfo__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).layer) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hipArrayMapInfo__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(layer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offsetX) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipArrayMapInfo__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(offsetX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offsetY) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hipArrayMapInfo__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(offsetY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offsetZ) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hipArrayMapInfo__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(offsetZ)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extentWidth) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(hipArrayMapInfo__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(extentWidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extentHeight) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hipArrayMapInfo__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(extentHeight)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extentDepth) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(hipArrayMapInfo__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(extentDepth)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipArrayMapInfo__bindgen_ty_2__bindgen_ty_2 {
    #[doc = "< For layered arrays must be a valid layer index. Otherwise, must be zero"]
    pub layer: ::libc::c_uint,
    #[doc = "< Offset within mip tail"]
    pub offset: ::libc::c_ulonglong,
    #[doc = "< Extent in bytes"]
    pub size: ::libc::c_ulonglong,
}
#[test]
fn bindgen_test_layout_hipArrayMapInfo__bindgen_ty_2__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<hipArrayMapInfo__bindgen_ty_2__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipArrayMapInfo__bindgen_ty_2__bindgen_ty_2>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(hipArrayMapInfo__bindgen_ty_2__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hipArrayMapInfo__bindgen_ty_2__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hipArrayMapInfo__bindgen_ty_2__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).layer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipArrayMapInfo__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(layer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipArrayMapInfo__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hipArrayMapInfo__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(size)
        )
    );
}
#[test]
fn bindgen_test_layout_hipArrayMapInfo__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<hipArrayMapInfo__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipArrayMapInfo__bindgen_ty_2>(),
        32usize,
        concat!("Size of: ", stringify!(hipArrayMapInfo__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<hipArrayMapInfo__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(hipArrayMapInfo__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sparseLevel) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipArrayMapInfo__bindgen_ty_2),
            "::",
            stringify!(sparseLevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).miptail) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipArrayMapInfo__bindgen_ty_2),
            "::",
            stringify!(miptail)
        )
    );
}
impl Default for hipArrayMapInfo__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hipArrayMapInfo__bindgen_ty_3 {
    pub memHandle: hipMemGenericAllocationHandle_t,
}
#[test]
fn bindgen_test_layout_hipArrayMapInfo__bindgen_ty_3() {
    const UNINIT: ::std::mem::MaybeUninit<hipArrayMapInfo__bindgen_ty_3> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipArrayMapInfo__bindgen_ty_3>(),
        8usize,
        concat!("Size of: ", stringify!(hipArrayMapInfo__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<hipArrayMapInfo__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(hipArrayMapInfo__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipArrayMapInfo__bindgen_ty_3),
            "::",
            stringify!(memHandle)
        )
    );
}
impl Default for hipArrayMapInfo__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_hipArrayMapInfo() {
    const UNINIT: ::std::mem::MaybeUninit<hipArrayMapInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipArrayMapInfo>(),
        152usize,
        concat!("Size of: ", stringify!(hipArrayMapInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<hipArrayMapInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(hipArrayMapInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resourceType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipArrayMapInfo),
            "::",
            stringify!(resourceType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resource) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipArrayMapInfo),
            "::",
            stringify!(resource)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subresourceType) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(hipArrayMapInfo),
            "::",
            stringify!(subresourceType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subresource) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(hipArrayMapInfo),
            "::",
            stringify!(subresource)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memOperationType) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(hipArrayMapInfo),
            "::",
            stringify!(memOperationType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memHandleType) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(hipArrayMapInfo),
            "::",
            stringify!(memHandleType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memHandle) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(hipArrayMapInfo),
            "::",
            stringify!(memHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(hipArrayMapInfo),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deviceBitMask) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(hipArrayMapInfo),
            "::",
            stringify!(deviceBitMask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(hipArrayMapInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(hipArrayMapInfo),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for hipArrayMapInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Memcpy node params"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipMemcpyNodeParams {
    #[doc = "< Must be zero."]
    pub flags: ::libc::c_int,
    #[doc = "< Must be zero."]
    pub reserved: [::libc::c_int; 3usize],
    #[doc = "< Params set for the memory copy."]
    pub copyParams: hipMemcpy3DParms,
}
#[test]
fn bindgen_test_layout_hipMemcpyNodeParams() {
    const UNINIT: ::std::mem::MaybeUninit<hipMemcpyNodeParams> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipMemcpyNodeParams>(),
        176usize,
        concat!("Size of: ", stringify!(hipMemcpyNodeParams))
    );
    assert_eq!(
        ::std::mem::align_of::<hipMemcpyNodeParams>(),
        8usize,
        concat!("Alignment of ", stringify!(hipMemcpyNodeParams))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMemcpyNodeParams),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMemcpyNodeParams),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).copyParams) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMemcpyNodeParams),
            "::",
            stringify!(copyParams)
        )
    );
}
impl Default for hipMemcpyNodeParams {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Child graph node params"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipChildGraphNodeParams {
    #[doc = "< Either the child graph to clone into the node, or\n< a handle to the graph possesed by the node used during query"]
    pub graph: hipGraph_t,
}
#[test]
fn bindgen_test_layout_hipChildGraphNodeParams() {
    const UNINIT: ::std::mem::MaybeUninit<hipChildGraphNodeParams> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipChildGraphNodeParams>(),
        8usize,
        concat!("Size of: ", stringify!(hipChildGraphNodeParams))
    );
    assert_eq!(
        ::std::mem::align_of::<hipChildGraphNodeParams>(),
        8usize,
        concat!("Alignment of ", stringify!(hipChildGraphNodeParams))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).graph) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipChildGraphNodeParams),
            "::",
            stringify!(graph)
        )
    );
}
impl Default for hipChildGraphNodeParams {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Event record node params"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipEventWaitNodeParams {
    #[doc = "< Event to wait on"]
    pub event: hipEvent_t,
}
#[test]
fn bindgen_test_layout_hipEventWaitNodeParams() {
    const UNINIT: ::std::mem::MaybeUninit<hipEventWaitNodeParams> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipEventWaitNodeParams>(),
        8usize,
        concat!("Size of: ", stringify!(hipEventWaitNodeParams))
    );
    assert_eq!(
        ::std::mem::align_of::<hipEventWaitNodeParams>(),
        8usize,
        concat!("Alignment of ", stringify!(hipEventWaitNodeParams))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipEventWaitNodeParams),
            "::",
            stringify!(event)
        )
    );
}
impl Default for hipEventWaitNodeParams {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Event record node params"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipEventRecordNodeParams {
    #[doc = "< The event to be recorded when node executes"]
    pub event: hipEvent_t,
}
#[test]
fn bindgen_test_layout_hipEventRecordNodeParams() {
    const UNINIT: ::std::mem::MaybeUninit<hipEventRecordNodeParams> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipEventRecordNodeParams>(),
        8usize,
        concat!("Size of: ", stringify!(hipEventRecordNodeParams))
    );
    assert_eq!(
        ::std::mem::align_of::<hipEventRecordNodeParams>(),
        8usize,
        concat!("Alignment of ", stringify!(hipEventRecordNodeParams))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipEventRecordNodeParams),
            "::",
            stringify!(event)
        )
    );
}
impl Default for hipEventRecordNodeParams {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Memory free node params"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipMemFreeNodeParams {
    #[doc = "< the pointer to be freed"]
    pub dptr: *mut ::libc::c_void,
}
#[test]
fn bindgen_test_layout_hipMemFreeNodeParams() {
    const UNINIT: ::std::mem::MaybeUninit<hipMemFreeNodeParams> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipMemFreeNodeParams>(),
        8usize,
        concat!("Size of: ", stringify!(hipMemFreeNodeParams))
    );
    assert_eq!(
        ::std::mem::align_of::<hipMemFreeNodeParams>(),
        8usize,
        concat!("Alignment of ", stringify!(hipMemFreeNodeParams))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMemFreeNodeParams),
            "::",
            stringify!(dptr)
        )
    );
}
impl Default for hipMemFreeNodeParams {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Params for different graph nodes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hipGraphNodeParams {
    pub type_: hipGraphNodeType,
    pub reserved0: [::libc::c_int; 3usize],
    pub __bindgen_anon_1: hipGraphNodeParams__bindgen_ty_1,
    pub reserved2: ::libc::c_longlong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hipGraphNodeParams__bindgen_ty_1 {
    pub reserved1: [::libc::c_longlong; 29usize],
    pub kernel: hipKernelNodeParams,
    pub memcpy: hipMemcpyNodeParams,
    pub memset: hipMemsetParams,
    pub host: hipHostNodeParams,
    pub graph: hipChildGraphNodeParams,
    pub eventWait: hipEventWaitNodeParams,
    pub eventRecord: hipEventRecordNodeParams,
    pub extSemSignal: hipExternalSemaphoreSignalNodeParams,
    pub extSemWait: hipExternalSemaphoreWaitNodeParams,
    pub alloc: hipMemAllocNodeParams,
    pub free: hipMemFreeNodeParams,
}
#[test]
fn bindgen_test_layout_hipGraphNodeParams__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<hipGraphNodeParams__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipGraphNodeParams__bindgen_ty_1>(),
        232usize,
        concat!("Size of: ", stringify!(hipGraphNodeParams__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<hipGraphNodeParams__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hipGraphNodeParams__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipGraphNodeParams__bindgen_ty_1),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kernel) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipGraphNodeParams__bindgen_ty_1),
            "::",
            stringify!(kernel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memcpy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipGraphNodeParams__bindgen_ty_1),
            "::",
            stringify!(memcpy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipGraphNodeParams__bindgen_ty_1),
            "::",
            stringify!(memset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).host) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipGraphNodeParams__bindgen_ty_1),
            "::",
            stringify!(host)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).graph) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipGraphNodeParams__bindgen_ty_1),
            "::",
            stringify!(graph)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eventWait) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipGraphNodeParams__bindgen_ty_1),
            "::",
            stringify!(eventWait)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eventRecord) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipGraphNodeParams__bindgen_ty_1),
            "::",
            stringify!(eventRecord)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extSemSignal) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipGraphNodeParams__bindgen_ty_1),
            "::",
            stringify!(extSemSignal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extSemWait) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipGraphNodeParams__bindgen_ty_1),
            "::",
            stringify!(extSemWait)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alloc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipGraphNodeParams__bindgen_ty_1),
            "::",
            stringify!(alloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipGraphNodeParams__bindgen_ty_1),
            "::",
            stringify!(free)
        )
    );
}
impl Default for hipGraphNodeParams__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_hipGraphNodeParams() {
    const UNINIT: ::std::mem::MaybeUninit<hipGraphNodeParams> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipGraphNodeParams>(),
        256usize,
        concat!("Size of: ", stringify!(hipGraphNodeParams))
    );
    assert_eq!(
        ::std::mem::align_of::<hipGraphNodeParams>(),
        8usize,
        concat!("Alignment of ", stringify!(hipGraphNodeParams))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipGraphNodeParams),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved0) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hipGraphNodeParams),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(hipGraphNodeParams),
            "::",
            stringify!(reserved2)
        )
    );
}
impl Default for hipGraphNodeParams {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipGraphDependencyType {
    hipGraphDependencyTypeDefault = 0,
    hipGraphDependencyTypeProgrammatic = 1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipGraphEdgeData {
    #[doc = "< This indicates when the dependency is triggered from the upstream node on the\n< edge. The meaning is specfic to the node type. A value of 0 in all cases\n< means full completion of the upstream node, with memory visibility to the\n< downstream node or portion thereof (indicated by to_port). Only kernel nodes\n< define non-zero ports. A kernel node can use the following output port types:\n< hipGraphKernelNodePortDefault, hipGraphKernelNodePortProgrammatic, or\n< hipGraphKernelNodePortLaunchCompletion."]
    pub from_port: ::libc::c_uchar,
    #[doc = "< These bytes are unused and must be zeroed"]
    pub reserved: [::libc::c_uchar; 5usize],
    #[doc = "< Currently no node types define non-zero ports. This field must be set to zero."]
    pub to_port: ::libc::c_uchar,
    #[doc = "< This should be populated with a value from hipGraphDependencyType"]
    pub type_: ::libc::c_uchar,
}
#[test]
fn bindgen_test_layout_hipGraphEdgeData() {
    const UNINIT: ::std::mem::MaybeUninit<hipGraphEdgeData> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipGraphEdgeData>(),
        8usize,
        concat!("Size of: ", stringify!(hipGraphEdgeData))
    );
    assert_eq!(
        ::std::mem::align_of::<hipGraphEdgeData>(),
        1usize,
        concat!("Alignment of ", stringify!(hipGraphEdgeData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).from_port) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipGraphEdgeData),
            "::",
            stringify!(from_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(hipGraphEdgeData),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).to_port) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(hipGraphEdgeData),
            "::",
            stringify!(to_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(hipGraphEdgeData),
            "::",
            stringify!(type_)
        )
    );
}
extern "C" {
    #[doc = " @}\n/\n/**\n  @defgroup API HIP API\n  @{\n\n  Defines the HIP API.  See the individual sections for more information.\n/\n/**\n  @defgroup Driver Initialization and Version\n  @{\n  This section describes the initializtion and version functions of HIP runtime API.\n\n/\n/**\n @brief Explicitly initializes the HIP runtime.\n\n @param [in] flags  Initialization flag, should be zero.\n\n Most HIP APIs implicitly initialize the HIP runtime.\n This API provides control over the timing of the initialization.\n\n @returns #hipSuccess, #hipErrorInvalidValue"]
    pub fn hipInit(flags: ::libc::c_uint) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns the approximate HIP driver version.\n\n @param [out] driverVersion driver version\n\n HIP driver version shows up in the format:\n HIP_VERSION_MAJOR * 10000000 + HIP_VERSION_MINOR * 100000 + HIP_VERSION_PATCH.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning The HIP driver version does not correspond to an exact CUDA driver revision.\n On AMD platform, the API returns the HIP driver version, while on NVIDIA platform, it calls\n the corresponding CUDA runtime API and returns the CUDA driver version.\n There is no mapping/correlation between HIP driver version and CUDA driver version.\n\n @see hipRuntimeGetVersion"]
    pub fn hipDriverGetVersion(driverVersion: *mut ::libc::c_int) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns the approximate HIP Runtime version.\n\n @param [out] runtimeVersion HIP runtime version\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning The version definition of HIP runtime is different from CUDA.\n On AMD platform, the function returns HIP runtime version,\n while on NVIDIA platform, it returns CUDA runtime version.\n And there is no mapping/correlation between HIP version and CUDA version.\n\n @see hipDriverGetVersion"]
    pub fn hipRuntimeGetVersion(runtimeVersion: *mut ::libc::c_int) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns a handle to a compute device\n @param [out] device Handle of device\n @param [in] ordinal Device ordinal\n\n @returns #hipSuccess, #hipErrorInvalidDevice"]
    pub fn hipDeviceGet(device: *mut hipDevice_t, ordinal: ::libc::c_int) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns the compute capability of the device\n @param [out] major Major compute capability version number\n @param [out] minor Minor compute capability version number\n @param [in] device Device ordinal\n\n @returns #hipSuccess, #hipErrorInvalidDevice"]
    pub fn hipDeviceComputeCapability(
        major: *mut ::libc::c_int,
        minor: *mut ::libc::c_int,
        device: hipDevice_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns an identifer string for the device.\n @param [out] name String of the device name\n @param [in] len Maximum length of string to store in device name\n @param [in] device Device ordinal\n\n @returns #hipSuccess, #hipErrorInvalidDevice"]
    pub fn hipDeviceGetName(
        name: *mut ::libc::c_char,
        len: ::libc::c_int,
        device: hipDevice_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns an UUID for the device.[BETA]\n @param [out] uuid UUID for the device\n @param [in] device device ordinal\n\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues.\n\n @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue, #hipErrorNotInitialized,\n #hipErrorDeinitialized"]
    pub fn hipDeviceGetUuid(uuid: *mut hipUUID, device: hipDevice_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns a value for attribute of link between two devices\n @param [out] value Pointer of the value for the attrubute\n @param [in] attr enum of hipDeviceP2PAttr to query\n @param [in] srcDevice The source device of the link\n @param [in] dstDevice The destination device of the link\n\n @returns #hipSuccess, #hipErrorInvalidDevice"]
    pub fn hipDeviceGetP2PAttribute(
        value: *mut ::libc::c_int,
        attr: hipDeviceP2PAttr,
        srcDevice: ::libc::c_int,
        dstDevice: ::libc::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns a PCI Bus Id string for the device, overloaded to take int device ID.\n @param [out] pciBusId The string of PCI Bus Id format for the device\n @param [in] len Maximum length of string\n @param [in] device The device ordinal\n\n @returns #hipSuccess, #hipErrorInvalidDevice"]
    pub fn hipDeviceGetPCIBusId(
        pciBusId: *mut ::libc::c_char,
        len: ::libc::c_int,
        device: ::libc::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns a handle to a compute device.\n @param [out] device The handle of the device\n @param [in] pciBusId The string of PCI Bus Id for the device\n\n @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue"]
    pub fn hipDeviceGetByPCIBusId(
        device: *mut ::libc::c_int,
        pciBusId: *const ::libc::c_char,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns the total amount of memory on the device.\n @param [out] bytes The size of memory in bytes, on the device\n @param [in] device The ordinal of the device\n\n @returns #hipSuccess, #hipErrorInvalidDevice"]
    pub fn hipDeviceTotalMem(bytes: *mut usize, device: hipDevice_t) -> hipError_t;
}
extern "C" {
    #[doc = " @}\n/\n/**\n  @defgroup Device Device Management\n  @{\n  This section describes the device management functions of HIP runtime API.\n/\n/**\n @brief Waits on all active streams on current device\n\n When this command is invoked, the host thread gets blocked until all the commands associated\n with streams associated with the device. HIP does not support multiple blocking modes (yet!).\n\n @returns #hipSuccess\n\n @see hipSetDevice, hipDeviceReset"]
    pub fn hipDeviceSynchronize() -> hipError_t;
}
extern "C" {
    #[doc = " @brief The state of current device is discarded and updated to a fresh state.\n\n Calling this function deletes all streams created, memory allocated, kernels running, events\n created. Make sure that no other thread is using the device or streams, memory, kernels, events\n associated with the current device.\n\n @returns #hipSuccess\n\n @see hipDeviceSynchronize"]
    pub fn hipDeviceReset() -> hipError_t;
}
extern "C" {
    #[doc = " @brief Set default device to be used for subsequent hip API calls from this thread.\n\n @param[in] deviceId Valid device in range 0...hipGetDeviceCount().\n\n Sets @p device as the default device for the calling host thread.  Valid device id's are 0...\n (hipGetDeviceCount()-1).\n\n Many HIP APIs implicitly use the \"default device\" :\n\n - Any device memory subsequently allocated from this host thread (using hipMalloc) will be\n allocated on device.\n - Any streams or events created from this host thread will be associated with device.\n - Any kernels launched from this host thread (using hipLaunchKernel) will be executed on device\n (unless a specific stream is specified, in which case the device associated with that stream will\n be used).\n\n This function may be called from any host thread.  Multiple host threads may use the same device.\n This function does no synchronization with the previous or new device, and has very little\n runtime overhead. Applications can use hipSetDevice to quickly switch the default device before\n making a HIP runtime call which uses the default device.\n\n The default device is stored in thread-local-storage for each thread.\n Thread-pool implementations may inherit the default device of the previous thread.  A good\n practice is to always call hipSetDevice at the start of HIP coding sequency to establish a known\n standard device.\n\n @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorNoDevice\n\n @see #hipGetDevice, #hipGetDeviceCount"]
    pub fn hipSetDevice(deviceId: ::libc::c_int) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Set a list of devices that can be used.\n\n @param[in] device_arr List of devices to try\n @param[in] len Number of devices in specified list\n\n @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue\n\n @see #hipGetDevice, #hipGetDeviceCount. #hipSetDevice. #hipGetDeviceProperties. #hipSetDeviceFlags. #hipChooseDevice\n"]
    pub fn hipSetValidDevices(device_arr: *mut ::libc::c_int, len: ::libc::c_int) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Return the default device id for the calling host thread.\n\n @param [out] deviceId *device is written with the default device\n\n HIP maintains an default device for each thread using thread-local-storage.\n This device is used implicitly for HIP runtime APIs called by this thread.\n hipGetDevice returns in * @p device the default device for the calling host thread.\n\n @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue\n\n @see hipSetDevice, hipGetDevicesizeBytes"]
    pub fn hipGetDevice(deviceId: *mut ::libc::c_int) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Return number of compute-capable devices.\n\n @param [out] count Returns number of compute-capable devices.\n\n @returns #hipSuccess, #hipErrorNoDevice\n\n\n Returns in @p *count the number of devices that have ability to run compute commands.  If there\n are no such devices, then @ref hipGetDeviceCount will return #hipErrorNoDevice. If 1 or more\n devices can be found, then hipGetDeviceCount returns #hipSuccess."]
    pub fn hipGetDeviceCount(count: *mut ::libc::c_int) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Query for a specific device attribute.\n\n @param [out] pi pointer to value to return\n @param [in] attr attribute to query\n @param [in] deviceId which device to query for information\n\n @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue"]
    pub fn hipDeviceGetAttribute(
        pi: *mut ::libc::c_int,
        attr: hipDeviceAttribute_t,
        deviceId: ::libc::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns the default memory pool of the specified device\n\n @param [out] mem_pool Default memory pool to return\n @param [in] device    Device index for query the default memory pool\n\n @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @see hipDeviceGetDefaultMemPool, hipMallocAsync, hipMemPoolTrimTo, hipMemPoolGetAttribute,\n hipDeviceSetMemPool, hipMemPoolSetAttribute, hipMemPoolSetAccess, hipMemPoolGetAccess\n\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipDeviceGetDefaultMemPool(
        mem_pool: *mut hipMemPool_t,
        device: ::libc::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets the current memory pool of a device\n\n The memory pool must be local to the specified device.\n @p hipMallocAsync allocates from the current mempool of the provided stream's device.\n By default, a device's current memory pool is its default memory pool.\n\n @note Use @p hipMallocFromPoolAsync for asynchronous memory allocations from a device\n different than the one the stream runs on.\n\n @param [in] device   Device index for the update\n @param [in] mem_pool Memory pool for update as the current on the specified device\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidDevice, #hipErrorNotSupported\n\n @see hipDeviceGetDefaultMemPool, hipMallocAsync, hipMemPoolTrimTo, hipMemPoolGetAttribute,\n hipDeviceSetMemPool, hipMemPoolSetAttribute, hipMemPoolSetAccess, hipMemPoolGetAccess\n\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipDeviceSetMemPool(device: ::libc::c_int, mem_pool: hipMemPool_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets the current memory pool for the specified device\n\n Returns the last pool provided to @p hipDeviceSetMemPool for this device\n or the device's default memory pool if @p hipDeviceSetMemPool has never been called.\n By default the current mempool is the default mempool for a device,\n otherwise the returned pool must have been set with @p hipDeviceSetMemPool.\n\n @param [out] mem_pool Current memory pool on the specified device\n @param [in] device    Device index to query the current memory pool\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @see hipDeviceGetDefaultMemPool, hipMallocAsync, hipMemPoolTrimTo, hipMemPoolGetAttribute,\n hipDeviceSetMemPool, hipMemPoolSetAttribute, hipMemPoolSetAccess, hipMemPoolGetAccess\n\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipDeviceGetMemPool(mem_pool: *mut hipMemPool_t, device: ::libc::c_int) -> hipError_t;
}
extern "C" {
    pub fn hipGetDevicePropertiesR0600(
        prop: *mut hipDeviceProp_tR0600,
        deviceId: ::libc::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets the maximum width for 1D linear textures on the specified device\n\n This function queries the maximum width, in elements, of 1D linear textures that can be allocated\n on the specified device. The maximum width depends on the texture element size and the hardware\n limitations of the device.\n\n @param [out] max_width Maximum width, in elements, of 1D linear textures that the device can support\n @param [in] device     Device index to query for maximum 1D texture width\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidDevice\n\n @see hipDeviceGetAttribute, hipMalloc, hipTexRefSetAddressMode"]
    pub fn hipDeviceGetTexture1DLinearMaxWidth(
        mem_pool: *mut hipMemPool_t,
        device: ::libc::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Set L1/Shared cache partition.\n\n @param [in] cacheConfig Cache configuration\n\n @returns #hipSuccess, #hipErrorNotInitialized, #hipErrorNotSupported\n\n Note: AMD devices do not support reconfigurable cache. This API is not implemented\n on AMD platform. If the function is called, it will return hipErrorNotSupported.\n"]
    pub fn hipDeviceSetCacheConfig(cacheConfig: hipFuncCache_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Get Cache configuration for a specific Device\n\n @param [out] cacheConfig Pointer of cache configuration\n\n @returns #hipSuccess, #hipErrorNotInitialized\n Note: AMD devices do not support reconfigurable cache. This hint is ignored\n on these architectures.\n"]
    pub fn hipDeviceGetCacheConfig(cacheConfig: *mut hipFuncCache_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets resource limits of current device\n\n The function queries the size of limit value, as required by the input enum value hipLimit_t,\n which can be either #hipLimitStackSize, or #hipLimitMallocHeapSize. Any other input as\n default, the function will return #hipErrorUnsupportedLimit.\n\n @param [out] pValue Returns the size of the limit in bytes\n @param [in]  limit The limit to query\n\n @returns #hipSuccess, #hipErrorUnsupportedLimit, #hipErrorInvalidValue\n"]
    pub fn hipDeviceGetLimit(pValue: *mut usize, limit: hipLimit_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets resource limits of current device.\n\n As the input enum limit,\n #hipLimitStackSize sets the limit value of the stack size on the current GPU device, per thread.\n The limit size can get via hipDeviceGetLimit. The size is in units of 256 dwords, up to the limit\n (128K - 16).\n\n #hipLimitMallocHeapSize sets the limit value of the heap used by the malloc()/free()\n calls. For limit size, use the #hipDeviceGetLimit API.\n\n Any other input as default, the funtion will return hipErrorUnsupportedLimit.\n\n @param [in] limit Enum of hipLimit_t to set\n @param [in] value The size of limit value in bytes\n\n @returns #hipSuccess, #hipErrorUnsupportedLimit, #hipErrorInvalidValue\n"]
    pub fn hipDeviceSetLimit(limit: hipLimit_t, value: usize) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns bank width of shared memory for current device\n\n @param [out] pConfig The pointer of the bank width for shared memory\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized\n\n Note: AMD devices and some Nvidia GPUS do not support shared cache banking, and the hint is\n ignored on those architectures.\n"]
    pub fn hipDeviceGetSharedMemConfig(pConfig: *mut hipSharedMemConfig) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets the flags set for current device\n\n @param [out] flags Pointer of the flags\n\n @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue"]
    pub fn hipGetDeviceFlags(flags: *mut ::libc::c_uint) -> hipError_t;
}
extern "C" {
    #[doc = " @brief The bank width of shared memory on current device is set\n\n @param [in] config Configuration for the bank width of shared memory\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized\n\n Note: AMD devices and some Nvidia GPUS do not support shared cache banking, and the hint is\n ignored on those architectures.\n"]
    pub fn hipDeviceSetSharedMemConfig(config: hipSharedMemConfig) -> hipError_t;
}
extern "C" {
    #[doc = " @brief The current device behavior is changed according to the flags passed.\n\n @param [in] flags Flag to set on the current device\n\n The schedule flags impact how HIP waits for the completion of a command running on a device.\n\n #hipDeviceScheduleSpin         : HIP runtime will actively spin in the thread which submitted\n the work until the command completes.  This offers the lowest latency, but will consume a CPU\n core and may increase power.\n\n #hipDeviceScheduleYield        : The HIP runtime will yield the CPU to system so that other\n tasks can use it. This may increase latency to detect the completion but will consume less\n power and is friendlier to other tasks in the system.\n\n #hipDeviceScheduleBlockingSync : On ROCm platform, this is a synonym for hipDeviceScheduleYield.\n\n #hipDeviceScheduleAuto         : This is the default value if the input 'flags' is zero.\n Uses a heuristic to select between Spin and Yield modes. If the number of HIP contexts is\n greater than the number of logical processors in the system, uses Spin scheduling, otherwise\n uses Yield scheduling.\n\n #hipDeviceMapHost              : Allows mapping host memory. On ROCm, this is always allowed and\n the flag is ignored.\n\n #hipDeviceLmemResizeToMax      : This flag is silently ignored on ROCm.\n\n @returns #hipSuccess, #hipErrorNoDevice, #hipErrorInvalidDevice, #hipErrorSetOnActiveProcess\n\n"]
    pub fn hipSetDeviceFlags(flags: ::libc::c_uint) -> hipError_t;
}
extern "C" {
    pub fn hipChooseDeviceR0600(
        device: *mut ::libc::c_int,
        prop: *const hipDeviceProp_tR0600,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns the link type and hop count between two devices\n\n @param [in] device1 Ordinal for device1\n @param [in] device2 Ordinal for device2\n @param [out] linktype Returns the link type (See hsa_amd_link_info_type_t) between the two devices\n @param [out] hopcount Returns the hop count between the two devices\n\n Queries and returns the HSA link type and the hop count between the two specified devices.\n\n @returns #hipSuccess, #hipErrorInvalidValue"]
    pub fn hipExtGetLinkTypeAndHopCount(
        device1: ::libc::c_int,
        device2: ::libc::c_int,
        linktype: *mut u32,
        hopcount: *mut u32,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets an interprocess memory handle for an existing device memory allocation.\n\n Takes a pointer to the base of an existing device memory allocation created with ::hipMalloc\n and exports it for use in another process. This is a lightweight operation and may be called\n multiple times on an allocation without adverse effects.\n\n If a region of memory is freed with ::hipFree and a subsequent call to ::hipMalloc returns\n memory with the same device address, ::hipIpcGetMemHandle will return a unique handle for\n the new memory.\n\n @param handle - Pointer to user allocated hipIpcMemHandle to return the handle in.\n @param devPtr - Base pointer to previously allocated device memory.\n\n @returns #hipSuccess, #hipErrorInvalidHandle, #hipErrorOutOfMemory, #hipErrorMapFailed\n\n @note This IPC memory related feature API on Windows may behave differently from Linux.\n"]
    pub fn hipIpcGetMemHandle(
        handle: *mut hipIpcMemHandle_t,
        devPtr: *mut ::libc::c_void,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Opens an interprocess memory handle exported from another process and returns a device\n pointer usable in the local process.\n\n Maps memory exported from another process with ::hipIpcGetMemHandle into the current device\n address space. For contexts on different devices ::hipIpcOpenMemHandle can attempt to enable\n peer access between the devices like the user called ::hipDeviceEnablePeerAccess.\n This behavior is controlled by the flag #hipIpcMemLazyEnablePeerAccess.\n The API ::hipDeviceCanAccessPeer can determine if a mapping is possible.\n\n hipIpcMemHandles from each device in a given process may only be opened by one context per\n device per other process.\n\n Memory returned from ::hipIpcOpenMemHandle must be freed with ::hipIpcCloseMemHandle.\n\n Calling ::hipFree on an exported memory region before calling ::hipIpcCloseMemHandle in the\n importing context will result in undefined behavior.\n\n @param devPtr - Returned device pointer\n @param handle - hipIpcMemHandle to open\n @param flags  - Flags for this operation. Must be specified as hipIpcMemLazyEnablePeerAccess\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidContext,\n #hipErrorInvalidDevicePointer\n\n @note During multiple processes, using the same memory handle opened by the current context,\n there is no guarantee that the same device pointer will be returned in @p *devPtr.\n This is diffrent from CUDA.\n\n @note This IPC memory related feature API on Windows may behave differently from Linux.\n"]
    pub fn hipIpcOpenMemHandle(
        devPtr: *mut *mut ::libc::c_void,
        handle: hipIpcMemHandle_t,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Close memory mapped with ::hipIpcOpenMemHandle\n\n Unmaps memory returned by ::hipIpcOpenMemHandle. The original allocation in the exporting\n process as well as imported mappings in other processes will be unaffected.\n\n Any resources used to enable peer access will be freed if this is the last mapping using them.\n\n @param devPtr - Device pointer returned by ::hipIpcOpenMemHandle\n\n @returns #hipSuccess, #hipErrorMapFailed, #hipErrorInvalidHandle\n\n @note This IPC memory related feature API on Windows may behave differently from Linux.\n"]
    pub fn hipIpcCloseMemHandle(devPtr: *mut ::libc::c_void) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets an opaque interprocess handle for an event.\n\n The event is previously allocated with #hipEventInterprocess and #hipEventDisableTiming flags.\n The opaque interprocess handle may be copied into other processes and opened with\n ::hipIpcOpenEventHandle. Then ::hipEventRecord, ::hipEventSynchronize, ::hipStreamWaitEvent and\n ::hipEventQuery may be used in either process. After the exported event has been freed with\n ::hipEventDestroy, operations on the imported event will result in undefined behavior.\n\n @param[out]  handle Pointer to #hipIpcEventHandle to return the opaque event handle\n @param[in]   event  Event allocated with #hipEventInterprocess and #hipEventDisableTiming flags\n\n @returns #hipSuccess, #hipErrorInvalidConfiguration, #hipErrorInvalidValue\n\n @note This IPC event related feature API is currently applicable on Linux.\n"]
    pub fn hipIpcGetEventHandle(handle: *mut hipIpcEventHandle_t, event: hipEvent_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Opens an interprocess event handle.\n\n Opens an interprocess event handle exported from another process with ::hipIpcGetEventHandle.\n The returned #hipEvent_t behaves like a locally created event with the #hipEventDisableTiming\n flag specified. This event needs be freed with ::hipEventDestroy. After the exported event\n has been freed with ::hipEventDestroy, operations on the imported event will result in\n undefined behavior. If the input handle is from the same process, it will return\n #hipErrorInvalidContext.\n\n @param[out]  event  Pointer to hipEvent_t to return the imported event\n @param[in]   handle The opaque interprocess handle to open\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidContext\n\n @note This IPC event related feature API is currently applicable on Linux.\n"]
    pub fn hipIpcOpenEventHandle(event: *mut hipEvent_t, handle: hipIpcEventHandle_t)
        -> hipError_t;
}
extern "C" {
    #[doc = " @}\n/\n/**\n\n  @defgroup Execution Execution Control\n  @{\n  This section describes the execution control functions of HIP runtime API.\n\n/\n/**\n @brief Set attribute for a specific function\n\n @param [in] func Pointer of the function\n @param [in] attr Attribute to set\n @param [in] value Value to set\n\n @returns #hipSuccess, #hipErrorInvalidDeviceFunction, #hipErrorInvalidValue\n\n Note: AMD devices and some Nvidia GPUS do not support shared cache banking, and the hint is\n ignored on those architectures.\n"]
    pub fn hipFuncSetAttribute(
        func: *const ::libc::c_void,
        attr: hipFuncAttribute,
        value: ::libc::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Set Cache configuration for a specific function\n\n @param [in] func Pointer of the function.\n @param [in] config Configuration to set.\n\n @returns #hipSuccess, #hipErrorNotInitialized\n Note: AMD devices and some Nvidia GPUS do not support reconfigurable cache.  This hint is ignored\n on those architectures.\n"]
    pub fn hipFuncSetCacheConfig(func: *const ::libc::c_void, config: hipFuncCache_t)
        -> hipError_t;
}
extern "C" {
    #[doc = " @brief Set shared memory configuation for a specific function\n\n @param [in] func Pointer of the function\n @param [in] config Configuration\n\n @returns #hipSuccess, #hipErrorInvalidDeviceFunction, #hipErrorInvalidValue\n\n Note: AMD devices and some Nvidia GPUS do not support shared cache banking, and the hint is\n ignored on those architectures.\n"]
    pub fn hipFuncSetSharedMemConfig(
        func: *const ::libc::c_void,
        config: hipSharedMemConfig,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @}\n/\n/**\n-------------------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------------------\n  @defgroup Error Error Handling\n  @{\n  This section describes the error handling functions of HIP runtime API.\n/\n/**\n @brief Return last error returned by any HIP runtime API call and resets the stored error code to\n #hipSuccess\n\n @returns return code from last HIP called from the active host thread\n\n Returns the last error that has been returned by any of the runtime calls in the same host\n thread, and then resets the saved error to #hipSuccess.\n\n @see hipGetErrorString, hipGetLastError, hipPeakAtLastError, hipError_t"]
    pub fn hipGetLastError() -> hipError_t;
}
extern "C" {
    #[doc = " @brief Return last error returned by any HIP runtime API call and resets the stored error code to\n #hipSuccess\n\n @returns return code from last HIP called from the active host thread\n\n Returns the last error that has been returned by any of the runtime calls in the same host\n thread, and then resets the saved error to #hipSuccess.\n\n @see hipGetErrorString, hipGetLastError, hipPeakAtLastError, hipError_t"]
    pub fn hipExtGetLastError() -> hipError_t;
}
extern "C" {
    #[doc = " @brief Return last error returned by any HIP runtime API call.\n\n @returns #hipSuccess\n\n Returns the last error that has been returned by any of the runtime calls in the same host\n thread. Unlike hipGetLastError, this function does not reset the saved error code.\n\n @see hipGetErrorString, hipGetLastError, hipPeakAtLastError, hipError_t"]
    pub fn hipPeekAtLastError() -> hipError_t;
}
extern "C" {
    #[doc = " @brief Return hip error as text string form.\n\n @param hip_error Error code to convert to name.\n @returns const char pointer to the NULL-terminated error name\n\n @see hipGetErrorString, hipGetLastError, hipPeakAtLastError, hipError_t"]
    pub fn hipGetErrorName(hip_error: hipError_t) -> *const ::libc::c_char;
}
extern "C" {
    #[doc = " @brief Return handy text string message to explain the error which occurred\n\n @param hipError Error code to convert to string.\n @returns const char pointer to the NULL-terminated error string\n\n @see hipGetErrorName, hipGetLastError, hipPeakAtLastError, hipError_t"]
    pub fn hipGetErrorString(hipError: hipError_t) -> *const ::libc::c_char;
}
extern "C" {
    #[doc = " @brief Return hip error as text string form.\n\n @param [in] hipError Error code to convert to string.\n @param [out] errorString char pointer to the NULL-terminated error string\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @see hipGetErrorName, hipGetLastError, hipPeakAtLastError, hipError_t"]
    pub fn hipDrvGetErrorName(
        hipError: hipError_t,
        errorString: *mut *const ::libc::c_char,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Return handy text string message to explain the error which occurred\n\n @param [in] hipError Error code to convert to string.\n @param [out] errorString char pointer to the NULL-terminated error string\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @see hipGetErrorName, hipGetLastError, hipPeakAtLastError, hipError_t"]
    pub fn hipDrvGetErrorString(
        hipError: hipError_t,
        errorString: *mut *const ::libc::c_char,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Create an asynchronous stream.\n\n @param[in, out] stream Valid pointer to hipStream_t.  This function writes the memory with the\n newly created stream.\n @returns #hipSuccess, #hipErrorInvalidValue\n\n Create a new asynchronous stream.  @p stream returns an opaque handle that can be used to\n reference the newly created stream in subsequent hipStream* commands.  The stream is allocated on\n the heap and will remain allocated even if the handle goes out-of-scope.  To release the memory\n used by the stream, application must call hipStreamDestroy.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @see hipStreamCreateWithFlags, hipStreamCreateWithPriority, hipStreamSynchronize, hipStreamWaitEvent, hipStreamDestroy"]
    pub fn hipStreamCreate(stream: *mut hipStream_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Create an asynchronous stream.\n\n @param[in, out] stream Pointer to new stream\n @param[in ] flags to control stream creation.\n @returns #hipSuccess, #hipErrorInvalidValue\n\n Create a new asynchronous stream.  @p stream returns an opaque handle that can be used to\n reference the newly created stream in subsequent hipStream* commands.  The stream is allocated on\n the heap and will remain allocated even if the handle goes out-of-scope.  To release the memory\n used by the stream, application must call hipStreamDestroy. Flags controls behavior of the\n stream.  See #hipStreamDefault, #hipStreamNonBlocking.\n\n\n @see hipStreamCreate, hipStreamCreateWithPriority, hipStreamSynchronize, hipStreamWaitEvent, hipStreamDestroy"]
    pub fn hipStreamCreateWithFlags(stream: *mut hipStream_t, flags: ::libc::c_uint) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Create an asynchronous stream with the specified priority.\n\n @param[in, out] stream Pointer to new stream\n @param[in ] flags to control stream creation.\n @param[in ] priority of the stream. Lower numbers represent higher priorities.\n @returns #hipSuccess, #hipErrorInvalidValue\n\n Create a new asynchronous stream with the specified priority.  @p stream returns an opaque handle\n that can be used to reference the newly created stream in subsequent hipStream* commands.  The\n stream is allocated on the heap and will remain allocated even if the handle goes out-of-scope.\n To release the memory used by the stream, application must call hipStreamDestroy. Flags controls\n behavior of the stream.  See #hipStreamDefault, #hipStreamNonBlocking.\n\n\n @see hipStreamCreate, hipStreamSynchronize, hipStreamWaitEvent, hipStreamDestroy"]
    pub fn hipStreamCreateWithPriority(
        stream: *mut hipStream_t,
        flags: ::libc::c_uint,
        priority: ::libc::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns numerical values that correspond to the least and greatest stream priority.\n\n @param[in, out] leastPriority pointer in which value corresponding to least priority is returned.\n @param[in, out] greatestPriority pointer in which value corresponding to greatest priority is returned.\n @returns #hipSuccess\n\n Returns in *leastPriority and *greatestPriority the numerical values that correspond to the least\n and greatest stream priority respectively. Stream priorities follow a convention where lower numbers\n imply greater priorities. The range of meaningful stream priorities is given by\n [*greatestPriority, *leastPriority]. If the user attempts to create a stream with a priority value\n that is outside the meaningful range as specified by this API, the priority is automatically\n clamped to within the valid range."]
    pub fn hipDeviceGetStreamPriorityRange(
        leastPriority: *mut ::libc::c_int,
        greatestPriority: *mut ::libc::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Destroys the specified stream.\n\n @param[in] stream stream identifier.\n @returns #hipSuccess #hipErrorInvalidHandle\n\n Destroys the specified stream.\n\n If commands are still executing on the specified stream, some may complete execution before the\n queue is deleted.\n\n The queue may be destroyed while some commands are still inflight, or may wait for all commands\n queued to the stream before destroying it.\n\n @see hipStreamCreate, hipStreamCreateWithFlags, hipStreamCreateWithPriority, hipStreamQuery,\n hipStreamWaitEvent, hipStreamSynchronize"]
    pub fn hipStreamDestroy(stream: hipStream_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Return #hipSuccess if all of the operations in the specified @p stream have completed, or\n #hipErrorNotReady if not.\n\n @param[in] stream stream to query\n\n @returns #hipSuccess, #hipErrorNotReady, #hipErrorInvalidHandle\n\n This is thread-safe and returns a snapshot of the current state of the queue.  However, if other\n host threads are sending work to the stream, the status may change immediately after the function\n is called.  It is typically used for debug.\n\n @see hipStreamCreate, hipStreamCreateWithFlags, hipStreamCreateWithPriority, hipStreamWaitEvent,\n hipStreamSynchronize, hipStreamDestroy"]
    pub fn hipStreamQuery(stream: hipStream_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Wait for all commands in stream to complete.\n\n @param[in] stream stream identifier.\n\n @returns #hipSuccess, #hipErrorInvalidHandle\n\n This command is host-synchronous : the host will block until the specified stream is empty.\n\n This command follows standard null-stream semantics.  Specifically, specifying the null stream\n will cause the command to wait for other streams on the same device to complete all pending\n operations.\n\n This command honors the hipDeviceLaunchBlocking flag, which controls whether the wait is active\n or blocking.\n\n @see hipStreamCreate, hipStreamCreateWithFlags, hipStreamCreateWithPriority, hipStreamWaitEvent,\n hipStreamDestroy\n"]
    pub fn hipStreamSynchronize(stream: hipStream_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Make the specified compute stream wait for an event\n\n @param[in] stream stream to make wait.\n @param[in] event event to wait on\n @param[in] flags control operation [must be 0]\n\n @returns #hipSuccess, #hipErrorInvalidHandle\n\n This function inserts a wait operation into the specified stream.\n All future work submitted to @p stream will wait until @p event reports completion before\n beginning execution.\n\n This function only waits for commands in the current stream to complete.  Notably, this function\n does not implicitly wait for commands in the default stream to complete, even if the specified\n stream is created with hipStreamNonBlocking = 0.\n\n @see hipStreamCreate, hipStreamCreateWithFlags, hipStreamCreateWithPriority, hipStreamSynchronize, hipStreamDestroy"]
    pub fn hipStreamWaitEvent(
        stream: hipStream_t,
        event: hipEvent_t,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Return flags associated with this stream.\n\n @param[in] stream stream to be queried\n @param[in,out] flags Pointer to an unsigned integer in which the stream's flags are returned\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidHandle\n\n @returns #hipSuccess #hipErrorInvalidValue #hipErrorInvalidHandle\n\n Return flags associated with this stream in *@p flags.\n\n @see hipStreamCreateWithFlags"]
    pub fn hipStreamGetFlags(stream: hipStream_t, flags: *mut ::libc::c_uint) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Query the priority of a stream.\n\n @param[in] stream stream to be queried\n @param[in,out] priority Pointer to an unsigned integer in which the stream's priority is returned\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidHandle\n\n @returns #hipSuccess #hipErrorInvalidValue #hipErrorInvalidHandle\n\n Query the priority of a stream. The priority is returned in in priority.\n\n @see hipStreamCreateWithFlags"]
    pub fn hipStreamGetPriority(stream: hipStream_t, priority: *mut ::libc::c_int) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Get the device assocaited with the stream\n\n @param[in] stream stream to be queried\n @param[out] device device associated with the stream\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorContextIsDestroyed, #hipErrorInvalidHandle,\n #hipErrorNotInitialized, #hipErrorDeinitialized, #hipErrorInvalidContext\n\n @see hipStreamCreate, hipStreamDestroy, hipDeviceGetStreamPriorityRange"]
    pub fn hipStreamGetDevice(stream: hipStream_t, device: *mut hipDevice_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Create an asynchronous stream with the specified CU mask.\n\n @param[in, out] stream Pointer to new stream\n @param[in ] cuMaskSize Size of CU mask bit array passed in.\n @param[in ] cuMask Bit-vector representing the CU mask. Each active bit represents using one CU.\n The first 32 bits represent the first 32 CUs, and so on. If its size is greater than physical\n CU number (i.e., multiProcessorCount member of hipDeviceProp_t), the extra elements are ignored.\n It is user's responsibility to make sure the input is meaningful.\n @returns #hipSuccess, #hipErrorInvalidHandle, #hipErrorInvalidValue\n\n Create a new asynchronous stream with the specified CU mask.  @p stream returns an opaque handle\n that can be used to reference the newly created stream in subsequent hipStream* commands.  The\n stream is allocated on the heap and will remain allocated even if the handle goes out-of-scope.\n To release the memory used by the stream, application must call hipStreamDestroy.\n\n\n @see hipStreamCreate, hipStreamSynchronize, hipStreamWaitEvent, hipStreamDestroy"]
    pub fn hipExtStreamCreateWithCUMask(
        stream: *mut hipStream_t,
        cuMaskSize: u32,
        cuMask: *const u32,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Get CU mask associated with an asynchronous stream\n\n @param[in] stream stream to be queried\n @param[in] cuMaskSize number of the block of memories (uint32_t *) allocated by user\n @param[out] cuMask Pointer to a pre-allocated block of memories (uint32_t *) in which\n the stream's CU mask is returned. The CU mask is returned in a chunck of 32 bits where\n each active bit represents one active CU\n @returns #hipSuccess, #hipErrorInvalidHandle, #hipErrorInvalidValue\n\n @see hipStreamCreate, hipStreamSynchronize, hipStreamWaitEvent, hipStreamDestroy"]
    pub fn hipExtStreamGetCUMask(
        stream: hipStream_t,
        cuMaskSize: u32,
        cuMask: *mut u32,
    ) -> hipError_t;
}
#[doc = " Stream CallBack struct"]
pub type hipStreamCallback_t = ::std::option::Option<
    unsafe extern "C" fn(stream: hipStream_t, status: hipError_t, userData: *mut ::libc::c_void),
>;
extern "C" {
    #[doc = " @brief Adds a callback to be called on the host after all currently enqueued\n items in the stream have completed.  For each\n hipStreamAddCallback call, a callback will be executed exactly once.\n The callback will block later work in the stream until it is finished.\n @param[in] stream   - Stream to add callback to\n @param[in] callback - The function to call once preceding stream operations are complete\n @param[in] userData - User specified data to be passed to the callback function\n @param[in] flags    - Reserved for future use, must be 0\n @returns #hipSuccess, #hipErrorInvalidHandle, #hipErrorNotSupported\n\n @see hipStreamCreate, hipStreamCreateWithFlags, hipStreamQuery, hipStreamSynchronize,\n hipStreamWaitEvent, hipStreamDestroy, hipStreamCreateWithPriority\n"]
    pub fn hipStreamAddCallback(
        stream: hipStream_t,
        callback: hipStreamCallback_t,
        userData: *mut ::libc::c_void,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Enqueues a wait command to the stream.[BETA]\n\n @param [in] stream - Stream identifier\n @param [in] ptr    - Pointer to memory object allocated using #hipMallocSignalMemory flag\n @param [in] value  - Value to be used in compare operation\n @param [in] flags  - Defines the compare operation, supported values are #hipStreamWaitValueGte\n #hipStreamWaitValueEq, #hipStreamWaitValueAnd and #hipStreamWaitValueNor\n @param [in] mask   - Mask to be applied on value at memory before it is compared with value,\n default value is set to enable every bit\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n Enqueues a wait command to the stream, all operations enqueued  on this stream after this, will\n not execute until the defined wait condition is true.\n\n #hipStreamWaitValueGte: waits until *ptr&mask >= value\n\n #hipStreamWaitValueEq : waits until *ptr&mask == value\n\n #hipStreamWaitValueAnd: waits until ((*ptr&mask) & value) != 0\n\n #hipStreamWaitValueNor: waits until ~((*ptr&mask) | (value&mask)) != 0\n\n @note when using #hipStreamWaitValueNor, mask is applied on both 'value' and '*ptr'.\n\n @note Support for #hipStreamWaitValue32 can be queried using 'hipDeviceGetAttribute()' and\n 'hipDeviceAttributeCanUseStreamWaitValue' flag.\n\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues.\n\n @see hipExtMallocWithFlags, hipFree, hipStreamWaitValue64, hipStreamWriteValue64,\n hipStreamWriteValue32, hipDeviceGetAttribute"]
    pub fn hipStreamWaitValue32(
        stream: hipStream_t,
        ptr: *mut ::libc::c_void,
        value: u32,
        flags: ::libc::c_uint,
        mask: u32,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Enqueues a wait command to the stream.[BETA]\n\n @param [in] stream - Stream identifier\n @param [in] ptr    - Pointer to memory object allocated using 'hipMallocSignalMemory' flag\n @param [in] value  - Value to be used in compare operation\n @param [in] flags  - Defines the compare operation, supported values are #hipStreamWaitValueGte\n #hipStreamWaitValueEq, #hipStreamWaitValueAnd and #hipStreamWaitValueNor.\n @param [in] mask   - Mask to be applied on value at memory before it is compared with value\n default value is set to enable every bit\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n Enqueues a wait command to the stream, all operations enqueued  on this stream after this, will\n not execute until the defined wait condition is true.\n\n #hipStreamWaitValueGte: waits until *ptr&mask >= value\n\n #hipStreamWaitValueEq : waits until *ptr&mask == value\n\n #hipStreamWaitValueAnd: waits until ((*ptr&mask) & value) != 0\n\n #hipStreamWaitValueNor: waits until ~((*ptr&mask) | (value&mask)) != 0\n\n @note when using #hipStreamWaitValueNor, mask is applied on both 'value' and '*ptr'.\n\n @note Support for hipStreamWaitValue64 can be queried using 'hipDeviceGetAttribute()' and\n 'hipDeviceAttributeCanUseStreamWaitValue' flag.\n\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues.\n\n @see hipExtMallocWithFlags, hipFree, hipStreamWaitValue32, hipStreamWriteValue64,\n hipStreamWriteValue32, hipDeviceGetAttribute"]
    pub fn hipStreamWaitValue64(
        stream: hipStream_t,
        ptr: *mut ::libc::c_void,
        value: u64,
        flags: ::libc::c_uint,
        mask: u64,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Enqueues a write command to the stream.[BETA]\n\n @param [in] stream - Stream identifier\n @param [in] ptr    - Pointer to a GPU accessible memory object\n @param [in] value  - Value to be written\n @param [in] flags  - reserved, ignored for now, will be used in future releases\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n Enqueues a write command to the stream, write operation is performed after all earlier commands\n on this stream have completed the execution.\n\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues.\n\n @see hipExtMallocWithFlags, hipFree, hipStreamWriteValue32, hipStreamWaitValue32,\n hipStreamWaitValue64"]
    pub fn hipStreamWriteValue32(
        stream: hipStream_t,
        ptr: *mut ::libc::c_void,
        value: u32,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Enqueues a write command to the stream.[BETA]\n\n @param [in] stream - Stream identifier\n @param [in] ptr    - Pointer to a GPU accessible memory object\n @param [in] value  - Value to be written\n @param [in] flags  - reserved, ignored for now, will be used in future releases\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n Enqueues a write command to the stream, write operation is performed after all earlier commands\n on this stream have completed the execution.\n\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues.\n\n @see hipExtMallocWithFlags, hipFree, hipStreamWriteValue32, hipStreamWaitValue32,\n hipStreamWaitValue64"]
    pub fn hipStreamWriteValue64(
        stream: hipStream_t,
        ptr: *mut ::libc::c_void,
        value: u64,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Enqueues an array of stream memory operations in the stream.[BETA]\n\n @param [in] stream      - Stream identifier\n @param [in] count       - The number of operations in the array. Must be less than 256\n @param [in] paramArray  - The types and parameters of the individual operations.\n @param [in] flags       - Reserved for future expansion; must be 0.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n Batch operations to synchronize the stream via memory operations.\n\n @warning This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @see hipStreamWriteValue32, hipStreamWaitValue32,\n hipStreamWaitValue64. hipStreamWriteValue64"]
    pub fn hipStreamBatchMemOp(
        stream: hipStream_t,
        count: ::libc::c_uint,
        paramArray: *mut hipStreamBatchMemOpParams,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Creates a batch memory operation node and adds it to a graph.[BETA]\n\n @param [in] phGraphNode      - Returns the newly created node\n @param [in] hGraph           - Graph to which to add the node\n @param [in] dependencies     -  Dependencies of the node\n @param [in] numDependencies  - Number of dependencies\n @param [in] nodeParams       - Parameters for the node\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @see hipStreamWriteValue32, hipStreamWaitValue32,\n hipStreamWaitValue64. hipStreamWriteValue64, hipStreamBatchMemOp"]
    pub fn hipGraphAddBatchMemOpNode(
        phGraphNode: *mut hipGraphNode_t,
        hGraph: hipGraph_t,
        dependencies: *const hipGraphNode_t,
        numDependencies: usize,
        nodeParams: *const hipBatchMemOpNodeParams,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns a batch mem op node's parameters.[BETA]\n\n @param [in] hNode           - Node to get the parameters for\n @param [in] nodeParams_out  - Pointer to return the parameters\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n Returns the parameters of batch mem op node hNode in nodeParams_out.\n The paramArray returned in nodeParams_out is owned by the node.\n This memory remains valid until the node is destroyed or its parameters are modified,\n and should not be modified directly.\n\n @warning This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @see hipStreamWriteValue32, hipStreamWaitValue32,\n hipStreamWaitValue64. hipStreamWriteValue64. hipGraphBatchMemOpNodeSetParams"]
    pub fn hipGraphBatchMemOpNodeGetParams(
        hNode: hipGraphNode_t,
        nodeParams_out: *mut hipBatchMemOpNodeParams,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets the batch mem op node's parameters.[BETA]\n\n @param [in] hNode       - Node to set the parameters for\n @param [in] nodeParams  - Parameters to copy\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n Sets the parameters of batch mem op node hNode to nodeParams.\n\n @warning This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @see hipStreamWriteValue32, hipStreamWaitValue32,\n hipStreamWaitValue64. hipStreamWriteValue64, hipGraphBatchMemOpNodeGetParams"]
    pub fn hipGraphBatchMemOpNodeSetParams(
        hNode: hipGraphNode_t,
        nodeParams: *mut hipBatchMemOpNodeParams,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets the parameters for a batch mem op node in the given graphExec.[BETA]\n\n @param [in] hGraphExec  - The executable graph in which to set the specified node\n @param [in] hNode       - Batch mem op node from the graph from which graphExec was instantiated\n @param [in] nodeParams  - Updated Parameters to set\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n Sets the parameters of a batch mem op node in an executable graph hGraphExec.\n The node is identified by the corresponding node hNode in the non-executable graph,\n from which the executable graph was instantiated.\n\n @warning This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues.\n\n @see hipStreamWriteValue32, hipStreamWaitValue32,\n hipStreamWaitValue64. hipStreamWriteValue64, hipStreamBatchMemOp"]
    pub fn hipGraphExecBatchMemOpNodeSetParams(
        hGraphExec: hipGraphExec_t,
        hNode: hipGraphNode_t,
        nodeParams: *const hipBatchMemOpNodeParams,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @}\n/\n/**\n-------------------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------------------\n  @defgroup Event Event Management\n  @{\n  This section describes the event management functions of HIP runtime API.\n/\n/**\n @brief Create an event with the specified flags\n\n @param[in,out] event Returns the newly created event.\n @param[in] flags     Flags to control event behavior.  Valid values are #hipEventDefault,\n#hipEventBlockingSync, #hipEventDisableTiming, #hipEventInterprocess\n #hipEventDefault : Default flag.  The event will use active synchronization and will support\ntiming.  Blocking synchronization provides lowest possible latency at the expense of dedicating a\nCPU to poll on the event.\n #hipEventBlockingSync : The event will use blocking synchronization : if hipEventSynchronize is\ncalled on this event, the thread will block until the event completes.  This can increase latency\nfor the synchroniation but can result in lower power and more resources for other CPU threads.\n #hipEventDisableTiming : Disable recording of timing information. Events created with this flag\nwould not record profiling data and provide best performance if used for synchronization.\n #hipEventInterprocess : The event can be used as an interprocess event. hipEventDisableTiming\nflag also must be set when hipEventInterprocess flag is set.\n #hipEventDisableSystemFence : Disable acquire and release system scope fence. This may\nimprove performance but device memory may not be visible to the host and other devices\nif this flag is set.\n\n @returns #hipSuccess, #hipErrorNotInitialized, #hipErrorInvalidValue,\n#hipErrorLaunchFailure, #hipErrorOutOfMemory\n\n @see hipEventCreate, hipEventSynchronize, hipEventDestroy, hipEventElapsedTime"]
    pub fn hipEventCreateWithFlags(event: *mut hipEvent_t, flags: ::libc::c_uint) -> hipError_t;
}
extern "C" {
    #[doc = "  Create an event\n\n @param[in,out] event Returns the newly created event.\n\n @returns #hipSuccess, #hipErrorNotInitialized, #hipErrorInvalidValue,\n #hipErrorLaunchFailure, #hipErrorOutOfMemory\n\n @see hipEventCreateWithFlags, hipEventRecord, hipEventQuery, hipEventSynchronize,\n hipEventDestroy, hipEventElapsedTime"]
    pub fn hipEventCreate(event: *mut hipEvent_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Record an event in the specified stream.\n\n @param[in] event event to record.\n @param[in] stream stream in which to record event.\n @param[in] flags parameter for operations\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized,\n #hipErrorInvalidHandle, #hipErrorLaunchFailure\n\n hipEventQuery() or hipEventSynchronize() must be used to determine when the event\n transitions from \"recording\" (after hipEventRecord() is called) to \"recorded\"\n (when timestamps are set, if requested).\n\n Events which are recorded in a non-NULL stream will transition to\n from recording to \"recorded\" state when they reach the head of\n the specified stream, after all previous\n commands in that stream have completed executing.\n\n Flags include:\n   hipEventRecordDefault: Default event creation flag.\n   hipEventRecordExternal: Event is captured in the graph as an external event node when\n                           performing stream capture\n\n If hipEventRecord() has been previously called on this event, then this call will overwrite any\n existing state in event.\n\n If this function is called on an event that is currently being recorded, results are undefined\n - either outstanding recording may save state into the event, and the order is not guaranteed.\n\n @note: If this function is not called before use hipEventQuery() or hipEventSynchronize(),\n #hipSuccess is returned, meaning no pending event in the stream.\n\n @see hipEventCreate, hipEventCreateWithFlags, hipEventQuery, hipEventSynchronize,\n hipEventDestroy, hipEventElapsedTime\n"]
    pub fn hipEventRecordWithFlags(
        event: hipEvent_t,
        stream: hipStream_t,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipEventRecord(event: hipEvent_t, stream: hipStream_t) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Destroy the specified event.\n\n  @param[in] event Event to destroy.\n  @returns #hipSuccess, #hipErrorNotInitialized, #hipErrorInvalidValue,\n #hipErrorLaunchFailure\n\n  Releases memory associated with the event.  If the event is recording but has not completed\n recording when hipEventDestroy() is called, the function will return immediately and the\n completion_future resources will be released later, when the hipDevice is synchronized.\n\n @see hipEventCreate, hipEventCreateWithFlags, hipEventQuery, hipEventSynchronize, hipEventRecord,\n hipEventElapsedTime\n\n @returns #hipSuccess"]
    pub fn hipEventDestroy(event: hipEvent_t) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Wait for an event to complete.\n\n  This function will block until the event is ready, waiting for all previous work in the stream\n specified when event was recorded with hipEventRecord().\n\n  If hipEventRecord() has not been called on @p event, this function returns #hipSuccess when no\n  event is captured.\n\n\n  @param[in] event Event on which to wait.\n\n  @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized,\n #hipErrorInvalidHandle, #hipErrorLaunchFailure\n\n  @see hipEventCreate, hipEventCreateWithFlags, hipEventQuery, hipEventDestroy, hipEventRecord,\n hipEventElapsedTime"]
    pub fn hipEventSynchronize(event: hipEvent_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Return the elapsed time between two events.\n\n @param[out] ms : Return time between start and stop in ms.\n @param[in]   start : Start event.\n @param[in]   stop  : Stop event.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotReady, #hipErrorInvalidHandle,\n #hipErrorNotInitialized, #hipErrorLaunchFailure\n\n Computes the elapsed time between two events. Time is computed in ms, with\n a resolution of approximately 1 us.\n\n Events which are recorded in a NULL stream will block until all commands\n on all other streams complete execution, and then record the timestamp.\n\n Events which are recorded in a non-NULL stream will record their timestamp\n when they reach the head of the specified stream, after all previous\n commands in that stream have completed executing.  Thus the time that\n the event recorded may be significantly after the host calls hipEventRecord().\n\n If hipEventRecord() has not been called on either event, then #hipErrorInvalidHandle is\n returned. If hipEventRecord() has been called on both events, but the timestamp has not yet been\n recorded on one or both events (that is, hipEventQuery() would return #hipErrorNotReady on at\n least one of the events), then #hipErrorNotReady is returned.\n\n @see hipEventCreate, hipEventCreateWithFlags, hipEventQuery, hipEventDestroy, hipEventRecord,\n hipEventSynchronize"]
    pub fn hipEventElapsedTime(ms: *mut f32, start: hipEvent_t, stop: hipEvent_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Query event status\n\n @param[in] event Event to query.\n @returns #hipSuccess, #hipErrorNotReady, #hipErrorInvalidHandle, #hipErrorInvalidValue,\n #hipErrorNotInitialized, #hipErrorLaunchFailure\n\n Query the status of the specified event.  This function will return #hipSuccess if all\n commands in the appropriate stream (specified to hipEventRecord()) have completed.  If any execution\n has not completed, then #hipErrorNotReady is returned.\n\n @note This API returns #hipSuccess, if hipEventRecord() is not called before this API.\n\n @see hipEventCreate, hipEventCreateWithFlags, hipEventRecord, hipEventDestroy,\n hipEventSynchronize, hipEventElapsedTime"]
    pub fn hipEventQuery(event: hipEvent_t) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Sets information on the specified pointer.[BETA]\n\n  @param [in]      value     Sets pointer attribute value\n  @param [in]      attribute  Attribute to set\n  @param [in]      ptr      Pointer to set attributes for\n\n  @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue\n\n  @warning This API is marked as Beta. While this feature is complete, it can\n           change and might have outstanding issues.\n"]
    pub fn hipPointerSetAttribute(
        value: *const ::libc::c_void,
        attribute: hipPointer_attribute,
        ptr: hipDeviceptr_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Returns attributes for the specified pointer\n\n  @param [out]  attributes  attributes for the specified pointer\n  @param [in]   ptr         pointer to get attributes for\n\n  The output parameter 'attributes' has a member named 'type' that describes what memory the\n  pointer is associated with, such as device memory, host memory, managed memory, and others.\n  Otherwise, the API cannot handle the pointer and returns #hipErrorInvalidValue.\n\n  @note  The unrecognized memory type is unsupported to keep the HIP functionality backward\n  compatibility due to #hipMemoryType enum values.\n\n  @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue\n\n  @note  The current behavior of this HIP API corresponds to the CUDA API before version 11.0.\n\n  @see hipPointerGetAttribute"]
    pub fn hipPointerGetAttributes(
        attributes: *mut hipPointerAttribute_t,
        ptr: *const ::libc::c_void,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Returns information about the specified pointer.[BETA]\n\n  @param [in, out] data     Returned pointer attribute value\n  @param [in]      attribute  Attribute to query for\n  @param [in]      ptr      Pointer to get attributes for\n\n  @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue\n\n  @warning This API is marked as Beta. While this feature is complete, it can\n           change and might have outstanding issues.\n\n  @see hipPointerGetAttributes"]
    pub fn hipPointerGetAttribute(
        data: *mut ::libc::c_void,
        attribute: hipPointer_attribute,
        ptr: hipDeviceptr_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Returns information about the specified pointer.[BETA]\n\n  @param [in]  numAttributes   number of attributes to query for\n  @param [in]  attributes      attributes to query for\n  @param [in, out] data        a two-dimensional containing pointers to memory locations\n                               where the result of each attribute query will be written to\n  @param [in]  ptr             pointer to get attributes for\n\n  @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue\n\n  @warning This API is marked as Beta. While this feature is complete, it can\n           change and might have outstanding issues.\n\n  @see hipPointerGetAttribute"]
    pub fn hipDrvPointerGetAttributes(
        numAttributes: ::libc::c_uint,
        attributes: *mut hipPointer_attribute,
        data: *mut *mut ::libc::c_void,
        ptr: hipDeviceptr_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "-------------------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------------------\n  @defgroup External External Resource Interoperability\n  @{\n  @ingroup API\n\n  This section describes the external resource interoperability functions of HIP runtime API.\n\n/\n/**\n  @brief Imports an external semaphore.\n\n  @param[out] extSem_out  External semaphores to be waited on\n  @param[in] semHandleDesc Semaphore import handle descriptor\n\n  @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue\n\n  @see\n\n  @note  This API is currently not supported on Linux.\n"]
    pub fn hipImportExternalSemaphore(
        extSem_out: *mut hipExternalSemaphore_t,
        semHandleDesc: *const hipExternalSemaphoreHandleDesc,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Signals a set of external semaphore objects.\n\n  @param[in] extSemArray  External semaphores to be waited on\n  @param[in] paramsArray Array of semaphore parameters\n  @param[in] numExtSems Number of semaphores to wait on\n  @param[in] stream Stream to enqueue the wait operations in\n\n  @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue\n\n  @see\n\n  @note  This API is currently not supported on Linux.\n"]
    pub fn hipSignalExternalSemaphoresAsync(
        extSemArray: *const hipExternalSemaphore_t,
        paramsArray: *const hipExternalSemaphoreSignalParams,
        numExtSems: ::libc::c_uint,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Waits on a set of external semaphore objects\n\n  @param[in] extSemArray  External semaphores to be waited on\n  @param[in] paramsArray Array of semaphore parameters\n  @param[in] numExtSems Number of semaphores to wait on\n  @param[in] stream Stream to enqueue the wait operations in\n\n  @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue\n\n  @see\n\n  @note  This API is currently not supported on Linux.\n"]
    pub fn hipWaitExternalSemaphoresAsync(
        extSemArray: *const hipExternalSemaphore_t,
        paramsArray: *const hipExternalSemaphoreWaitParams,
        numExtSems: ::libc::c_uint,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Destroys an external semaphore object and releases any references to the underlying resource. Any outstanding signals or waits must have completed before the semaphore is destroyed.\n\n  @param[in] extSem handle to an external memory object\n\n  @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue\n\n  @see\n\n  @note  This API is currently not supported on Linux.\n"]
    pub fn hipDestroyExternalSemaphore(extSem: hipExternalSemaphore_t) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Imports an external memory object.\n\n  @param[out] extMem_out  Returned handle to an external memory object\n  @param[in]  memHandleDesc Memory import handle descriptor\n\n  @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue\n\n  @see"]
    pub fn hipImportExternalMemory(
        extMem_out: *mut hipExternalMemory_t,
        memHandleDesc: *const hipExternalMemoryHandleDesc,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Maps a buffer onto an imported memory object.\n\n  @param[out] devPtr Returned device pointer to buffer\n  @param[in]  extMem  Handle to external memory object\n  @param[in]  bufferDesc  Buffer descriptor\n\n  @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue\n\n  @see"]
    pub fn hipExternalMemoryGetMappedBuffer(
        devPtr: *mut *mut ::libc::c_void,
        extMem: hipExternalMemory_t,
        bufferDesc: *const hipExternalMemoryBufferDesc,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Destroys an external memory object.\n\n  @param[in] extMem  External memory object to be destroyed\n\n  @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue\n\n  @see"]
    pub fn hipDestroyExternalMemory(extMem: hipExternalMemory_t) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Maps a mipmapped array onto an external memory object.\n\n  @param[out] mipmap mipmapped array to return\n  @param[in]  extMem external memory object handle\n  @param[in]  mipmapDesc external mipmapped array descriptor\n\n  Returned mipmapped array must be freed using hipFreeMipmappedArray.\n\n  @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidResourceHandle\n\n  @see hipImportExternalMemory, hipDestroyExternalMemory, hipExternalMemoryGetMappedBuffer, hipFreeMipmappedArray"]
    pub fn hipExternalMemoryGetMappedMipmappedArray(
        mipmap: *mut hipMipmappedArray_t,
        extMem: hipExternalMemory_t,
        mipmapDesc: *const hipExternalMemoryMipmappedArrayDesc,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @}\n/\n/**\n  @brief Allocate memory on the default accelerator\n\n  @param[out] ptr Pointer to the allocated memory\n  @param[in]  size Requested memory size\n\n  If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned.\n\n  @returns #hipSuccess, #hipErrorOutOfMemory, #hipErrorInvalidValue (bad context, null *ptr)\n\n  @see hipMallocPitch, hipFree, hipMallocArray, hipFreeArray, hipMalloc3D, hipMalloc3DArray,\n hipHostFree, hipHostMalloc"]
    pub fn hipMalloc(ptr: *mut *mut ::libc::c_void, size: usize) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Allocate memory on the default accelerator\n\n  @param[out] ptr  Pointer to the allocated memory\n  @param[in]  sizeBytes  Requested memory size\n  @param[in]  flags  Type of memory allocation\n\n  If requested memory size is 0, no memory is allocated, *ptr returns nullptr, and #hipSuccess\n  is returned.\n\n  The memory allocation flag should be either #hipDeviceMallocDefault,\n  #hipDeviceMallocFinegrained, #hipDeviceMallocUncached, or #hipMallocSignalMemory.\n  If the flag is any other value, the API returns #hipErrorInvalidValue.\n\n  @returns #hipSuccess, #hipErrorOutOfMemory, #hipErrorInvalidValue (bad context, null *ptr)\n\n  @see hipMallocPitch, hipFree, hipMallocArray, hipFreeArray, hipMalloc3D, hipMalloc3DArray,\n hipHostFree, hiHostMalloc"]
    pub fn hipExtMallocWithFlags(
        ptr: *mut *mut ::libc::c_void,
        sizeBytes: usize,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Allocate pinned host memory [Deprecated]\n\n  @param[out] ptr Pointer to the allocated host pinned memory\n  @param[in]  size Requested memory size\n\n  If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned.\n\n  @returns #hipSuccess, #hipErrorOutOfMemory\n\n  @warning  This API is deprecated, use hipHostMalloc() instead"]
    pub fn hipMallocHost(ptr: *mut *mut ::libc::c_void, size: usize) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Allocate pinned host memory [Deprecated]\n\n  @param[out] ptr Pointer to the allocated host pinned memory\n  @param[in]  size Requested memory size\n\n  If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned.\n\n  @returns #hipSuccess, #hipErrorOutOfMemory\n\n  @warning  This API is deprecated, use hipHostMalloc() instead"]
    pub fn hipMemAllocHost(ptr: *mut *mut ::libc::c_void, size: usize) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Allocates device accessible page locked (pinned) host memory\n\n  This API allocates pinned host memory which is mapped into the address space of all GPUs\n  in the system, the memory can be accessed directly by the GPU device, and can be read or\n  written with much higher bandwidth than pageable memory obtained with functions such as\n  malloc().\n\n  Using the pinned host memory, applications can implement faster data transfers for HostToDevice\n  and DeviceToHost. The runtime tracks the hipHostMalloc allocations and can avoid some of the\n  setup required for regular unpinned memory.\n\n  When the memory accesses are infrequent, zero-copy memory can be a good choice, for coherent\n  allocation. GPU can directly access the host memory over the CPU/GPU interconnect, without need\n  to copy the data.\n\n  Currently the allocation granularity is 4KB for the API.\n\n  Developers need to choose proper allocation flag with consideration of synchronization.\n\n  @param[out] ptr Pointer to the allocated host pinned memory\n  @param[in]  size Requested memory size in bytes\n  If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned.\n  @param[in]  flags Type of host memory allocation. See the description of flags in\n  hipSetDeviceFlags.\n\n  If no input for flags, it will be the default pinned memory allocation on the host.\n\n  @returns #hipSuccess, #hipErrorOutOfMemory\n\n\n  @see hipSetDeviceFlags, hiptHostFree"]
    pub fn hipHostMalloc(
        ptr: *mut *mut ::libc::c_void,
        size: usize,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "-------------------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------------------\n  @defgroup MemoryM Managed Memory\n\n  @ingroup Memory\n @{\n  This section describes the managed memory management functions of HIP runtime API.\n\n  @note  The managed memory management APIs are implemented on Linux, under developement\n  on Windows.\n\n/\n/**\n @brief Allocates memory that will be automatically managed by HIP.\n\n This API is used for managed memory, allows data be shared and accessible to both CPU and\n GPU using a single pointer.\n\n The API returns the allocation pointer, managed by HMM, can be used further to execute kernels\n on device and fetch data between the host and device as needed.\n\n @note   It is recommend to do the capability check before call this API.\n\n @param [out] dev_ptr - pointer to allocated device memory\n @param [in]  size    - requested allocation size in bytes, it should be granularity of 4KB\n @param [in]  flags   - must be either hipMemAttachGlobal or hipMemAttachHost\n                        (defaults to hipMemAttachGlobal)\n\n @returns #hipSuccess, #hipErrorMemoryAllocation, #hipErrorNotSupported, #hipErrorInvalidValue\n"]
    pub fn hipMallocManaged(
        dev_ptr: *mut *mut ::libc::c_void,
        size: usize,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Prefetches memory to the specified destination device using HIP.\n\n @param [in] dev_ptr  pointer to be prefetched\n @param [in] count    size in bytes for prefetching\n @param [in] device   destination device to prefetch to\n @param [in] stream   stream to enqueue prefetch operation\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @note  This API is implemented on Linux and is under development on Microsoft Windows."]
    pub fn hipMemPrefetchAsync(
        dev_ptr: *const ::libc::c_void,
        count: usize,
        device: ::libc::c_int,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Advise about the usage of a given memory range to HIP.\n\n @param [in] dev_ptr  pointer to memory to set the advice for\n @param [in] count    size in bytes of the memory range, it should be CPU page size alligned.\n @param [in] advice   advice to be applied for the specified memory range\n @param [in] device   device to apply the advice for\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n This HIP API advises about the usage to be applied on unified memory allocation in the\n range starting from the pointer address devPtr, with the size of count bytes.\n The memory range must refer to managed memory allocated via the API hipMallocManaged, and the\n range will be handled with proper round down and round up respectively in the driver to\n be aligned to CPU page size, the same way as corresponding CUDA API behaves in CUDA version 8.0\n and afterwards.\n\n @note  This API is implemented on Linux and is under development on Microsoft Windows."]
    pub fn hipMemAdvise(
        dev_ptr: *const ::libc::c_void,
        count: usize,
        advice: hipMemoryAdvise,
        device: ::libc::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Query an attribute of a given memory range in HIP.\n\n @param [in,out] data   a pointer to a memory location where the result of each\n                        attribute query will be written to\n @param [in] data_size  the size of data\n @param [in] attribute  the attribute to query\n @param [in] dev_ptr    start of the range to query\n @param [in] count      size of the range to query\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @note  This API is implemented on Linux and is under development on Microsoft Windows."]
    pub fn hipMemRangeGetAttribute(
        data: *mut ::libc::c_void,
        data_size: usize,
        attribute: hipMemRangeAttribute,
        dev_ptr: *const ::libc::c_void,
        count: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Query attributes of a given memory range in HIP.\n\n @param [in,out] data     a two-dimensional array containing pointers to memory locations\n                          where the result of each attribute query will be written to\n @param [in] data_sizes   an array, containing the sizes of each result\n @param [in] attributes   the attribute to query\n @param [in] num_attributes  an array of attributes to query (numAttributes and the number\n                          of attributes in this array should match)\n @param [in] dev_ptr      start of the range to query\n @param [in] count        size of the range to query\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @note  This API is implemented on Linux and is under development on Microsoft Windows."]
    pub fn hipMemRangeGetAttributes(
        data: *mut *mut ::libc::c_void,
        data_sizes: *mut usize,
        attributes: *mut hipMemRangeAttribute,
        num_attributes: usize,
        dev_ptr: *const ::libc::c_void,
        count: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Attach memory to a stream asynchronously in HIP.\n\n @param [in] stream     - stream in which to enqueue the attach operation\n @param [in] dev_ptr    - pointer to memory (must be a pointer to managed memory or\n                          to a valid host-accessible region of system-allocated memory)\n @param [in] length     - length of memory (defaults to zero)\n @param [in] flags      - must be one of hipMemAttachGlobal, hipMemAttachHost or\n                          hipMemAttachSingle (defaults to hipMemAttachSingle)\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning This API is under development. Currently it is a no-operation (NOP)\n          function on AMD GPUs and returns #hipSuccess."]
    pub fn hipStreamAttachMemAsync(
        stream: hipStream_t,
        dev_ptr: *mut ::libc::c_void,
        length: usize,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Allocates memory with stream ordered semantics\n\n Inserts a memory allocation operation into @p stream.\n A pointer to the allocated memory is returned immediately in *dptr.\n The allocation must not be accessed until the allocation operation completes.\n The allocation comes from the memory pool associated with the stream's device.\n\n @note The default memory pool of a device contains device memory from that device.\n @note Basic stream ordering allows future work submitted into the same stream to use the\n  allocation. Stream query, stream synchronize, and HIP events can be used to guarantee that\n  the allocation operation completes before work submitted in a separate stream runs.\n @note During stream capture, this function results in the creation of an allocation node.\n  In this case, the allocation is owned by the graph instead of the memory pool. The memory\n  pool's properties are used to set the node's creation parameters.\n\n @param [out] dev_ptr  Returned device pointer of memory allocation\n @param [in] size      Number of bytes to allocate\n @param [in] stream    The stream establishing the stream ordering contract and\n                       the memory pool to allocate from\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported, #hipErrorOutOfMemory\n\n @see hipMallocFromPoolAsync, hipFreeAsync, hipMemPoolTrimTo, hipMemPoolGetAttribute,\n hipDeviceSetMemPool, hipMemPoolSetAttribute, hipMemPoolSetAccess, hipMemPoolGetAccess\n\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues.\n\n @note  This API is implemented on Linux and is under development on Microsoft Windows."]
    pub fn hipMallocAsync(
        dev_ptr: *mut *mut ::libc::c_void,
        size: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Frees memory with stream ordered semantics\n\n Inserts a free operation into @p stream.\n The allocation must not be used after stream execution reaches the free.\n After this API returns, accessing the memory from any subsequent work launched on the GPU\n or querying its pointer attributes results in undefined behavior.\n\n @note During stream capture, this function results in the creation of a free node and\n must therefore be passed the address of a graph allocation.\n\n @param [in] dev_ptr Pointer to device memory to free\n @param [in] stream  The stream, where the destruciton will occur according to the execution order\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @see hipMallocFromPoolAsync, hipMallocAsync, hipMemPoolTrimTo, hipMemPoolGetAttribute,\n hipDeviceSetMemPool, hipMemPoolSetAttribute, hipMemPoolSetAccess, hipMemPoolGetAccess\n\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues.\n\n @note  This API is implemented on Linux and is under development on Microsoft Windows."]
    pub fn hipFreeAsync(dev_ptr: *mut ::libc::c_void, stream: hipStream_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Releases freed memory back to the OS\n\n Releases memory back to the OS until the pool contains fewer than @p min_bytes_to_keep\n reserved bytes, or there is no more memory that the allocator can safely release.\n The allocator cannot release OS allocations that back outstanding asynchronous allocations.\n The OS allocations may happen at different granularity from the user allocations.\n\n @note Allocations that have not been freed count as outstanding.\n @note Allocations that have been asynchronously freed but whose completion has\n not been observed on the host (eg. by a synchronize) can count as outstanding.\n\n @param[in] mem_pool          The memory pool to trim allocations\n @param[in] min_bytes_to_hold If the pool has less than min_bytes_to_hold reserved,\n then the TrimTo operation is a no-op.  Otherwise the memory pool will contain\n at least min_bytes_to_hold bytes reserved after the operation.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @see hipMallocFromPoolAsync, hipMallocAsync, hipFreeAsync, hipMemPoolGetAttribute,\n hipDeviceSetMemPool, hipMemPoolSetAttribute, hipMemPoolSetAccess, hipMemPoolGetAccess\n\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues.\n\n @note  This API is implemented on Linux and is under development on Microsoft Windows."]
    pub fn hipMemPoolTrimTo(mem_pool: hipMemPool_t, min_bytes_to_hold: usize) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets attributes of a memory pool\n\n Supported attributes are:\n - @p hipMemPoolAttrReleaseThreshold: (value type = cuuint64_t)\n                                  Amount of reserved memory in bytes to hold onto before trying\n                                  to release memory back to the OS. When more than the release\n                                  threshold bytes of memory are held by the memory pool, the\n                                  allocator will try to release memory back to the OS on the\n                                  next call to stream, event or context synchronize. (default 0)\n - @p hipMemPoolReuseFollowEventDependencies: (value type = int)\n                                  Allow @p hipMallocAsync to use memory asynchronously freed\n                                  in another stream as long as a stream ordering dependency\n                                  of the allocating stream on the free action exists.\n                                  HIP events and null stream interactions can create the required\n                                  stream ordered dependencies. (default enabled)\n - @p hipMemPoolReuseAllowOpportunistic: (value type = int)\n                                  Allow reuse of already completed frees when there is no dependency\n                                  between the free and allocation. (default enabled)\n - @p hipMemPoolReuseAllowInternalDependencies: (value type = int)\n                                  Allow @p hipMallocAsync to insert new stream dependencies\n                                  in order to establish the stream ordering required to reuse\n                                  a piece of memory released by @p hipFreeAsync (default enabled).\n\n @param [in] mem_pool The memory pool to modify\n @param [in] attr     The attribute to modify\n @param [in] value    Pointer to the value to assign\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @see hipMallocFromPoolAsync, hipMallocAsync, hipFreeAsync, hipMemPoolGetAttribute,\n hipMemPoolTrimTo, hipDeviceSetMemPool, hipMemPoolSetAccess, hipMemPoolGetAccess\n\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues.\n\n @note  This API is implemented on Linux and is under development on Microsoft Windows."]
    pub fn hipMemPoolSetAttribute(
        mem_pool: hipMemPool_t,
        attr: hipMemPoolAttr,
        value: *mut ::libc::c_void,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets attributes of a memory pool\n\n Supported attributes are:\n - @p hipMemPoolAttrReleaseThreshold: (value type = cuuint64_t)\n                                  Amount of reserved memory in bytes to hold onto before trying\n                                  to release memory back to the OS. When more than the release\n                                  threshold bytes of memory are held by the memory pool, the\n                                  allocator will try to release memory back to the OS on the\n                                  next call to stream, event or context synchronize. (default 0)\n - @p hipMemPoolReuseFollowEventDependencies: (value type = int)\n                                  Allow @p hipMallocAsync to use memory asynchronously freed\n                                  in another stream as long as a stream ordering dependency\n                                  of the allocating stream on the free action exists.\n                                  HIP events and null stream interactions can create the required\n                                  stream ordered dependencies. (default enabled)\n - @p hipMemPoolReuseAllowOpportunistic: (value type = int)\n                                  Allow reuse of already completed frees when there is no dependency\n                                  between the free and allocation. (default enabled)\n - @p hipMemPoolReuseAllowInternalDependencies: (value type = int)\n                                  Allow @p hipMallocAsync to insert new stream dependencies\n                                  in order to establish the stream ordering required to reuse\n                                  a piece of memory released by @p hipFreeAsync (default enabled).\n\n @param [in] mem_pool The memory pool to get attributes of\n @param [in] attr     The attribute to get\n @param [in] value    Retrieved value\n\n @returns  #hipSuccess, #hipErrorInvalidValue\n\n @see hipMallocFromPoolAsync, hipMallocAsync, hipFreeAsync,\n hipMemPoolTrimTo, hipDeviceSetMemPool, hipMemPoolSetAttribute, hipMemPoolSetAccess, hipMemPoolGetAccess\n\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues.\n\n @note  This API is implemented on Linux and is under development on Microsoft Windows."]
    pub fn hipMemPoolGetAttribute(
        mem_pool: hipMemPool_t,
        attr: hipMemPoolAttr,
        value: *mut ::libc::c_void,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Controls visibility of the specified pool between devices\n\n @param [in] mem_pool   Memory pool for acccess change\n @param [in] desc_list  Array of access descriptors. Each descriptor instructs the access to enable for a single gpu\n @param [in] count  Number of descriptors in the map array.\n\n @returns  #hipSuccess, #hipErrorInvalidValue\n\n @see hipMallocFromPoolAsync, hipMallocAsync, hipFreeAsync, hipMemPoolGetAttribute,\n hipMemPoolTrimTo, hipDeviceSetMemPool, hipMemPoolSetAttribute, hipMemPoolGetAccess\n\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues.\n\n @note  This API is implemented on Linux and is under development on Microsoft Windows."]
    pub fn hipMemPoolSetAccess(
        mem_pool: hipMemPool_t,
        desc_list: *const hipMemAccessDesc,
        count: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns the accessibility of a pool from a device\n\n Returns the accessibility of the pool's memory from the specified location.\n\n @param [out] flags    Accessibility of the memory pool from the specified location/device\n @param [in] mem_pool   Memory pool being queried\n @param [in] location  Location/device for memory pool access\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @see hipMallocFromPoolAsync, hipMallocAsync, hipFreeAsync, hipMemPoolGetAttribute,\n hipMemPoolTrimTo, hipDeviceSetMemPool, hipMemPoolSetAttribute, hipMemPoolSetAccess\n\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues.\n\n @note  This API is implemented on Linux and is under development on Microsoft Windows."]
    pub fn hipMemPoolGetAccess(
        flags: *mut hipMemAccessFlags,
        mem_pool: hipMemPool_t,
        location: *mut hipMemLocation,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Creates a memory pool\n\n Creates a HIP memory pool and returns the handle in @p mem_pool. The @p pool_props determines\n the properties of the pool such as the backing device and IPC capabilities.\n\n By default, the memory pool will be accessible from the device it is allocated on.\n\n @param [out] mem_pool    Contains createed memory pool\n @param [in] pool_props   Memory pool properties\n\n @note Specifying hipMemHandleTypeNone creates a memory pool that will not support IPC.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @see hipMallocFromPoolAsync, hipMallocAsync, hipFreeAsync, hipMemPoolGetAttribute, hipMemPoolDestroy,\n hipMemPoolTrimTo, hipDeviceSetMemPool, hipMemPoolSetAttribute, hipMemPoolSetAccess, hipMemPoolGetAccess\n\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues.\n\n @note  This API is implemented on Linux and is under development on Microsoft Windows."]
    pub fn hipMemPoolCreate(
        mem_pool: *mut hipMemPool_t,
        pool_props: *const hipMemPoolProps,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Destroys the specified memory pool\n\n If any pointers obtained from this pool haven't been freed or\n the pool has free operations that haven't completed\n when @p hipMemPoolDestroy is invoked, the function will return immediately and the\n resources associated with the pool will be released automatically\n once there are no more outstanding allocations.\n\n Destroying the current mempool of a device sets the default mempool of\n that device as the current mempool for that device.\n\n @param [in] mem_pool Memory pool for destruction\n\n @note A device's default memory pool cannot be destroyed.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @see hipMallocFromPoolAsync, hipMallocAsync, hipFreeAsync, hipMemPoolGetAttribute, hipMemPoolCreate\n hipMemPoolTrimTo, hipDeviceSetMemPool, hipMemPoolSetAttribute, hipMemPoolSetAccess, hipMemPoolGetAccess\n\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues.\n\n @note  This API is implemented on Linux and is under development on Microsoft Windows."]
    pub fn hipMemPoolDestroy(mem_pool: hipMemPool_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Allocates memory from a specified pool with stream ordered semantics.\n\n Inserts an allocation operation into @p stream.\n A pointer to the allocated memory is returned immediately in @p dev_ptr.\n The allocation must not be accessed until the allocation operation completes.\n The allocation comes from the specified memory pool.\n\n @note The specified memory pool may be from a device different than that of the specified @p stream.\n\n Basic stream ordering allows future work submitted into the same stream to use the allocation.\n Stream query, stream synchronize, and HIP events can be used to guarantee that the allocation\n operation completes before work submitted in a separate stream runs.\n\n @note During stream capture, this function results in the creation of an allocation node. In this case,\n the allocation is owned by the graph instead of the memory pool. The memory pool's properties\n are used to set the node's creation parameters.\n\n @param [out] dev_ptr Returned device pointer\n @param [in] size     Number of bytes to allocate\n @param [in] mem_pool The pool to allocate from\n @param [in] stream   The stream establishing the stream ordering semantic\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported, #hipErrorOutOfMemory\n\n @see hipMallocAsync, hipFreeAsync, hipMemPoolGetAttribute, hipMemPoolCreate\n hipMemPoolTrimTo, hipDeviceSetMemPool, hipMemPoolSetAttribute, hipMemPoolSetAccess, hipMemPoolGetAccess,\n\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues.\n\n @note  This API is implemented on Linux and is under development on Microsoft Windows."]
    pub fn hipMallocFromPoolAsync(
        dev_ptr: *mut *mut ::libc::c_void,
        size: usize,
        mem_pool: hipMemPool_t,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Exports a memory pool to the requested handle type.\n\n Given an IPC capable mempool, create an OS handle to share the pool with another process.\n A recipient process can convert the shareable handle into a mempool with @p hipMemPoolImportFromShareableHandle.\n Individual pointers can then be shared with the @p hipMemPoolExportPointer and @p hipMemPoolImportPointer APIs.\n The implementation of what the shareable handle is and how it can be transferred is defined by the requested\n handle type.\n\n @note To create an IPC capable mempool, create a mempool with a @p hipMemAllocationHandleType other\n than @p hipMemHandleTypeNone.\n\n @param [out] shared_handle Pointer to the location in which to store the requested handle\n @param [in] mem_pool       Pool to export\n @param [in] handle_type    The type of handle to create\n @param [in] flags          Must be 0\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorOutOfMemory\n\n @see hipMemPoolImportFromShareableHandle\n\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues.\n\n @note  This API is implemented on Linux and is under development on Microsoft Windows."]
    pub fn hipMemPoolExportToShareableHandle(
        shared_handle: *mut ::libc::c_void,
        mem_pool: hipMemPool_t,
        handle_type: hipMemAllocationHandleType,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Imports a memory pool from a shared handle.\n\n Specific allocations can be imported from the imported pool with @p hipMemPoolImportPointer.\n\n @note Imported memory pools do not support creating new allocations.\n As such imported memory pools may not be used in @p hipDeviceSetMemPool\n or @p hipMallocFromPoolAsync calls.\n\n @param [out] mem_pool     Returned memory pool\n @param [in] shared_handle OS handle of the pool to open\n @param [in] handle_type   The type of handle being imported\n @param [in] flags         Must be 0\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorOutOfMemory\n\n @see hipMemPoolExportToShareableHandle\n\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues.\n\n @note  This API is implemented on Linux and is under development on Microsoft Windows."]
    pub fn hipMemPoolImportFromShareableHandle(
        mem_pool: *mut hipMemPool_t,
        shared_handle: *mut ::libc::c_void,
        handle_type: hipMemAllocationHandleType,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Export data to share a memory pool allocation between processes.\n\n Constructs @p export_data for sharing a specific allocation from an already shared memory pool.\n The recipient process can import the allocation with the @p hipMemPoolImportPointer api.\n The data is not a handle and may be shared through any IPC mechanism.\n\n @param[out] export_data  Returned export data\n @param[in] dev_ptr       Pointer to memory being exported\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorOutOfMemory\n\n @see hipMemPoolImportPointer\n\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues.\n\n @note  This API is implemented on Linux and is under development on Microsoft Windows."]
    pub fn hipMemPoolExportPointer(
        export_data: *mut hipMemPoolPtrExportData,
        dev_ptr: *mut ::libc::c_void,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Import a memory pool allocation from another process.\n\n Returns in @p dev_ptr a pointer to the imported memory.\n The imported memory must not be accessed before the allocation operation completes\n in the exporting process. The imported memory must be freed from all importing processes before\n being freed in the exporting process. The pointer may be freed with @p hipFree\n or @p hipFreeAsync. If @p hipFreeAsync is used, the free must be completed\n on the importing process before the free operation on the exporting process.\n\n @note The @p hipFreeAsync api may be used in the exporting process before\n the @p hipFreeAsync operation completes in its stream as long as the\n @p hipFreeAsync in the exporting process specifies a stream with\n a stream dependency on the importing process's @p hipFreeAsync.\n\n @param [out] dev_ptr     Pointer to imported memory\n @param [in] mem_pool     Memory pool from which to import a pointer\n @param [in] export_data  Data specifying the memory to import\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized, #hipErrorOutOfMemory\n\n @see hipMemPoolExportPointer\n\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues.\n\n @note  This API is implemented on Linux and is under development on Microsoft Windows."]
    pub fn hipMemPoolImportPointer(
        dev_ptr: *mut *mut ::libc::c_void,
        mem_pool: hipMemPool_t,
        export_data: *mut hipMemPoolPtrExportData,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Allocate device accessible page locked host memory\n\n  @param[out] ptr Pointer to the allocated host pinned memory\n  @param[in]  size Requested memory size in bytes\n  @param[in]  flags Type of host memory allocation see below\n\n  If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned.\n\n  Flags:\n  - #hipHostAllocDefault   Default pinned memory allocation on the host.\n  - #hipHostAllocPortable  Memory is considered allocated by all contexts.\n  - #hipHostAllocMapped    Map the allocation into the address space for the current device.\n  - #hipHostAllocWriteCombined  Allocates the memory as write-combined.\n\n  @return #hipSuccess, #hipErrorOutOfMemory, #hipErrorInvalidValue"]
    pub fn hipHostAlloc(
        ptr: *mut *mut ::libc::c_void,
        size: usize,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Get Device pointer from Host Pointer allocated through hipHostMalloc\n\n  @param[out] devPtr Device Pointer mapped to passed host pointer\n  @param[in]  hstPtr Host Pointer allocated through hipHostMalloc\n  @param[in]  flags Flags to be passed for extension\n\n  @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorOutOfMemory\n\n  @see hipSetDeviceFlags, hipHostMalloc"]
    pub fn hipHostGetDevicePointer(
        devPtr: *mut *mut ::libc::c_void,
        hstPtr: *mut ::libc::c_void,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Return flags associated with host pointer\n\n  @param[out] flagsPtr Memory location to store flags\n  @param[in]  hostPtr Host Pointer allocated through hipHostMalloc\n  @returns #hipSuccess, #hipErrorInvalidValue\n\n  @see hipHostMalloc"]
    pub fn hipHostGetFlags(
        flagsPtr: *mut ::libc::c_uint,
        hostPtr: *mut ::libc::c_void,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Register host memory so it can be accessed from the current device.\n\n  @param[out] hostPtr Pointer to host memory to be registered.\n  @param[in] sizeBytes Size of the host memory\n  @param[in] flags  See below.\n\n  Flags:\n  - #hipHostRegisterDefault   Memory is Mapped and Portable\n  - #hipHostRegisterPortable  Memory is considered registered by all contexts.  HIP only supports\n one context so this is always assumed true.\n  - #hipHostRegisterMapped    Map the allocation into the address space for the current device.\n The device pointer can be obtained with #hipHostGetDevicePointer.\n\n\n  After registering the memory, use #hipHostGetDevicePointer to obtain the mapped device pointer.\n  On many systems, the mapped device pointer will have a different value than the mapped host\n pointer.  Applications must use the device pointer in device code, and the host pointer in host\n code.\n\n  On some systems, registered memory is pinned.  On some systems, registered memory may not be\n actually be pinned but uses OS or hardware facilities to all GPU access to the host memory.\n\n  Developers are strongly encouraged to register memory blocks which are aligned to the host\n cache-line size. (typically 64-bytes but can be obtains from the CPUID instruction).\n\n  If registering non-aligned pointers, the application must take care when register pointers from\n the same cache line on different devices.  HIP's coarse-grained synchronization model does not\n guarantee correct results if different devices write to different parts of the same cache block -\n typically one of the writes will \"win\" and overwrite data from the other registered memory\n region.\n\n  @returns #hipSuccess, #hipErrorOutOfMemory\n\n  @see hipHostUnregister, hipHostGetFlags, hipHostGetDevicePointer"]
    pub fn hipHostRegister(
        hostPtr: *mut ::libc::c_void,
        sizeBytes: usize,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Un-register host pointer\n\n  @param[in] hostPtr Host pointer previously registered with #hipHostRegister\n  @returns Error code\n\n  @see hipHostRegister"]
    pub fn hipHostUnregister(hostPtr: *mut ::libc::c_void) -> hipError_t;
}
extern "C" {
    #[doc = "  Allocates at least width (in bytes) * height bytes of linear memory\n  Padding may occur to ensure alighnment requirements are met for the given row\n  The change in width size due to padding will be returned in *pitch.\n  Currently the alignment is set to 128 bytes\n\n  @param[out] ptr Pointer to the allocated device memory\n  @param[out] pitch Pitch for allocation (in bytes)\n  @param[in]  width Requested pitched allocation width (in bytes)\n  @param[in]  height Requested pitched allocation height\n\n  If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned.\n\n  @returns Error code\n\n  @see hipMalloc, hipFree, hipMallocArray, hipFreeArray, hipHostFree, hipMalloc3D,\n hipMalloc3DArray, hipHostMalloc"]
    pub fn hipMallocPitch(
        ptr: *mut *mut ::libc::c_void,
        pitch: *mut usize,
        width: usize,
        height: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  Allocates at least width (in bytes) * height bytes of linear memory\n  Padding may occur to ensure alighnment requirements are met for the given row\n  The change in width size due to padding will be returned in *pitch.\n  Currently the alignment is set to 128 bytes\n\n  @param[out] dptr  Pointer to the allocated device memory\n  @param[out] pitch  Pitch for allocation (in bytes)\n  @param[in]  widthInBytes  Requested pitched allocation width (in bytes)\n  @param[in]  height  Requested pitched allocation height\n  @param[in]  elementSizeBytes  The size of element bytes, should be 4, 8 or 16\n\n  If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned.\n  The intended usage of pitch is as a separate parameter of the allocation, used to compute addresses within the 2D array.\n  Given the row and column of an array element of type T, the address is computed as:\n  T* pElement = (T*)((char*)BaseAddress + Row * Pitch) + Column;\n\n  @returns Error code\n\n  @see hipMalloc, hipFree, hipMallocArray, hipFreeArray, hipHostFree, hipMalloc3D,\n hipMalloc3DArray, hipHostMalloc"]
    pub fn hipMemAllocPitch(
        dptr: *mut hipDeviceptr_t,
        pitch: *mut usize,
        widthInBytes: usize,
        height: usize,
        elementSizeBytes: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Free memory allocated by the hcc hip memory allocation API.\n  This API performs an implicit hipDeviceSynchronize() call.\n  If pointer is NULL, the hip runtime is initialized and hipSuccess is returned.\n\n  @param[in] ptr Pointer to memory to be freed\n  @returns #hipSuccess\n  @returns #hipErrorInvalidDevicePointer (if pointer is invalid, including host pointers allocated\n with hipHostMalloc)\n\n  @see hipMalloc, hipMallocPitch, hipMallocArray, hipFreeArray, hipHostFree, hipMalloc3D,\n hipMalloc3DArray, hipHostMalloc"]
    pub fn hipFree(ptr: *mut ::libc::c_void) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Frees page-locked memory\n  This API performs an implicit hipDeviceSynchronize() call.\n  If pointer is NULL, the hip runtime is initialized and hipSuccess is returned.\n\n  @param[in] ptr Pointer to memory to be freed\n  @returns #hipSuccess,\n          #hipErrorInvalidValue (if pointer is invalid, including device pointers allocated\n  with hipMalloc)\n"]
    pub fn hipFreeHost(ptr: *mut ::libc::c_void) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Free memory allocated by the hcc hip host memory allocation API\n  This API performs an implicit hipDeviceSynchronize() call.\n  If pointer is NULL, the hip runtime is initialized and hipSuccess is returned.\n\n  @ingroup MemoryD\n\n  @param[in] ptr Pointer to memory to be freed\n  @returns #hipSuccess,\n          #hipErrorInvalidValue (if pointer is invalid, including device pointers allocated with\n hipMalloc)\n\n  @see hipMalloc, hipMallocPitch, hipFree, hipMallocArray, hipFreeArray, hipMalloc3D,\n hipMalloc3DArray, hipHostMalloc\n"]
    pub fn hipHostFree(ptr: *mut ::libc::c_void) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copy data from src to dst.\n\n  It supports memory from host to device,\n  device to host, device to device and host to host\n  The src and dst must not overlap.\n\n  For hipMemcpy, the copy is always performed by the current device (set by hipSetDevice).\n  For multi-gpu or peer-to-peer configurations, it is recommended to set the current device to the\n  device where the src data is physically located. For optimal peer-to-peer copies, the copy device\n  must be able to access the src and dst pointers (by calling hipDeviceEnablePeerAccess with copy\n  agent as the current device and src/dest as the peerDevice argument.  if this is not done, the\n  hipMemcpy will still work, but will perform the copy using a staging buffer on the host.\n  Calling hipMemcpy with dst and src pointers that do not match the hipMemcpyKind results in\n  undefined behavior.\n\n  @param[out]  dst Data being copy to\n  @param[in]  src Data being copy from\n  @param[in]  sizeBytes Data size in bytes\n  @param[in]  kind Kind of transfer\n  @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorUnknown\n\n  @see hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,\n hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,\n hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,\n hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,\n hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,\n hipMemHostAlloc, hipMemHostGetDevicePointer"]
    pub fn hipMemcpy(
        dst: *mut ::libc::c_void,
        src: *const ::libc::c_void,
        sizeBytes: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Memory copy on the stream.\n  It allows single or multiple devices to do memory copy on single or multiple streams.\n\n  @param[out]  dst Data being copy to\n  @param[in]  src Data being copy from\n  @param[in]  sizeBytes Data size in bytes\n  @param[in]  kind Kind of transfer\n  @param[in]  stream Valid stream\n  @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorUnknown, #hipErrorContextIsDestroyed\n\n  @see hipMemcpy, hipStreamCreate, hipStreamSynchronize, hipStreamDestroy, hipSetDevice, hipLaunchKernelGGL\n"]
    pub fn hipMemcpyWithStream(
        dst: *mut ::libc::c_void,
        src: *const ::libc::c_void,
        sizeBytes: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copy data from Host to Device\n\n  @param[out]  dst Data being copy to\n  @param[in]   src Data being copy from\n  @param[in]   sizeBytes Data size in bytes\n\n  @returns #hipSuccess, #hipErrorDeinitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,\n #hipErrorInvalidValue\n\n  @see hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,\n hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,\n hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,\n hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,\n hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,\n hipMemHostAlloc, hipMemHostGetDevicePointer"]
    pub fn hipMemcpyHtoD(
        dst: hipDeviceptr_t,
        src: *mut ::libc::c_void,
        sizeBytes: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copy data from Device to Host\n\n  @param[out]  dst Data being copy to\n  @param[in]   src Data being copy from\n  @param[in]   sizeBytes Data size in bytes\n\n  @returns #hipSuccess, #hipErrorDeinitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,\n #hipErrorInvalidValue\n\n  @see hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,\n hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,\n hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,\n hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,\n hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,\n hipMemHostAlloc, hipMemHostGetDevicePointer"]
    pub fn hipMemcpyDtoH(
        dst: *mut ::libc::c_void,
        src: hipDeviceptr_t,
        sizeBytes: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copy data from Device to Device\n\n  @param[out]  dst Data being copy to\n  @param[in]   src Data being copy from\n  @param[in]   sizeBytes Data size in bytes\n\n  @returns #hipSuccess, #hipErrorDeinitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,\n #hipErrorInvalidValue\n\n  @see hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,\n hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,\n hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,\n hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,\n hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,\n hipMemHostAlloc, hipMemHostGetDevicePointer"]
    pub fn hipMemcpyDtoD(dst: hipDeviceptr_t, src: hipDeviceptr_t, sizeBytes: usize) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies from one 1D array to device memory.\n\n  @param[out]  dstDevice Destination device pointer\n  @param[in]   srcArray Source array\n  @param[in]   srcOffset Offset in bytes of source array\n  @param[in]   ByteCount Size of memory copy in bytes\n\n  @returns #hipSuccess, #hipErrorDeinitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,\n #hipErrorInvalidValue\n\n  @see hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,\n hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,\n hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,\n hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,\n hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,\n hipMemHostAlloc, hipMemHostGetDevicePointer"]
    pub fn hipMemcpyAtoD(
        dstDevice: hipDeviceptr_t,
        srcArray: hipArray_t,
        srcOffset: usize,
        ByteCount: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies from device memory to a 1D array.\n\n  @param[out]  dstArray Destination array\n  @param[in]   dstOffset Offset in bytes of destination array\n  @param[in]   srcDevice Source device pointer\n  @param[in]   ByteCount Size of memory copy in bytes\n\n  @returns #hipSuccess, #hipErrorDeinitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,\n #hipErrorInvalidValue\n\n  @see hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,\n hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,\n hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,\n hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,\n hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,\n hipMemHostAlloc, hipMemHostGetDevicePointer"]
    pub fn hipMemcpyDtoA(
        dstArray: hipArray_t,
        dstOffset: usize,
        srcDevice: hipDeviceptr_t,
        ByteCount: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies from one 1D array to another.\n\n  @param[out]  dstArray Destination array\n  @param[in]   dstOffset Offset in bytes of destination array\n  @param[in]   srcArray Source array\n  @param[in]   srcOffset Offset in bytes of source array\n  @param[in]   ByteCount Size of memory copy in bytes\n\n  @returns #hipSuccess, #hipErrorDeinitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,\n #hipErrorInvalidValue\n\n  @see hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,\n hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,\n hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,\n hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,\n hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,\n hipMemHostAlloc, hipMemHostGetDevicePointer"]
    pub fn hipMemcpyAtoA(
        dstArray: hipArray_t,
        dstOffset: usize,
        srcArray: hipArray_t,
        srcOffset: usize,
        ByteCount: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copy data from Host to Device asynchronously\n\n  @param[out]  dst  Data being copy to\n  @param[in]   src  Data being copy from\n  @param[in]   sizeBytes  Data size in bytes\n  @param[in]   stream  Stream identifier\n\n  @returns #hipSuccess, #hipErrorDeinitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,\n #hipErrorInvalidValue\n\n  @see hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,\n hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,\n hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,\n hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,\n hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,\n hipMemHostAlloc, hipMemHostGetDevicePointer"]
    pub fn hipMemcpyHtoDAsync(
        dst: hipDeviceptr_t,
        src: *mut ::libc::c_void,
        sizeBytes: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copy data from Device to Host asynchronously\n\n  @param[out]  dst Data being copy to\n  @param[in]   src Data being copy from\n  @param[in]   sizeBytes Data size in bytes\n  @param[in]   stream  Stream identifier\n\n  @returns #hipSuccess, #hipErrorDeinitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,\n #hipErrorInvalidValue\n\n  @see hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,\n hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,\n hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,\n hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,\n hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,\n hipMemHostAlloc, hipMemHostGetDevicePointer"]
    pub fn hipMemcpyDtoHAsync(
        dst: *mut ::libc::c_void,
        src: hipDeviceptr_t,
        sizeBytes: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copy data from Device to Device asynchronously\n\n  @param[out]  dst  Data being copy to\n  @param[in]   src  Data being copy from\n  @param[in]   sizeBytes  Data size in bytes\n  @param[in]   stream  Stream identifier\n\n  @returns #hipSuccess, #hipErrorDeinitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,\n #hipErrorInvalidValue\n\n  @see hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,\n hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,\n hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,\n hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,\n hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,\n hipMemHostAlloc, hipMemHostGetDevicePointer"]
    pub fn hipMemcpyDtoDAsync(
        dst: hipDeviceptr_t,
        src: hipDeviceptr_t,
        sizeBytes: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Copies from one 1D array to host memory.\n\n  @param[out]  dstHost Destination pointer\n  @param[in]   srcArray Source array\n  @param[in]   srcOffset Offset in bytes of source array\n  @param[in]   ByteCount Size of memory copy in bytes\n  @param[in]   stream Stream identifier\n\n  @returns #hipSuccess, #hipErrorDeinitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,\n #hipErrorInvalidValue\n\n  @see hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,\n hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,\n hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,\n hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,\n hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,\n hipMemHostAlloc, hipMemHostGetDevicePointer"]
    pub fn hipMemcpyAtoHAsync(
        dstHost: *mut ::libc::c_void,
        srcArray: hipArray_t,
        srcOffset: usize,
        ByteCount: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Copies from host memory to a 1D array.\n\n  @param[out]  dstArray Destination array\n  @param[in]   dstOffset Offset in bytes of destination array\n  @param[in]   srcHost Source host pointer\n  @param[in]   ByteCount Size of memory copy in bytes\n  @param[in]   stream Stream identifier\n\n  @returns #hipSuccess, #hipErrorDeinitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,\n #hipErrorInvalidValue\n\n  @see hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,\n hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,\n hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,\n hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,\n hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,\n hipMemHostAlloc, hipMemHostGetDevicePointer"]
    pub fn hipMemcpyHtoAAsync(
        dstArray: hipArray_t,
        dstOffset: usize,
        srcHost: *const ::libc::c_void,
        ByteCount: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Returns a global pointer from a module.\n  @ingroup Module\n\n  Returns in *dptr and *bytes the pointer and size of the global of name name located in module hmod.\n  If no variable of that name exists, it returns hipErrorNotFound. Both parameters dptr and bytes are optional.\n  If one of them is NULL, it is ignored and hipSuccess is returned.\n\n  @param[out]  dptr  Returns global device pointer\n  @param[out]  bytes Returns global size in bytes\n  @param[in]   hmod  Module to retrieve global from\n  @param[in]   name  Name of global to retrieve\n\n  @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotFound, #hipErrorInvalidContext\n"]
    pub fn hipModuleGetGlobal(
        dptr: *mut hipDeviceptr_t,
        bytes: *mut usize,
        hmod: hipModule_t,
        name: *const ::libc::c_char,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Gets device pointer associated with symbol on the device.\n\n  @param[out]  devPtr  pointer to the device associated the symbole\n  @param[in]   symbol  pointer to the symbole of the device\n\n  @returns #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipGetSymbolAddress(
        devPtr: *mut *mut ::libc::c_void,
        symbol: *const ::libc::c_void,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Gets the size of the given symbol on the device.\n\n  @param[in]   symbol  pointer to the device symbole\n  @param[out]  size  pointer to the size\n\n  @returns #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipGetSymbolSize(size: *mut usize, symbol: *const ::libc::c_void) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets the pointer of requested HIP driver function.\n\n @param[in] symbol  The Symbol name of the driver function to request.\n @param[out] pfn  Output pointer to the requested driver function.\n @param[in] hipVersion  The HIP version for the requested driver function symbol.\n HIP version is defined as 100*version_major + version_minor. For example, in HIP 6.1, the\n hipversion is 601, for the symbol function \"hipGetDeviceProperties\", the specified hipVersion 601\n is greater or equal to the version 600, the symbol function will be handle properly as backend\n compatible function.\n\n @param[in] flags  Currently only default flag is suppported.\n @param[out] symbolStatus  Optional enumeration for returned status of searching for symbol driver\n function based on the input hipVersion.\n\n Returns hipSuccess if the returned pfn is addressed to the pointer of found driver function.\n\n @returns #hipSuccess, #hipErrorInvalidValue."]
    pub fn hipGetProcAddress(
        symbol: *const ::libc::c_char,
        pfn: *mut *mut ::libc::c_void,
        hipVersion: ::libc::c_int,
        flags: u64,
        symbolStatus: *mut hipDriverProcAddressQueryResult,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data to the given symbol on the device.\n Symbol HIP APIs allow a kernel to define a device-side data symbol which can be accessed on\n the host side. The symbol can be in __constant or device space.\n Note that the symbol name needs to be encased in the HIP_SYMBOL macro.\n This also applies to hipMemcpyFromSymbol, hipGetSymbolAddress, and hipGetSymbolSize.\n For detailed usage, see the\n <a href=\"https://rocm.docs.amd.com/projects/HIP/en/latest/how-to/hip_porting_guide.html#memcpytosymbol\">memcpyToSymbol example</a>\n in the HIP Porting Guide.\n\n\n  @param[out]  symbol  pointer to the device symbole\n  @param[in]   src  pointer to the source address\n  @param[in]   sizeBytes  size in bytes to copy\n  @param[in]   offset  offset in bytes from start of symbole\n  @param[in]   kind  type of memory transfer\n\n  @returns #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipMemcpyToSymbol(
        symbol: *const ::libc::c_void,
        src: *const ::libc::c_void,
        sizeBytes: usize,
        offset: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data to the given symbol on the device asynchronously.\n\n  @param[out]  symbol  pointer to the device symbole\n  @param[in]   src  pointer to the source address\n  @param[in]   sizeBytes  size in bytes to copy\n  @param[in]   offset  offset in bytes from start of symbole\n  @param[in]   kind  type of memory transfer\n  @param[in]   stream  stream identifier\n\n  @returns #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipMemcpyToSymbolAsync(
        symbol: *const ::libc::c_void,
        src: *const ::libc::c_void,
        sizeBytes: usize,
        offset: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data from the given symbol on the device.\n\n  @param[out]  dst  Returns pointer to destinition memory address\n  @param[in]   symbol  Pointer to the symbole address on the device\n  @param[in]   sizeBytes  Size in bytes to copy\n  @param[in]   offset  Offset in bytes from the start of symbole\n  @param[in]   kind  Type of memory transfer\n\n  @returns #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipMemcpyFromSymbol(
        dst: *mut ::libc::c_void,
        symbol: *const ::libc::c_void,
        sizeBytes: usize,
        offset: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data from the given symbol on the device asynchronously.\n\n  @param[out]  dst  Returns pointer to destinition memory address\n  @param[in]   symbol  pointer to the symbole address on the device\n  @param[in]   sizeBytes  size in bytes to copy\n  @param[in]   offset  offset in bytes from the start of symbole\n  @param[in]   kind  type of memory transfer\n  @param[in]   stream  stream identifier\n\n  @returns #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipMemcpyFromSymbolAsync(
        dst: *mut ::libc::c_void,
        symbol: *const ::libc::c_void,
        sizeBytes: usize,
        offset: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copy data from src to dst asynchronously.\n\n  @warning If host or dest are not pinned, the memory copy will be performed synchronously.  For\n best performance, use hipHostMalloc to allocate host memory that is transferred asynchronously.\n\n  @warning on HCC hipMemcpyAsync does not support overlapped H2D and D2H copies.\n  For hipMemcpy, the copy is always performed by the device associated with the specified stream.\n\n  For multi-gpu or peer-to-peer configurations, it is recommended to use a stream which is a\n attached to the device where the src data is physically located. For optimal peer-to-peer copies,\n the copy device must be able to access the src and dst pointers (by calling\n hipDeviceEnablePeerAccess with copy agent as the current device and src/dest as the peerDevice\n argument.  if this is not done, the hipMemcpy will still work, but will perform the copy using a\n staging buffer on the host.\n\n  @param[out] dst Data being copy to\n  @param[in]  src Data being copy from\n  @param[in]  sizeBytes Data size in bytes\n  @param[in]  kind  Type of memory transfer\n  @param[in]  stream  Stream identifier\n  @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorUnknown\n\n  @see hipMemcpy, hipMemcpy2D, hipMemcpyToArray, hipMemcpy2DToArray, hipMemcpyFromArray,\n hipMemcpy2DFromArray, hipMemcpyArrayToArray, hipMemcpy2DArrayToArray, hipMemcpyToSymbol,\n hipMemcpyFromSymbol, hipMemcpy2DAsync, hipMemcpyToArrayAsync, hipMemcpy2DToArrayAsync,\n hipMemcpyFromArrayAsync, hipMemcpy2DFromArrayAsync, hipMemcpyToSymbolAsync,\n hipMemcpyFromSymbolAsync"]
    pub fn hipMemcpyAsync(
        dst: *mut ::libc::c_void,
        src: *const ::libc::c_void,
        sizeBytes: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Fills the first sizeBytes bytes of the memory area pointed to by dest with the constant\n byte value value.\n\n  @param[out] dst  Data being filled\n  @param[in]  value  Value to be set\n  @param[in]  sizeBytes  Data size in bytes\n  @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized"]
    pub fn hipMemset(
        dst: *mut ::libc::c_void,
        value: ::libc::c_int,
        sizeBytes: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Fills the first sizeBytes bytes of the memory area pointed to by dest with the constant\n byte value value.\n\n  @param[out] dest  Data ptr to be filled\n  @param[in]  value  Value to be set\n  @param[in]  count  Number of values to be set\n  @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized"]
    pub fn hipMemsetD8(dest: hipDeviceptr_t, value: ::libc::c_uchar, count: usize) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Fills the first sizeBytes bytes of the memory area pointed to by dest with the constant\n byte value value.\n\n hipMemsetD8Async() is asynchronous with respect to the host, so the call may return before the\n memset is complete. The operation can optionally be associated to a stream by passing a non-zero\n stream argument. If stream is non-zero, the operation may overlap with operations in other\n streams.\n\n  @param[out] dest  Data ptr to be filled\n  @param[in]  value  Constant value to be set\n  @param[in]  count  Number of values to be set\n  @param[in]  stream  Stream identifier\n  @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized"]
    pub fn hipMemsetD8Async(
        dest: hipDeviceptr_t,
        value: ::libc::c_uchar,
        count: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Fills the first sizeBytes bytes of the memory area pointed to by dest with the constant\n short value value.\n\n  @param[out] dest  Data ptr to be filled\n  @param[in]  value  Constant value to be set\n  @param[in]  count  Number of values to be set\n  @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized"]
    pub fn hipMemsetD16(dest: hipDeviceptr_t, value: ::libc::c_ushort, count: usize) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Fills the first sizeBytes bytes of the memory area pointed to by dest with the constant\n short value value.\n\n hipMemsetD16Async() is asynchronous with respect to the host, so the call may return before the\n memset is complete. The operation can optionally be associated to a stream by passing a non-zero\n stream argument. If stream is non-zero, the operation may overlap with operations in other\n streams.\n\n  @param[out] dest  Data ptr to be filled\n  @param[in]  value  Constant value to be set\n  @param[in]  count  Number of values to be set\n  @param[in]  stream  Stream identifier\n  @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized"]
    pub fn hipMemsetD16Async(
        dest: hipDeviceptr_t,
        value: ::libc::c_ushort,
        count: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Fills the memory area pointed to by dest with the constant integer\n value for specified number of times.\n\n  @param[out] dest  Data being filled\n  @param[in]  value  Constant value to be set\n  @param[in]  count  Number of values to be set\n  @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized"]
    pub fn hipMemsetD32(dest: hipDeviceptr_t, value: ::libc::c_int, count: usize) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Fills the first sizeBytes bytes of the memory area pointed to by dev with the constant\n byte value value.\n\n hipMemsetAsync() is asynchronous with respect to the host, so the call may return before the\n memset is complete. The operation can optionally be associated to a stream by passing a non-zero\n stream argument. If stream is non-zero, the operation may overlap with operations in other\n streams.\n\n  @param[out] dst Pointer to device memory\n  @param[in]  value  Value to set for each byte of specified memory\n  @param[in]  sizeBytes  Size in bytes to set\n  @param[in]  stream  Stream identifier\n  @return #hipSuccess, #hipErrorInvalidValue"]
    pub fn hipMemsetAsync(
        dst: *mut ::libc::c_void,
        value: ::libc::c_int,
        sizeBytes: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Fills the memory area pointed to by dev with the constant integer\n value for specified number of times.\n\n  hipMemsetD32Async() is asynchronous with respect to the host, so the call may return before the\n memset is complete. The operation can optionally be associated to a stream by passing a non-zero\n stream argument. If stream is non-zero, the operation may overlap with operations in other\n streams.\n\n  @param[out] dst Pointer to device memory\n  @param[in]  value  Value to set for each byte of specified memory\n  @param[in]  count  Number of values to be set\n  @param[in]  stream  Stream identifier\n  @return #hipSuccess, #hipErrorInvalidValue"]
    pub fn hipMemsetD32Async(
        dst: hipDeviceptr_t,
        value: ::libc::c_int,
        count: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Fills the memory area pointed to by dst with the constant value.\n\n  @param[out] dst Pointer to device memory\n  @param[in]  pitch  Data size in bytes\n  @param[in]  value  Constant value to be set\n  @param[in]  width\n  @param[in]  height\n  @returns #hipSuccess, #hipErrorInvalidValue"]
    pub fn hipMemset2D(
        dst: *mut ::libc::c_void,
        pitch: usize,
        value: ::libc::c_int,
        width: usize,
        height: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Fills asynchronously the memory area pointed to by dst with the constant value.\n\n  @param[in]  dst Pointer to 2D device memory\n  @param[in]  pitch  Pitch size in bytes\n  @param[in]  value  Value to be set for each byte of specified memory\n  @param[in]  width  Width of matrix set columns in bytes\n  @param[in]  height  Height of matrix set rows in bytes\n  @param[in]  stream  Stream identifier\n  @returns #hipSuccess, #hipErrorInvalidValue"]
    pub fn hipMemset2DAsync(
        dst: *mut ::libc::c_void,
        pitch: usize,
        value: ::libc::c_int,
        width: usize,
        height: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Fills synchronously the memory area pointed to by pitchedDevPtr with the constant value.\n\n  @param[in] pitchedDevPtr  Pointer to pitched device memory\n  @param[in]  value  Value to set for each byte of specified memory\n  @param[in]  extent  Size parameters for width field in bytes in device memory\n  @returns #hipSuccess, #hipErrorInvalidValue"]
    pub fn hipMemset3D(
        pitchedDevPtr: hipPitchedPtr,
        value: ::libc::c_int,
        extent: hipExtent,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Fills asynchronously the memory area pointed to by pitchedDevPtr with the constant value.\n\n  @param[in] pitchedDevPtr  Pointer to pitched device memory\n  @param[in]  value  Value to set for each byte of specified memory\n  @param[in]  extent  Size parameters for width field in bytes in device memory\n  @param[in]  stream  Stream identifier\n  @returns #hipSuccess, #hipErrorInvalidValue"]
    pub fn hipMemset3DAsync(
        pitchedDevPtr: hipPitchedPtr,
        value: ::libc::c_int,
        extent: hipExtent,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Query memory info.\n\n On ROCM, this function gets the actual free memory left on the current device, so supports\n the cases while running multi-workload (such as multiple processes, multiple threads, and\n multiple GPUs).\n\n @warning On Windows, the free memory only accounts for memory allocated by this process and may\n be optimistic.\n\n @param[out] free Returns free memory on the current device in bytes\n @param[out] total Returns total allocatable memory on the current device in bytes\n\n @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue\n"]
    pub fn hipMemGetInfo(free: *mut usize, total: *mut usize) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Get allocated memory size via memory pointer.\n\n This function gets the allocated shared virtual memory size from memory pointer.\n\n @param[in] ptr Pointer to allocated memory\n @param[out] size Returns the allocated memory size in bytes\n\n @returns #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipMemPtrGetInfo(ptr: *mut ::libc::c_void, size: *mut usize) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Allocate an array on the device.\n\n  @param[out]  array  Pointer to allocated array in device memory\n  @param[in]   desc   Requested channel format\n  @param[in]   width  Requested array allocation width\n  @param[in]   height Requested array allocation height\n  @param[in]   flags  Requested properties of allocated array\n  @returns     #hipSuccess, #hipErrorOutOfMemory\n\n  @see hipMalloc, hipMallocPitch, hipFree, hipFreeArray, hipHostMalloc, hipHostFree"]
    pub fn hipMallocArray(
        array: *mut hipArray_t,
        desc: *const hipChannelFormatDesc,
        width: usize,
        height: usize,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Create an array memory pointer on the device.\n\n  @param[out]  pHandle  Pointer to the array memory\n  @param[in]   pAllocateArray   Requested array desciptor\n\n  @returns     #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n  @see hipMallocArray, hipArrayDestroy, hipFreeArray"]
    pub fn hipArrayCreate(
        pHandle: *mut hipArray_t,
        pAllocateArray: *const HIP_ARRAY_DESCRIPTOR,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Destroy an array memory pointer on the device.\n\n  @param[in]  array  Pointer to the array memory\n\n  @returns     #hipSuccess, #hipErrorInvalidValue\n\n  @see hipArrayCreate, hipArrayDestroy, hipFreeArray"]
    pub fn hipArrayDestroy(array: hipArray_t) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Create a 3D array memory pointer on the device.\n\n  @param[out]  array  Pointer to the 3D array memory\n  @param[in]   pAllocateArray   Requested array desciptor\n\n  @returns     #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n  @see hipMallocArray, hipArrayDestroy, hipFreeArray"]
    pub fn hipArray3DCreate(
        array: *mut hipArray_t,
        pAllocateArray: *const HIP_ARRAY3D_DESCRIPTOR,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Create a 3D memory pointer on the device.\n\n  @param[out]  pitchedDevPtr  Pointer to the 3D memory\n  @param[in]   extent   Requested extent\n\n  @returns     #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n  @see hipMallocPitch, hipMemGetInfo, hipFree"]
    pub fn hipMalloc3D(pitchedDevPtr: *mut hipPitchedPtr, extent: hipExtent) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Frees an array on the device.\n\n  @param[in]  array  Pointer to array to free\n  @returns    #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized\n\n  @see hipMalloc, hipMallocPitch, hipFree, hipMallocArray, hipHostMalloc, hipHostFree"]
    pub fn hipFreeArray(array: hipArray_t) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Allocate an array on the device.\n\n  @param[out]  array  Pointer to allocated array in device memory\n  @param[in]   desc   Requested channel format\n  @param[in]   extent Requested array allocation width, height and depth\n  @param[in]   flags  Requested properties of allocated array\n  @returns     #hipSuccess, #hipErrorOutOfMemory\n\n  @see hipMalloc, hipMallocPitch, hipFree, hipFreeArray, hipHostMalloc, hipHostFree"]
    pub fn hipMalloc3DArray(
        array: *mut hipArray_t,
        desc: *const hipChannelFormatDesc,
        extent: hipExtent,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets info about the specified array\n\n @param[out] desc   - Returned array type\n @param[out] extent - Returned array shape. 2D arrays will have depth of zero\n @param[out] flags  - Returned array flags\n @param[in]  array  - The HIP array to get info for\n\n @returns #hipSuccess, #hipErrorInvalidValue #hipErrorInvalidHandle\n\n @see hipArrayGetDescriptor, hipArray3DGetDescriptor"]
    pub fn hipArrayGetInfo(
        desc: *mut hipChannelFormatDesc,
        extent: *mut hipExtent,
        flags: *mut ::libc::c_uint,
        array: hipArray_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets a 1D or 2D array descriptor\n\n @param[out] pArrayDescriptor - Returned array descriptor\n @param[in]  array            - Array to get descriptor of\n\n @returns #hipSuccess, #hipErrorDeinitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,\n #hipErrorInvalidValue #hipErrorInvalidHandle\n\n @see hipArray3DCreate, hipArray3DGetDescriptor, hipArrayCreate, hipArrayDestroy, hipMemAlloc,\n hipMemAllocHost, hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned,\n hipMemcpy3D, hipMemcpy3DAsync, hipMemcpyAtoA, hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync,\n hipMemcpyDtoA, hipMemcpyDtoD, hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync,\n hipMemcpyHtoA, hipMemcpyHtoAAsync, hipMemcpyHtoD, hipMemcpyHtoDAsync, hipMemFree,\n hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo, hipMemHostAlloc,\n hipMemHostGetDevicePointer, hipMemsetD8, hipMemsetD16, hipMemsetD32, hipArrayGetInfo"]
    pub fn hipArrayGetDescriptor(
        pArrayDescriptor: *mut HIP_ARRAY_DESCRIPTOR,
        array: hipArray_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets a 3D array descriptor\n\n @param[out] pArrayDescriptor - Returned 3D array descriptor\n @param[in]  array            - 3D array to get descriptor of\n\n @returns #hipSuccess, #hipErrorDeinitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,\n #hipErrorInvalidValue #hipErrorInvalidHandle, #hipErrorContextIsDestroyed\n\n @see hipArray3DCreate, hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc,\n hipMemAllocHost, hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned,\n hipMemcpy3D, hipMemcpy3DAsync, hipMemcpyAtoA, hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync,\n hipMemcpyDtoA, hipMemcpyDtoD, hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync,\n hipMemcpyHtoA, hipMemcpyHtoAAsync, hipMemcpyHtoD, hipMemcpyHtoDAsync, hipMemFree,\n hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo, hipMemHostAlloc,\n hipMemHostGetDevicePointer, hipMemsetD8, hipMemsetD16, hipMemsetD32, hipArrayGetInfo"]
    pub fn hipArray3DGetDescriptor(
        pArrayDescriptor: *mut HIP_ARRAY3D_DESCRIPTOR,
        array: hipArray_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device.\n\n  @param[in]   dst    Destination memory address\n  @param[in]   dpitch Pitch of destination memory\n  @param[in]   src    Source memory address\n  @param[in]   spitch Pitch of source memory\n  @param[in]   width  Width of matrix transfer (columns in bytes)\n  @param[in]   height Height of matrix transfer (rows)\n  @param[in]   kind   Type of transfer\n  @returns     #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpyToArray, hipMemcpy2DToArray, hipMemcpyFromArray, hipMemcpyToSymbol,\n hipMemcpyAsync"]
    pub fn hipMemcpy2D(
        dst: *mut ::libc::c_void,
        dpitch: usize,
        src: *const ::libc::c_void,
        spitch: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies memory for 2D arrays.\n  @param[in]   pCopy Parameters for the memory copy\n  @returns     #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n  #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpy2D, hipMemcpyToArray, hipMemcpy2DToArray, hipMemcpyFromArray,\n hipMemcpyToSymbol, hipMemcpyAsync"]
    pub fn hipMemcpyParam2D(pCopy: *const hip_Memcpy2D) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies memory for 2D arrays.\n  @param[in]   pCopy Parameters for the memory copy\n  @param[in]   stream Stream to use\n  @returns     #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpy2D, hipMemcpyToArray, hipMemcpy2DToArray, hipMemcpyFromArray,\n hipMemcpyToSymbol, hipMemcpyAsync"]
    pub fn hipMemcpyParam2DAsync(pCopy: *const hip_Memcpy2D, stream: hipStream_t) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device.\n\n  @param[in]   dst    Destination memory address\n  @param[in]   dpitch Pitch of destination memory\n  @param[in]   src    Source memory address\n  @param[in]   spitch Pitch of source memory\n  @param[in]   width  Width of matrix transfer (columns in bytes)\n  @param[in]   height Height of matrix transfer (rows)\n  @param[in]   kind   Type of transfer\n  @param[in]   stream Stream to use\n  @returns     #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpyToArray, hipMemcpy2DToArray, hipMemcpyFromArray, hipMemcpyToSymbol,\n hipMemcpyAsync"]
    pub fn hipMemcpy2DAsync(
        dst: *mut ::libc::c_void,
        dpitch: usize,
        src: *const ::libc::c_void,
        spitch: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device.\n\n  @param[in]   dst     Destination memory address\n  @param[in]   wOffset Destination starting X offset\n  @param[in]   hOffset Destination starting Y offset\n  @param[in]   src     Source memory address\n  @param[in]   spitch  Pitch of source memory\n  @param[in]   width   Width of matrix transfer (columns in bytes)\n  @param[in]   height  Height of matrix transfer (rows)\n  @param[in]   kind    Type of transfer\n  @returns     #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpyToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,\n hipMemcpyAsync"]
    pub fn hipMemcpy2DToArray(
        dst: hipArray_t,
        wOffset: usize,
        hOffset: usize,
        src: *const ::libc::c_void,
        spitch: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device.\n\n  @param[in]   dst     Destination memory address\n  @param[in]   wOffset Destination starting X offset\n  @param[in]   hOffset Destination starting Y offset\n  @param[in]   src     Source memory address\n  @param[in]   spitch  Pitch of source memory\n  @param[in]   width   Width of matrix transfer (columns in bytes)\n  @param[in]   height  Height of matrix transfer (rows)\n  @param[in]   kind    Type of transfer\n  @param[in]   stream    Accelerator view which the copy is being enqueued\n  @returns     #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpyToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,\n hipMemcpyAsync"]
    pub fn hipMemcpy2DToArrayAsync(
        dst: hipArray_t,
        wOffset: usize,
        hOffset: usize,
        src: *const ::libc::c_void,
        spitch: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device.\n\n  @param[in]   dst Destination memory address\n  @param[in]   wOffsetDst Destination starting X offset\n  @param[in]   hOffsetDst Destination starting Y offset\n  @param[in]   src  Source memory address\n  @param[in]   wOffsetSrc Source starting X offset\n  @param[in]   hOffsetSrc Source starting Y offset (columns in bytes)\n  @param[in]   width  Width of matrix transfer (columns in bytes)\n  @param[in]   height  Height of matrix transfer (rows)\n  @param[in]   kind Type of transfer\n\n  @returns     #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpyToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,\n hipMemcpyAsync"]
    pub fn hipMemcpy2DArrayToArray(
        dst: hipArray_t,
        wOffsetDst: usize,
        hOffsetDst: usize,
        src: hipArray_const_t,
        wOffsetSrc: usize,
        hOffsetSrc: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device [Deprecated]\n\n  @ingroup MemoryD\n\n  @param[in]   dst     Destination memory address\n  @param[in]   wOffset Destination starting X offset\n  @param[in]   hOffset Destination starting Y offset\n  @param[in]   src     Source memory address\n  @param[in]   count   size in bytes to copy\n  @param[in]   kind    Type of transfer\n  @returns     #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,\n  hipMemcpyAsync\n  @warning  This API is deprecated."]
    pub fn hipMemcpyToArray(
        dst: hipArray_t,
        wOffset: usize,
        hOffset: usize,
        src: *const ::libc::c_void,
        count: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device [Deprecated]\n\n  @ingroup MemoryD\n\n  @param[in]   dst       Destination memory address\n  @param[in]   srcArray  Source memory address\n  @param[in]   wOffset   Source starting X offset\n  @param[in]   hOffset   Source starting Y offset\n  @param[in]   count     Size in bytes to copy\n  @param[in]   kind      Type of transfer\n  @returns     #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,\n hipMemcpyAsync\n @warning  This API is deprecated."]
    pub fn hipMemcpyFromArray(
        dst: *mut ::libc::c_void,
        srcArray: hipArray_const_t,
        wOffset: usize,
        hOffset: usize,
        count: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device.\n\n  @param[in]   dst       Destination memory address\n  @param[in]   dpitch    Pitch of destination memory\n  @param[in]   src       Source memory address\n  @param[in]   wOffset   Source starting X offset\n  @param[in]   hOffset   Source starting Y offset\n  @param[in]   width     Width of matrix transfer (columns in bytes)\n  @param[in]   height    Height of matrix transfer (rows)\n  @param[in]   kind      Type of transfer\n  @returns     #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,\n hipMemcpyAsync"]
    pub fn hipMemcpy2DFromArray(
        dst: *mut ::libc::c_void,
        dpitch: usize,
        src: hipArray_const_t,
        wOffset: usize,
        hOffset: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device asynchronously.\n\n  @param[in]   dst       Destination memory address\n  @param[in]   dpitch    Pitch of destination memory\n  @param[in]   src       Source memory address\n  @param[in]   wOffset   Source starting X offset\n  @param[in]   hOffset   Source starting Y offset\n  @param[in]   width     Width of matrix transfer (columns in bytes)\n  @param[in]   height    Height of matrix transfer (rows)\n  @param[in]   kind      Type of transfer\n  @param[in]   stream    Accelerator view which the copy is being enqueued\n  @returns     #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,\n hipMemcpyAsync"]
    pub fn hipMemcpy2DFromArrayAsync(
        dst: *mut ::libc::c_void,
        dpitch: usize,
        src: hipArray_const_t,
        wOffset: usize,
        hOffset: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device.\n\n  @param[in]   dst       Destination memory address\n  @param[in]   srcArray  Source array\n  @param[in]   srcOffset Offset in bytes of source array\n  @param[in]   count     Size of memory copy in bytes\n  @returns     #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,\n hipMemcpyAsync"]
    pub fn hipMemcpyAtoH(
        dst: *mut ::libc::c_void,
        srcArray: hipArray_t,
        srcOffset: usize,
        count: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device.\n\n  @param[in]   dstArray   Destination memory address\n  @param[in]   dstOffset  Offset in bytes of destination array\n  @param[in]   srcHost    Source host pointer\n  @param[in]   count      Size of memory copy in bytes\n  @returns     #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,\n hipMemcpyAsync"]
    pub fn hipMemcpyHtoA(
        dstArray: hipArray_t,
        dstOffset: usize,
        srcHost: *const ::libc::c_void,
        count: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device.\n\n  @param[in]   p   3D memory copy parameters\n  @returns     #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,\n hipMemcpyAsync"]
    pub fn hipMemcpy3D(p: *const hipMemcpy3DParms) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device asynchronously.\n\n  @param[in]   p        3D memory copy parameters\n  @param[in]   stream   Stream to use\n  @returns     #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,\n hipMemcpyAsync"]
    pub fn hipMemcpy3DAsync(p: *const hipMemcpy3DParms, stream: hipStream_t) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device.\n\n  @param[in]   pCopy   3D memory copy parameters\n  @returns     #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n  #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,\n hipMemcpyAsync"]
    pub fn hipDrvMemcpy3D(pCopy: *const HIP_MEMCPY3D) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device asynchronously.\n\n  @param[in]   pCopy    3D memory copy parameters\n  @param[in]   stream   Stream to use\n  @returns     #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,\n  #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection\n\n  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,\n hipMemcpyAsync"]
    pub fn hipDrvMemcpy3DAsync(pCopy: *const HIP_MEMCPY3D, stream: hipStream_t) -> hipError_t;
}
extern "C" {
    #[doc = " @}\n/\n/**\n-------------------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------------------\n  @defgroup PeerToPeer PeerToPeer Device Memory Access\n  @{\n  @warning PeerToPeer support is experimental.\n  This section describes the PeerToPeer device memory access functions of HIP runtime API.\n/\n/**\n @brief Determine if a device can access a peer's memory.\n\n @param [out] canAccessPeer Returns the peer access capability (0 or 1)\n @param [in] deviceId - device from where memory may be accessed.\n @param [in] peerDeviceId - device where memory is physically located\n\n Returns \"1\" in @p canAccessPeer if the specified @p device is capable\n of directly accessing memory physically located on peerDevice , or \"0\" if not.\n\n Returns \"0\" in @p canAccessPeer if deviceId == peerDeviceId, and both are valid devices : a\n device is not a peer of itself.\n\n @returns #hipSuccess,\n @returns #hipErrorInvalidDevice if deviceId or peerDeviceId are not valid devices"]
    pub fn hipDeviceCanAccessPeer(
        canAccessPeer: *mut ::libc::c_int,
        deviceId: ::libc::c_int,
        peerDeviceId: ::libc::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Enable direct access from current device's virtual address space to memory allocations\n physically located on a peer device.\n\n Memory which already allocated on peer device will be mapped into the address space of the\n current device.  In addition, all future memory allocations on peerDeviceId will be mapped into\n the address space of the current device when the memory is allocated. The peer memory remains\n accessible from the current device until a call to hipDeviceDisablePeerAccess or hipDeviceReset.\n\n\n @param [in] peerDeviceId  Peer device to enable direct access to from the current device\n @param [in] flags  Reserved for future use, must be zero\n\n Returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue,\n @returns #hipErrorPeerAccessAlreadyEnabled if peer access is already enabled for this device."]
    pub fn hipDeviceEnablePeerAccess(
        peerDeviceId: ::libc::c_int,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Disable direct access from current device's virtual address space to memory allocations\n physically located on a peer device.\n\n Returns hipErrorPeerAccessNotEnabled if direct access to memory on peerDevice has not yet been\n enabled from the current device.\n\n @param [in] peerDeviceId  Peer device to disable direct access to\n\n @returns #hipSuccess, #hipErrorPeerAccessNotEnabled"]
    pub fn hipDeviceDisablePeerAccess(peerDeviceId: ::libc::c_int) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Get information on memory allocations.\n\n @param [out] pbase - BAse pointer address\n @param [out] psize - Size of allocation\n @param [in]  dptr- Device Pointer\n\n @returns #hipSuccess, #hipErrorNotFound\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub fn hipMemGetAddressRange(
        pbase: *mut hipDeviceptr_t,
        psize: *mut usize,
        dptr: hipDeviceptr_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Copies memory from one device to memory on another device.\n\n @param [out] dst - Destination device pointer.\n @param [in] dstDeviceId - Destination device\n @param [in] src - Source device pointer\n @param [in] srcDeviceId - Source device\n @param [in] sizeBytes - Size of memory copy in bytes\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidDevice"]
    pub fn hipMemcpyPeer(
        dst: *mut ::libc::c_void,
        dstDeviceId: ::libc::c_int,
        src: *const ::libc::c_void,
        srcDeviceId: ::libc::c_int,
        sizeBytes: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Copies memory from one device to memory on another device.\n\n @param [out] dst - Destination device pointer.\n @param [in] dstDeviceId - Destination device\n @param [in] src - Source device pointer\n @param [in] srcDevice - Source device\n @param [in] sizeBytes - Size of memory copy in bytes\n @param [in] stream - Stream identifier\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidDevice"]
    pub fn hipMemcpyPeerAsync(
        dst: *mut ::libc::c_void,
        dstDeviceId: ::libc::c_int,
        src: *const ::libc::c_void,
        srcDevice: ::libc::c_int,
        sizeBytes: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Create a context and set it as current/default context\n\n @param [out] ctx  Context to create\n @param [in] flags  Context creation flags\n @param [in] device  device handle\n\n @returns #hipSuccess\n\n @see hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent, hipCtxPushCurrent,\n hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice\n\n @warning  This API is deprecated on the AMD platform, only for equivalent cuCtx driver API on the\n NVIDIA platform.\n"]
    pub fn hipCtxCreate(
        ctx: *mut hipCtx_t,
        flags: ::libc::c_uint,
        device: hipDevice_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Destroy a HIP context [Deprecated]\n\n @param [in] ctx Context to destroy\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @see hipCtxCreate, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,hipCtxSetCurrent,\n hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize , hipCtxGetDevice\n\n @warning  This API is deprecated on the AMD platform, only for equivalent cuCtx driver API on the\n NVIDIA platform."]
    pub fn hipCtxDestroy(ctx: hipCtx_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Pop the current/default context and return the popped context [Deprecated]\n\n @param [out] ctx  The current context to pop\n\n @returns #hipSuccess, #hipErrorInvalidContext\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxSetCurrent, hipCtxGetCurrent,\n hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice\n\n @warning  This API is deprecated on the AMD platform, only for equivalent cuCtx driver API on the\n NVIDIA platform."]
    pub fn hipCtxPopCurrent(ctx: *mut hipCtx_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Push the context to be set as current/ default context [Deprecated]\n\n @param [in] ctx  The current context to push\n\n @returns #hipSuccess, #hipErrorInvalidContext\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize , hipCtxGetDevice\n\n @warning  This API is deprecated on the AMD platform, only for equivalent cuCtx driver API on the\n NVIDIA platform."]
    pub fn hipCtxPushCurrent(ctx: hipCtx_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Set the passed context as current/default [Deprecated]\n\n @param [in] ctx The context to set as current\n\n @returns #hipSuccess, #hipErrorInvalidContext\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize , hipCtxGetDevice\n\n @warning  This API is deprecated on the AMD platform, only for equivalent cuCtx driver API on the\n NVIDIA platform."]
    pub fn hipCtxSetCurrent(ctx: hipCtx_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Get the handle of the current/ default context [Deprecated]\n\n @param [out] ctx  The context to get as current\n\n @returns #hipSuccess, #hipErrorInvalidContext\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetDevice, hipCtxGetFlags, hipCtxPopCurrent,\n hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice\n\n @warning  This API is deprecated on the AMD platform, only for equivalent cuCtx driver API on the\n NVIDIA platform."]
    pub fn hipCtxGetCurrent(ctx: *mut hipCtx_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Get the handle of the device associated with current/default context [Deprecated]\n\n @param [out] device The device from the current context\n\n @returns #hipSuccess, #hipErrorInvalidContext\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize\n\n @warning  This API is deprecated on the AMD platform, only for equivalent cuCtx driver API on the\n NVIDIA platform."]
    pub fn hipCtxGetDevice(device: *mut hipDevice_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns the approximate HIP api version.\n\n @param [in]  ctx Context to check [Deprecated]\n @param [out] apiVersion API version to get\n\n @returns #hipSuccess\n\n @warning The HIP feature set does not correspond to an exact CUDA SDK api revision.\n This function always set *apiVersion to 4 as an approximation though HIP supports\n some features which were introduced in later CUDA SDK revisions.\n HIP apps code should not rely on the api revision number here and should\n use arch feature flags to test device capabilities or conditional compilation.\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetDevice, hipCtxGetFlags, hipCtxPopCurrent,\n hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice\n\n @warning  This API is deprecated on the AMD platform, only for equivalent cuCtx driver API on the\n NVIDIA platform."]
    pub fn hipCtxGetApiVersion(ctx: hipCtx_t, apiVersion: *mut ::libc::c_int) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Get Cache configuration for a specific function [Deprecated]\n\n @param [out] cacheConfig  Cache configuration\n\n @returns #hipSuccess\n\n @warning AMD devices and some Nvidia GPUS do not support reconfigurable cache.  This hint is\n ignored on those architectures.\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice\n\n @warning  This API is deprecated on the AMD platform, only for equivalent cuCtx driver API on the\n NVIDIA platform."]
    pub fn hipCtxGetCacheConfig(cacheConfig: *mut hipFuncCache_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Set L1/Shared cache partition [Deprecated]\n\n @param [in] cacheConfig  Cache configuration to set\n\n @return #hipSuccess\n\n @warning AMD devices and some Nvidia GPUS do not support reconfigurable cache.  This hint is\n ignored on those architectures.\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice\n\n @warning  This API is deprecated on the AMD platform, only for equivalent cuCtx driver API on the\n NVIDIA platform."]
    pub fn hipCtxSetCacheConfig(cacheConfig: hipFuncCache_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Set Shared memory bank configuration  [Deprecated]\n\n @param [in] config  Shared memory configuration to set\n\n @return #hipSuccess\n\n @warning AMD devices and some Nvidia GPUS do not support shared cache banking, and the hint is\n ignored on those architectures.\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice\n\n @warning  This API is deprecated on the AMD platform, only for equivalent cuCtx driver API on the\n NVIDIA platform."]
    pub fn hipCtxSetSharedMemConfig(config: hipSharedMemConfig) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Get Shared memory bank configuration [Deprecated]\n\n @param [out] pConfig  Pointer of shared memory configuration\n\n @return #hipSuccess\n\n @warning AMD devices and some Nvidia GPUS do not support shared cache banking, and the hint is\n ignored on those architectures.\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice\n\n @warning  This API is deprecated on the AMD platform, only for equivalent cuCtx driver API on the\n NVIDIA platform."]
    pub fn hipCtxGetSharedMemConfig(pConfig: *mut hipSharedMemConfig) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Blocks until the default context has completed all preceding requested tasks [Deprecated]\n\n @return #hipSuccess\n\n @warning This function waits for all streams on the default context to complete execution, and\n then returns.\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxGetDevice\n\n @warning  This API is deprecated on the AMD platform, only for equivalent cuCtx driver API on the\n NVIDIA platform."]
    pub fn hipCtxSynchronize() -> hipError_t;
}
extern "C" {
    #[doc = " @brief Return flags used for creating default context [Deprecated]\n\n @param [out] flags  Pointer of flags\n\n @returns #hipSuccess\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxPopCurrent, hipCtxGetCurrent, hipCtxGetCurrent,\n hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice\n\n @warning  This API is deprecated on the AMD platform, only for equivalent cuCtx driver API on the\n NVIDIA platform."]
    pub fn hipCtxGetFlags(flags: *mut ::libc::c_uint) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Enables direct access to memory allocations in a peer context [Deprecated]\n\n Memory which already allocated on peer device will be mapped into the address space of the\n current device.  In addition, all future memory allocations on peerDeviceId will be mapped into\n the address space of the current device when the memory is allocated. The peer memory remains\n accessible from the current device until a call to hipDeviceDisablePeerAccess or hipDeviceReset.\n\n\n @param [in] peerCtx  Peer context\n @param [in] flags  flags, need to set as 0\n\n @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue,\n #hipErrorPeerAccessAlreadyEnabled\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice\n @warning PeerToPeer support is experimental.\n\n @warning  This API is deprecated on the AMD platform, only for equivalent cuCtx driver API on the\n NVIDIA platform."]
    pub fn hipCtxEnablePeerAccess(peerCtx: hipCtx_t, flags: ::libc::c_uint) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Disable direct access from current context's virtual address space to memory allocations\n physically located on a peer context.Disables direct access to memory allocations in a peer\n context and unregisters any registered allocations [Deprecated]\n\n Returns #hipErrorPeerAccessNotEnabled if direct access to memory on peerDevice has not yet been\n enabled from the current device.\n\n @param [in] peerCtx  Peer context to be disabled\n\n @returns #hipSuccess, #hipErrorPeerAccessNotEnabled\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice\n @warning PeerToPeer support is experimental.\n\n @warning  This API is deprecated on the AMD platform, only for equivalent cuCtx driver API on the\n NVIDIA platform."]
    pub fn hipCtxDisablePeerAccess(peerCtx: hipCtx_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Get the state of the primary context [Deprecated]\n\n @param [in] dev  Device to get primary context flags for\n @param [out] flags  Pointer to store flags\n @param [out] active  Pointer to store context state; 0 = inactive, 1 = active\n\n @returns #hipSuccess\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice\n\n @warning  This API is deprecated on the AMD platform, only for equivalent driver API on the\n NVIDIA platform."]
    pub fn hipDevicePrimaryCtxGetState(
        dev: hipDevice_t,
        flags: *mut ::libc::c_uint,
        active: *mut ::libc::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Release the primary context on the GPU.\n\n @param [in] dev  Device which primary context is released [Deprecated]\n\n @returns #hipSuccess\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice\n @warning This function return #hipSuccess though doesn't release the primaryCtx by design on\n HIP/HCC path.\n\n @warning  This API is deprecated on the AMD platform, only for equivalent driver API on the NVIDIA\n platform."]
    pub fn hipDevicePrimaryCtxRelease(dev: hipDevice_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Retain the primary context on the GPU [Deprecated]\n\n @param [out] pctx  Returned context handle of the new context\n @param [in] dev  Device which primary context is released\n\n @returns #hipSuccess\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice\n\n @warning  This API is deprecated on the AMD platform, only for equivalent driver API on the NVIDIA\n platform."]
    pub fn hipDevicePrimaryCtxRetain(pctx: *mut hipCtx_t, dev: hipDevice_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Resets the primary context on the GPU [Deprecated]\n\n @param [in] dev  Device which primary context is reset\n\n @returns #hipSuccess\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice\n\n @warning  This API is deprecated on the AMD platform, only for equivalent driver API on the NVIDIA\n platform."]
    pub fn hipDevicePrimaryCtxReset(dev: hipDevice_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Set flags for the primary context [Deprecated]\n\n @param [in] dev  Device for which the primary context flags are set\n @param [in] flags  New flags for the device\n\n @returns #hipSuccess, #hipErrorContextAlreadyInUse\n\n @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,\n hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice\n\n @warning  This API is deprecated on the AMD platform, only for equivalent driver API on the NVIDIA\n platform."]
    pub fn hipDevicePrimaryCtxSetFlags(dev: hipDevice_t, flags: ::libc::c_uint) -> hipError_t;
}
extern "C" {
    #[doc = " @}\n/\n/**\n-------------------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------------------\n\n  @defgroup Module Module Management\n  @{\n  @ingroup API\n  This section describes the module management functions of HIP runtime API.\n\n/\n/**\n @brief Loads code object from file into a module the currrent context.\n\n @param [in] fname  Filename of code object to load\n\n @param [out] module  Module\n\n @warning File/memory resources allocated in this function are released only in hipModuleUnload.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidContext, #hipErrorFileNotFound,\n #hipErrorOutOfMemory, #hipErrorSharedObjectInitFailed, #hipErrorNotInitialized\n"]
    pub fn hipModuleLoad(module: *mut hipModule_t, fname: *const ::libc::c_char) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Frees the module\n\n @param [in] module  Module to free\n\n @returns #hipSuccess, #hipErrorInvalidResourceHandle\n\n The module is freed, and the code objects associated with it are destroyed."]
    pub fn hipModuleUnload(module: hipModule_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Function with kname will be extracted if present in module\n\n @param [in] module  Module to get function from\n @param [in] kname  Pointer to the name of function\n @param [out] function  Pointer to function handle\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidContext, #hipErrorNotInitialized,\n #hipErrorNotFound,"]
    pub fn hipModuleGetFunction(
        function: *mut hipFunction_t,
        module: hipModule_t,
        kname: *const ::libc::c_char,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Find out attributes for a given function.\n @ingroup Execution\n @param [out] attr  Attributes of funtion\n @param [in] func  Pointer to the function handle\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidDeviceFunction"]
    pub fn hipFuncGetAttributes(
        attr: *mut hipFuncAttributes,
        func: *const ::libc::c_void,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Find out a specific attribute for a given function.\n @ingroup Execution\n @param [out] value  Pointer to the value\n @param [in]  attrib  Attributes of the given funtion\n @param [in]  hfunc  Function to get attributes from\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidDeviceFunction"]
    pub fn hipFuncGetAttribute(
        value: *mut ::libc::c_int,
        attrib: hipFunction_attribute,
        hfunc: hipFunction_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets pointer to device entry function that matches entry function symbolPtr.\n\n @param [out] functionPtr  Device entry function\n @param [in]  symbolPtr  Pointer to device entry function to search for\n\n @returns #hipSuccess, #hipErrorInvalidDeviceFunction\n"]
    pub fn hipGetFuncBySymbol(
        functionPtr: *mut hipFunction_t,
        symbolPtr: *const ::libc::c_void,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief returns the handle of the texture reference with the name from the module.\n\n @param [in] hmod  Module\n @param [in] name  Pointer of name of texture reference\n @param [out] texRef  Pointer of texture reference\n\n @returns #hipSuccess, #hipErrorNotInitialized, #hipErrorNotFound, #hipErrorInvalidValue"]
    pub fn hipModuleGetTexRef(
        texRef: *mut *mut textureReference,
        hmod: hipModule_t,
        name: *const ::libc::c_char,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief builds module from code object which resides in host memory. Image is pointer to that\n location.\n\n @param [in] image  The pointer to the location of data\n @param [out] module  Retuned module\n\n @returns hipSuccess, hipErrorNotInitialized, hipErrorOutOfMemory, hipErrorNotInitialized"]
    pub fn hipModuleLoadData(module: *mut hipModule_t, image: *const ::libc::c_void) -> hipError_t;
}
extern "C" {
    #[doc = " @brief builds module from code object which resides in host memory. Image is pointer to that\n location. Options are not used. hipModuleLoadData is called.\n\n @param [in] image  The pointer to the location of data\n @param [out] module  Retuned module\n @param [in] numOptions Number of options\n @param [in] options Options for JIT\n @param [in] optionValues  Option values for JIT\n\n @returns hipSuccess, hipErrorNotInitialized, hipErrorOutOfMemory, hipErrorNotInitialized"]
    pub fn hipModuleLoadDataEx(
        module: *mut hipModule_t,
        image: *const ::libc::c_void,
        numOptions: ::libc::c_uint,
        options: *mut hipJitOption,
        optionValues: *mut *mut ::libc::c_void,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Completes the linking of the given program.\n @param [in] state hip link state\n @param [in] type  Type of the input data or bitcode\n @param [in] data  Input data which is null terminated\n @param [in] size  Size of the input data\n @param [in] name  Optional name for this input\n @param [in] numOptions  Size of the options\n @param [in] options  Array of options applied to this input\n @param [in] optionValues  Array of option values cast to void*\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidHandle\n\n If adding the file fails, it will\n @return #hipErrorInvalidConfiguration\n\n @see hipError_t"]
    pub fn hipLinkAddData(
        state: hipLinkState_t,
        type_: hipJitInputType,
        data: *mut ::libc::c_void,
        size: usize,
        name: *const ::libc::c_char,
        numOptions: ::libc::c_uint,
        options: *mut hipJitOption,
        optionValues: *mut *mut ::libc::c_void,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Adds a file with bit code to be linked with options\n @param [in] state hip link state\n @param [in] type  Type of the input data or bitcode\n @param [in] path  Path to the input file where bitcode is present\n @param [in] numOptions  Size of the options\n @param [in] options  Array of options applied to this input\n @param [in] optionValues  Array of option values cast to void*\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n If adding the file fails, it will\n @return #hipErrorInvalidConfiguration\n\n @see hipError_t"]
    pub fn hipLinkAddFile(
        state: hipLinkState_t,
        type_: hipJitInputType,
        path: *const ::libc::c_char,
        numOptions: ::libc::c_uint,
        options: *mut hipJitOption,
        optionValues: *mut *mut ::libc::c_void,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Completes the linking of the given program.\n @param [in]   state hip link state\n @param [out]  hipBinOut  Upon success, points to the output binary\n @param [out]  sizeOut  Size of the binary is stored (optional)\n\n @returns #hipSuccess #hipErrorInvalidValue\n\n If adding the data fails, it will\n @return #hipErrorInvalidConfiguration\n\n @see hipError_t"]
    pub fn hipLinkComplete(
        state: hipLinkState_t,
        hipBinOut: *mut *mut ::libc::c_void,
        sizeOut: *mut usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Creates the link instance via hip APIs.\n @param [in] numOptions  Number of options\n @param [in] option  Array of options\n @param [in] optionValues  Array of option values cast to void*\n @param [out] stateOut  hip link state created upon success\n\n @returns #hipSuccess #hipErrorInvalidValue #hipErrorInvalidConfiguration\n\n @see hipSuccess"]
    pub fn hipLinkCreate(
        numOptions: ::libc::c_uint,
        options: *mut hipJitOption,
        optionValues: *mut *mut ::libc::c_void,
        stateOut: *mut hipLinkState_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Deletes the link instance via hip APIs.\n @param [in] state link state instance\n\n @returns #hipSuccess #hipErrorInvalidValue\n\n @see hipSuccess"]
    pub fn hipLinkDestroy(state: hipLinkState_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief launches kernel f with launch parameters and shared memory on stream with arguments passed\n to kernelparams or extra\n @ingroup Execution\n @param [in] f         Kernel to launch.\n @param [in] gridDimX  X grid dimension specified as multiple of blockDimX.\n @param [in] gridDimY  Y grid dimension specified as multiple of blockDimY.\n @param [in] gridDimZ  Z grid dimension specified as multiple of blockDimZ.\n @param [in] blockDimX X block dimensions specified in work-items\n @param [in] blockDimY Y grid dimension specified in work-items\n @param [in] blockDimZ Z grid dimension specified in work-items\n @param [in] sharedMemBytes Amount of dynamic shared memory to allocate for this kernel. The\n HIP-Clang compiler provides support for extern shared declarations.\n @param [in] stream    Stream where the kernel should be dispatched.  May be 0, in which case th\n default stream is used with associated synchronization rules.\n @param [in] kernelParams  Kernel parameters to launch\n @param [in] extra     Pointer to kernel arguments.   These are passed directly to the kernel and\n must be in the memory layout and alignment expected by the kernel.\n All passed arguments must be naturally aligned according to their type. The memory address of each\n argument should be a multiple of its size in bytes. Please refer to hip_porting_driver_api.md\n for sample usage.\n\n Please note, HIP does not support kernel launch with total work items defined in dimension with\n size gridDim x blockDim >= 2^32. So gridDim.x * blockDim.x, gridDim.y * blockDim.y\n and gridDim.z * blockDim.z are always less than 2^32.\n\n @returns #hipSuccess, #hipErrorNotInitialized, #hipErrorInvalidValue"]
    pub fn hipModuleLaunchKernel(
        f: hipFunction_t,
        gridDimX: ::libc::c_uint,
        gridDimY: ::libc::c_uint,
        gridDimZ: ::libc::c_uint,
        blockDimX: ::libc::c_uint,
        blockDimY: ::libc::c_uint,
        blockDimZ: ::libc::c_uint,
        sharedMemBytes: ::libc::c_uint,
        stream: hipStream_t,
        kernelParams: *mut *mut ::libc::c_void,
        extra: *mut *mut ::libc::c_void,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " \\addtogroup ModuleCooperativeG Cooperative groups kernel launch of Module management.\n \\ingroup Module\n  @{ */\n/**\n @brief launches kernel f with launch parameters and shared memory on stream with arguments passed\n to kernelParams, where thread blocks can cooperate and synchronize as they execute\n\n @param [in] f              Kernel to launch.\n @param [in] gridDimX       X grid dimension specified as multiple of blockDimX.\n @param [in] gridDimY       Y grid dimension specified as multiple of blockDimY.\n @param [in] gridDimZ       Z grid dimension specified as multiple of blockDimZ.\n @param [in] blockDimX      X block dimension specified in work-items.\n @param [in] blockDimY      Y block dimension specified in work-items.\n @param [in] blockDimZ      Z block dimension specified in work-items.\n @param [in] sharedMemBytes Amount of dynamic shared memory to allocate for this kernel. The\n HIP-Clang compiler provides support for extern shared declarations.\n @param [in] stream         Stream where the kernel should be dispatched. May be 0,\n in which case the default stream is used with associated synchronization rules.\n @param [in] kernelParams   A list of kernel arguments.\n\n Please note, HIP does not support kernel launch with total work items defined in dimension with\n size \\f$ gridDim \\cdot blockDim \\geq 2^{32} \\f$.\n\n @returns #hipSuccess, #hipErrorDeinitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,\n #hipErrorInvalidHandle, #hipErrorInvalidImage, #hipErrorInvalidValue,\n #hipErrorInvalidConfiguration, #hipErrorLaunchFailure, #hipErrorLaunchOutOfResources,\n #hipErrorLaunchTimeOut, #hipErrorCooperativeLaunchTooLarge, #hipErrorSharedObjectInitFailed"]
    pub fn hipModuleLaunchCooperativeKernel(
        f: hipFunction_t,
        gridDimX: ::libc::c_uint,
        gridDimY: ::libc::c_uint,
        gridDimZ: ::libc::c_uint,
        blockDimX: ::libc::c_uint,
        blockDimY: ::libc::c_uint,
        blockDimZ: ::libc::c_uint,
        sharedMemBytes: ::libc::c_uint,
        stream: hipStream_t,
        kernelParams: *mut *mut ::libc::c_void,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Launches kernels on multiple devices where thread blocks can cooperate and\n synchronize as they execute.\n\n @param [in] launchParamsList         List of launch parameters, one per device.\n @param [in] numDevices               Size of the launchParamsList array.\n @param [in] flags                    Flags to control launch behavior.\n\n @returns #hipSuccess, #hipErrorDeinitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,\n #hipErrorInvalidHandle, #hipErrorInvalidImage, #hipErrorInvalidValue,\n #hipErrorInvalidConfiguration, #hipErrorInvalidResourceHandle, #hipErrorLaunchFailure,\n #hipErrorLaunchOutOfResources, #hipErrorLaunchTimeOut, #hipErrorCooperativeLaunchTooLarge,\n #hipErrorSharedObjectInitFailed"]
    pub fn hipModuleLaunchCooperativeKernelMultiDevice(
        launchParamsList: *mut hipFunctionLaunchParams,
        numDevices: ::libc::c_uint,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Launches kernel f with launch parameters and shared memory on stream with arguments passed\n to kernelparams or extra, where thread blocks can cooperate and synchronize as they execute.\n\n @param [in] f - Kernel to launch.\n @param [in] gridDim - Grid dimensions specified as multiple of blockDim.\n @param [in] blockDimX - Block dimensions specified in work-items\n @param [in] kernelParams - Pointer of arguments passed to the kernel. If the kernel has multiple\n parameters, 'kernelParams' should be array of pointers, each points the corresponding argument.\n @param [in] sharedMemBytes - Amount of dynamic shared memory to allocate for this kernel. The\n HIP-Clang compiler provides support for extern shared declarations.\n @param [in] stream - Stream where the kernel should be dispatched.  May be 0, in which case th\n default stream is used with associated synchronization rules.\n\n Please note, HIP does not support kernel launch with total work items defined in dimension with\n size \\f$ gridDim \\cdot blockDim \\geq 2^{32} \\f$.\n\n @returns #hipSuccess, #hipErrorNotInitialized, #hipErrorInvalidValue,\n #hipErrorCooperativeLaunchTooLarge"]
    pub fn hipLaunchCooperativeKernel(
        f: *const ::libc::c_void,
        gridDim: dim3,
        blockDimX: dim3,
        kernelParams: *mut *mut ::libc::c_void,
        sharedMemBytes: ::libc::c_uint,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Launches kernels on multiple devices where thread blocks can cooperate and\n synchronize as they execute.\n\n @param [in] launchParamsList         List of launch parameters, one per device.\n @param [in] numDevices               Size of the launchParamsList array.\n @param [in] flags                    Flags to control launch behavior.\n\n @returns #hipSuccess, #hipErrorNotInitialized, #hipErrorInvalidValue,\n  #hipErrorCooperativeLaunchTooLarge"]
    pub fn hipLaunchCooperativeKernelMultiDevice(
        launchParamsList: *mut hipLaunchParams,
        numDevices: ::libc::c_int,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Launches kernels on multiple devices and guarantees all specified kernels are dispatched\n on respective streams before enqueuing any other work on the specified streams from any other threads\n @ingroup Execution\n @param [in] launchParamsList          List of launch parameters, one per device.\n @param [in] numDevices               Size of the launchParamsList array.\n @param [in] flags                    Flags to control launch behavior.\n\n @returns #hipSuccess, #hipErrorNotInitialized, #hipErrorInvalidValue"]
    pub fn hipExtLaunchMultiKernelMultiDevice(
        launchParamsList: *mut hipLaunchParams,
        numDevices: ::libc::c_int,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "-------------------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------------------\n  @defgroup Occupancy Occupancy\n  @{\n  This section describes the occupancy functions of HIP runtime API.\n\n/\n/**\n @brief determine the grid and block sizes to achieves maximum occupancy for a kernel\n\n @param [out] gridSize           minimum grid size for maximum potential occupancy\n @param [out] blockSize          block size for maximum potential occupancy\n @param [in]  f                  kernel function for which occupancy is calulated\n @param [in]  dynSharedMemPerBlk dynamic shared memory usage (in bytes) intended for each block\n @param [in]  blockSizeLimit     the maximum block size for the kernel, use 0 for no limit\n\n Please note, HIP does not support kernel launch with total work items defined in dimension with\n size gridDim x blockDim >= 2^32.\n\n @returns #hipSuccess, #hipErrorInvalidValue"]
    pub fn hipModuleOccupancyMaxPotentialBlockSize(
        gridSize: *mut ::libc::c_int,
        blockSize: *mut ::libc::c_int,
        f: hipFunction_t,
        dynSharedMemPerBlk: usize,
        blockSizeLimit: ::libc::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief determine the grid and block sizes to achieves maximum occupancy for a kernel\n\n @param [out] gridSize           minimum grid size for maximum potential occupancy\n @param [out] blockSize          block size for maximum potential occupancy\n @param [in]  f                  kernel function for which occupancy is calulated\n @param [in]  dynSharedMemPerBlk dynamic shared memory usage (in bytes) intended for each block\n @param [in]  blockSizeLimit     the maximum block size for the kernel, use 0 for no limit\n @param [in]  flags            Extra flags for occupancy calculation (only default supported)\n\n Please note, HIP does not support kernel launch with total work items defined in dimension with\n size gridDim x blockDim >= 2^32.\n\n @returns #hipSuccess, #hipErrorInvalidValue"]
    pub fn hipModuleOccupancyMaxPotentialBlockSizeWithFlags(
        gridSize: *mut ::libc::c_int,
        blockSize: *mut ::libc::c_int,
        f: hipFunction_t,
        dynSharedMemPerBlk: usize,
        blockSizeLimit: ::libc::c_int,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns occupancy for a device function.\n\n @param [out] numBlocks        Returned occupancy\n @param [in]  f                Kernel function (hipFunction) for which occupancy is calulated\n @param [in]  blockSize        Block size the kernel is intended to be launched with\n @param [in]  dynSharedMemPerBlk Dynamic shared memory usage (in bytes) intended for each block\n @returns  #hipSuccess, #hipErrorInvalidValue"]
    pub fn hipModuleOccupancyMaxActiveBlocksPerMultiprocessor(
        numBlocks: *mut ::libc::c_int,
        f: hipFunction_t,
        blockSize: ::libc::c_int,
        dynSharedMemPerBlk: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns occupancy for a device function.\n\n @param [out] numBlocks        Returned occupancy\n @param [in]  f                Kernel function(hipFunction_t) for which occupancy is calulated\n @param [in]  blockSize        Block size the kernel is intended to be launched with\n @param [in]  dynSharedMemPerBlk Dynamic shared memory usage (in bytes) intended for each block\n @param [in]  flags            Extra flags for occupancy calculation (only default supported)\n @returns  #hipSuccess, #hipErrorInvalidValue"]
    pub fn hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(
        numBlocks: *mut ::libc::c_int,
        f: hipFunction_t,
        blockSize: ::libc::c_int,
        dynSharedMemPerBlk: usize,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns occupancy for a device function.\n\n @param [out] numBlocks        Returned occupancy\n @param [in]  f                Kernel function for which occupancy is calulated\n @param [in]  blockSize        Block size the kernel is intended to be launched with\n @param [in]  dynSharedMemPerBlk Dynamic shared memory usage (in bytes) intended for each block\n @returns  #hipSuccess, #hipErrorInvalidDeviceFunction, #hipErrorInvalidValue"]
    pub fn hipOccupancyMaxActiveBlocksPerMultiprocessor(
        numBlocks: *mut ::libc::c_int,
        f: *const ::libc::c_void,
        blockSize: ::libc::c_int,
        dynSharedMemPerBlk: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns occupancy for a device function.\n\n @param [out] numBlocks        Returned occupancy\n @param [in]  f                Kernel function for which occupancy is calulated\n @param [in]  blockSize        Block size the kernel is intended to be launched with\n @param [in]  dynSharedMemPerBlk Dynamic shared memory usage (in bytes) intended for each block\n @param [in]  flags            Extra flags for occupancy calculation (currently ignored)\n @returns  #hipSuccess, #hipErrorInvalidDeviceFunction, #hipErrorInvalidValue"]
    pub fn hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(
        numBlocks: *mut ::libc::c_int,
        f: *const ::libc::c_void,
        blockSize: ::libc::c_int,
        dynSharedMemPerBlk: usize,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief determine the grid and block sizes to achieves maximum occupancy for a kernel\n\n @param [out] gridSize           minimum grid size for maximum potential occupancy\n @param [out] blockSize          block size for maximum potential occupancy\n @param [in]  f                  kernel function for which occupancy is calulated\n @param [in]  dynSharedMemPerBlk dynamic shared memory usage (in bytes) intended for each block\n @param [in]  blockSizeLimit     the maximum block size for the kernel, use 0 for no limit\n\n Please note, HIP does not support kernel launch with total work items defined in dimension with\n size gridDim x blockDim >= 2^32.\n\n @returns #hipSuccess, #hipErrorInvalidValue"]
    pub fn hipOccupancyMaxPotentialBlockSize(
        gridSize: *mut ::libc::c_int,
        blockSize: *mut ::libc::c_int,
        f: *const ::libc::c_void,
        dynSharedMemPerBlk: usize,
        blockSizeLimit: ::libc::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Start recording of profiling information [Deprecated]\n When using this API, start the profiler with profiling disabled.  (--startdisabled)\n @returns  #hipErrorNotSupported\n @warning hipProfilerStart API is deprecated, use roctracer/rocTX instead."]
    pub fn hipProfilerStart() -> hipError_t;
}
extern "C" {
    #[doc = " @brief Stop recording of profiling information [Deprecated]\n When using this API, start the profiler with profiling disabled.  (--startdisabled)\n @returns  #hipErrorNotSupported\n @warning  hipProfilerStart API is deprecated, use roctracer/rocTX instead."]
    pub fn hipProfilerStop() -> hipError_t;
}
extern "C" {
    #[doc = " @}\n/\n/**\n-------------------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------------------\n  @defgroup Clang Launch API to support the triple-chevron syntax\n  @{\n  This section describes the API to support the triple-chevron syntax.\n/\n/**\n @brief Configure a kernel launch.\n\n @param [in] gridDim   grid dimension specified as multiple of blockDim.\n @param [in] blockDim  block dimensions specified in work-items\n @param [in] sharedMem Amount of dynamic shared memory to allocate for this kernel. The\n HIP-Clang compiler provides support for extern shared declarations.\n @param [in] stream    Stream where the kernel should be dispatched.  May be 0, in which case the\n default stream is used with associated synchronization rules.\n\n Please note, HIP does not support kernel launch with total work items defined in dimension with\n size gridDim x blockDim >= 2^32.\n\n @returns #hipSuccess, #hipErrorNotInitialized, #hipErrorInvalidValue\n"]
    pub fn hipConfigureCall(
        gridDim: dim3,
        blockDim: dim3,
        sharedMem: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Set a kernel argument.\n\n @returns #hipSuccess, #hipErrorNotInitialized, #hipErrorInvalidValue\n\n @param [in] arg    Pointer the argument in host memory.\n @param [in] size   Size of the argument.\n @param [in] offset Offset of the argument on the argument stack.\n"]
    pub fn hipSetupArgument(arg: *const ::libc::c_void, size: usize, offset: usize) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Launch a kernel.\n\n @param [in] func Kernel to launch.\n\n @returns #hipSuccess, #hipErrorNotInitialized, #hipErrorInvalidValue\n"]
    pub fn hipLaunchByPtr(func: *const ::libc::c_void) -> hipError_t;
}
extern "C" {
    #[doc = " @brief C compliant kernel launch API\n\n @param [in] function_address - Kernel stub function pointer.\n @param [in] numBlocks - Number of blocks.\n @param [in] dimBlocks - Dimension of a block\n @param [in] args - Pointer of arguments passed to the kernel. If the kernel has multiple\n parameters, 'args' should be array of pointers, each points the corresponding argument.\n @param [in] sharedMemBytes - Amount of dynamic shared memory to allocate for this kernel. The\n HIP-Clang compiler provides support for extern shared declarations.\n @param [in] stream - Stream where the kernel should be dispatched.  May be 0, in which case th\n  default stream is used with associated synchronization rules.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipLaunchKernel(
        function_address: *const ::libc::c_void,
        numBlocks: dim3,
        dimBlocks: dim3,
        args: *mut *mut ::libc::c_void,
        sharedMemBytes: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Enqueues a host function call in a stream.\n\n @param [in] stream - The stream to enqueue work in.\n @param [in] fn - The function to call once enqueued preceeding operations are complete.\n @param [in] userData - User-specified data to be passed to the function.\n\n @returns #hipSuccess, #hipErrorInvalidResourceHandle, #hipErrorInvalidValue,\n #hipErrorNotSupported\n\n The host function to call in this API will be executed after the preceding operations in\n the stream are complete. The function is a blocking operation that blocks operations in the\n stream that follow it, until the function is returned.\n Event synchronization and internal callback functions make sure enqueued operations will\n execute in order, in the stream.\n\n The host function must not make any HIP API calls. The host function is non-reentrant. It must\n not perform sychronization with any operation that may depend on other processing execution\n but is not enqueued to run earlier in the stream.\n\n Host functions that are enqueued respectively in different non-blocking streams can run concurrently.\n\n @warning  This API is marked as beta, meaning, while this is feature complete,\n it is still open to changes and may have outstanding issues."]
    pub fn hipLaunchHostFunc(
        stream: hipStream_t,
        fn_: hipHostFn_t,
        userData: *mut ::libc::c_void,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " Copies memory for 2D arrays.\n\n @param pCopy           - Parameters for the memory copy\n\n @returns #hipSuccess, #hipErrorInvalidValue"]
    pub fn hipDrvMemcpy2DUnaligned(pCopy: *const hip_Memcpy2D) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Launches kernel from the pointer address, with arguments and shared memory on stream.\n\n @param [in] function_address - Pointer to the Kernel to launch.\n @param [in] numBlocks -  Number of blocks.\n @param [in] dimBlocks - Dimension of a block.\n @param [in] args - Pointer of arguments passed to the kernel. If the kernel has multiple\n parameters, 'args' should be array of pointers, each points the corresponding argument.\n @param [in] sharedMemBytes - Amount of dynamic shared memory to allocate for this kernel.\n HIP-Clang compiler provides support for extern shared declarations.\n @param [in] stream - Stream where the kernel should be dispatched.\n May be 0, in which case the default stream is used with associated synchronization rules.\n @param [in] startEvent - If non-null, specified event will be updated to track the start time of\n the kernel launch. The event must be created before calling this API.\n @param [in] stopEvent - If non-null, specified event will be updated to track the stop time of\n the kernel launch. The event must be created before calling this API.\n @param [in] flags - The value of hipExtAnyOrderLaunch, signifies if kernel can be\n launched in any order.\n @returns #hipSuccess, #hipErrorNotInitialized, #hipErrorInvalidValue.\n"]
    pub fn hipExtLaunchKernel(
        function_address: *const ::libc::c_void,
        numBlocks: dim3,
        dimBlocks: dim3,
        args: *mut *mut ::libc::c_void,
        sharedMemBytes: usize,
        stream: hipStream_t,
        startEvent: hipEvent_t,
        stopEvent: hipEvent_t,
        flags: ::libc::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Creates a texture object.\n\n @param [out] pTexObject  pointer to the texture object to create\n @param [in] pResDesc  pointer to resource descriptor\n @param [in] pTexDesc  pointer to texture descriptor\n @param [in] pResViewDesc  pointer to resource view descriptor\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported, #hipErrorOutOfMemory\n\n @note 3D liner filter isn't supported on GFX90A boards, on which the API @p hipCreateTextureObject will\n return hipErrorNotSupported.\n"]
    pub fn hipCreateTextureObject(
        pTexObject: *mut hipTextureObject_t,
        pResDesc: *const hipResourceDesc,
        pTexDesc: *const hipTextureDesc,
        pResViewDesc: *const hipResourceViewDesc,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Destroys a texture object.\n\n @param [in] textureObject  texture object to destroy\n\n @returns #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipDestroyTextureObject(textureObject: hipTextureObject_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets the channel descriptor in an array.\n\n @param [in] desc  pointer to channel format descriptor\n @param [out] array  memory array on the device\n\n @returns #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipGetChannelDesc(
        desc: *mut hipChannelFormatDesc,
        array: hipArray_const_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets resource descriptor for the texture object.\n\n @param [out] pResDesc  pointer to resource descriptor\n @param [in] textureObject  texture object\n\n @returns #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipGetTextureObjectResourceDesc(
        pResDesc: *mut hipResourceDesc,
        textureObject: hipTextureObject_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets resource view descriptor for the texture object.\n\n @param [out] pResViewDesc  pointer to resource view descriptor\n @param [in] textureObject  texture object\n\n @returns #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipGetTextureObjectResourceViewDesc(
        pResViewDesc: *mut hipResourceViewDesc,
        textureObject: hipTextureObject_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets texture descriptor for the texture object.\n\n @param [out] pTexDesc  pointer to texture descriptor\n @param [in] textureObject  texture object\n\n @returns #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipGetTextureObjectTextureDesc(
        pTexDesc: *mut hipTextureDesc,
        textureObject: hipTextureObject_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Creates a texture object.\n\n @param [out] pTexObject  pointer to texture object to create\n @param [in] pResDesc  pointer to resource descriptor\n @param [in] pTexDesc  pointer to texture descriptor\n @param [in] pResViewDesc  pointer to resource view descriptor\n\n @returns #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipTexObjectCreate(
        pTexObject: *mut hipTextureObject_t,
        pResDesc: *const HIP_RESOURCE_DESC,
        pTexDesc: *const HIP_TEXTURE_DESC,
        pResViewDesc: *const HIP_RESOURCE_VIEW_DESC,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Destroys a texture object.\n\n @param [in] texObject  texture object to destroy\n\n @returns #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipTexObjectDestroy(texObject: hipTextureObject_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets resource descriptor of a texture object.\n\n @param [out] pResDesc  pointer to resource descriptor\n @param [in] texObject  texture object\n\n @returns #hipSuccess, #hipErrorNotSupported, #hipErrorInvalidValue\n"]
    pub fn hipTexObjectGetResourceDesc(
        pResDesc: *mut HIP_RESOURCE_DESC,
        texObject: hipTextureObject_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets resource view descriptor of a texture object.\n\n @param [out] pResViewDesc  pointer to resource view descriptor\n @param [in] texObject  texture object\n\n @returns #hipSuccess, #hipErrorNotSupported, #hipErrorInvalidValue\n"]
    pub fn hipTexObjectGetResourceViewDesc(
        pResViewDesc: *mut HIP_RESOURCE_VIEW_DESC,
        texObject: hipTextureObject_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets texture descriptor of a texture object.\n\n @param [out] pTexDesc  pointer to texture descriptor\n @param [in] texObject  texture object\n\n @returns #hipSuccess, #hipErrorNotSupported, #hipErrorInvalidValue\n"]
    pub fn hipTexObjectGetTextureDesc(
        pTexDesc: *mut HIP_TEXTURE_DESC,
        texObject: hipTextureObject_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Allocate a mipmapped array on the device.\n\n @param[out] mipmappedArray  - Pointer to allocated mipmapped array in device memory\n @param[in]  desc            - Requested channel format\n @param[in]  extent          - Requested allocation size (width field in elements)\n @param[in]  numLevels       - Number of mipmap levels to allocate\n @param[in]  flags           - Flags for extensions\n\n @return #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryAllocation\n\n @note  This API is implemented on Linux and is under development on Microsoft Windows.\n"]
    pub fn hipMallocMipmappedArray(
        mipmappedArray: *mut hipMipmappedArray_t,
        desc: *const hipChannelFormatDesc,
        extent: hipExtent,
        numLevels: ::libc::c_uint,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Frees a mipmapped array on the device.\n\n @param[in] mipmappedArray - Pointer to mipmapped array to free\n\n @return #hipSuccess, #hipErrorInvalidValue\n\n @note  This API is implemented on Linux and is under development on Microsoft Windows.\n"]
    pub fn hipFreeMipmappedArray(mipmappedArray: hipMipmappedArray_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets a mipmap level of a HIP mipmapped array.\n\n @param[out] levelArray     - Returned mipmap level HIP array\n @param[in]  mipmappedArray - HIP mipmapped array\n @param[in]  level          - Mipmap level\n\n @return #hipSuccess, #hipErrorInvalidValue\n\n @note  This API is implemented on Linux and is under development on Microsoft Windows.\n"]
    pub fn hipGetMipmappedArrayLevel(
        levelArray: *mut hipArray_t,
        mipmappedArray: hipMipmappedArray_const_t,
        level: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Create a mipmapped array.\n\n @param [out] pHandle  pointer to mipmapped array\n @param [in] pMipmappedArrayDesc  mipmapped array descriptor\n @param [in] numMipmapLevels  mipmap level\n\n @returns #hipSuccess, #hipErrorNotSupported, #hipErrorInvalidValue\n\n @note  This API is implemented on Linux and is under development on Microsoft Windows."]
    pub fn hipMipmappedArrayCreate(
        pHandle: *mut hipMipmappedArray_t,
        pMipmappedArrayDesc: *mut HIP_ARRAY3D_DESCRIPTOR,
        numMipmapLevels: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Destroy a mipmapped array.\n\n @param [out] hMipmappedArray  pointer to mipmapped array to destroy\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @note  This API is implemented on Linux and is under development on Microsoft Windows.\n"]
    pub fn hipMipmappedArrayDestroy(hMipmappedArray: hipMipmappedArray_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Get a mipmapped array on a mipmapped level.\n\n @param [in] pLevelArray Pointer of array\n @param [out] hMipMappedArray Pointer of mipmapped array on the requested mipmap level\n @param [out] level  Mipmap level\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @note  This API is implemented on Linux and is under development on Microsoft Windows.\n"]
    pub fn hipMipmappedArrayGetLevel(
        pLevelArray: *mut hipArray_t,
        hMipMappedArray: hipMipmappedArray_t,
        level: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief  Binds a mipmapped array to a texture [Deprecated]\n\n @param [in] tex  pointer to the texture reference to bind\n @param [in] mipmappedArray memory mipmapped array on the device\n @param [in] desc  opointer to the channel format\n\n @returns #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipBindTextureToMipmappedArray(
        tex: *const textureReference,
        mipmappedArray: hipMipmappedArray_const_t,
        desc: *const hipChannelFormatDesc,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets the texture reference related with the symbol [Deprecated]\n\n @param [out] texref  texture reference\n @param [in] symbol  pointer to the symbol related with the texture for the reference\n\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is deprecated.\n"]
    pub fn hipGetTextureReference(
        texref: *mut *const textureReference,
        symbol: *const ::libc::c_void,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets the border color used by a texture reference [Deprecated]\n\n @param [out] pBorderColor  Returned Type and Value of RGBA color.\n @param [in] texRef  Texture reference.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is deprecated.\n"]
    pub fn hipTexRefGetBorderColor(
        pBorderColor: *mut f32,
        texRef: *const textureReference,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets the array bound to a texture reference [Deprecated]\n\n\n @param [in] pArray  Returned array.\n @param [in] texRef  texture reference.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is deprecated.\n"]
    pub fn hipTexRefGetArray(
        pArray: *mut hipArray_t,
        texRef: *const textureReference,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets address mode for a texture reference [Deprecated]\n\n @param [in] texRef  texture reference.\n @param [in] dim  Dimension of the texture.\n @param [in] am  Value of the texture address mode.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is deprecated.\n"]
    pub fn hipTexRefSetAddressMode(
        texRef: *mut textureReference,
        dim: ::libc::c_int,
        am: hipTextureAddressMode,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Binds an array as a texture reference [Deprecated]\n\n @param [in] tex  Pointer texture reference.\n @param [in] array  Array to bind.\n @param [in] flags  Flags should be set as HIP_TRSA_OVERRIDE_FORMAT, as a valid value.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefSetArray(
        tex: *mut textureReference,
        array: hipArray_const_t,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Set filter mode for a texture reference [Deprecated]\n\n @param [in] texRef  Pointer texture reference.\n @param [in] fm  Value of texture filter mode.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefSetFilterMode(
        texRef: *mut textureReference,
        fm: hipTextureFilterMode,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Set flags for a texture reference [Deprecated]\n\n @param [in] texRef  Pointer texture reference.\n @param [in] Flags  Value of flags.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefSetFlags(texRef: *mut textureReference, Flags: ::libc::c_uint) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Set format for a texture reference [Deprecated]\n\n @param [in] texRef  Pointer texture reference.\n @param [in] fmt  Value of format.\n @param [in] NumPackedComponents  Number of components per array.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefSetFormat(
        texRef: *mut textureReference,
        fmt: hipArray_Format,
        NumPackedComponents: ::libc::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Binds a memory area to a texture [Deprecated]\n\n @param [in] offset  Offset in bytes.\n @param [in] tex  Texture to bind.\n @param [in] devPtr  Pointer of memory on the device.\n @param [in] desc  Pointer of channel format descriptor.\n @param [in] size  Size of memory in bites.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipBindTexture(
        offset: *mut usize,
        tex: *const textureReference,
        devPtr: *const ::libc::c_void,
        desc: *const hipChannelFormatDesc,
        size: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Binds a 2D memory area to a texture [Deprecated]\n\n @param [in] offset  Offset in bytes.\n @param [in] tex  Texture to bind.\n @param [in] devPtr  Pointer of 2D memory area on the device.\n @param [in] desc  Pointer of channel format descriptor.\n @param [in] width  Width in texel units.\n @param [in] height  Height in texel units.\n @param [in] pitch  Pitch in bytes.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipBindTexture2D(
        offset: *mut usize,
        tex: *const textureReference,
        devPtr: *const ::libc::c_void,
        desc: *const hipChannelFormatDesc,
        width: usize,
        height: usize,
        pitch: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Binds a memory area to a texture [Deprecated]\n\n @param [in] tex  Pointer of texture reference.\n @param [in] array  Array to bind.\n @param [in] desc  Pointer of channel format descriptor.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipBindTextureToArray(
        tex: *const textureReference,
        array: hipArray_const_t,
        desc: *const hipChannelFormatDesc,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Get the offset of the alignment in a texture [Deprecated]\n\n @param [in] offset  Offset in bytes.\n @param [in] texref  Pointer of texture reference.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipGetTextureAlignmentOffset(
        offset: *mut usize,
        texref: *const textureReference,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Unbinds a texture [Deprecated]\n\n @param [in] tex  Texture to unbind.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipUnbindTexture(tex: *const textureReference) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets the address for a texture reference [Deprecated]\n\n @param [out] dev_ptr  Pointer of device address.\n @param [in] texRef  Pointer of texture reference.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefGetAddress(
        dev_ptr: *mut hipDeviceptr_t,
        texRef: *const textureReference,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets the address mode for a texture reference [Deprecated]\n\n @param [out] pam  Pointer of address mode.\n @param [in] texRef  Pointer of texture reference.\n @param [in] dim  Dimension.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefGetAddressMode(
        pam: *mut hipTextureAddressMode,
        texRef: *const textureReference,
        dim: ::libc::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets filter mode for a texture reference [Deprecated]\n\n @param [out] pfm  Pointer of filter mode.\n @param [in] texRef  Pointer of texture reference.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefGetFilterMode(
        pfm: *mut hipTextureFilterMode,
        texRef: *const textureReference,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets flags for a texture reference [Deprecated]\n\n @param [out] pFlags  Pointer of flags.\n @param [in] texRef  Pointer of texture reference.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefGetFlags(
        pFlags: *mut ::libc::c_uint,
        texRef: *const textureReference,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets texture format for a texture reference [Deprecated]\n\n @param [out] pFormat  Pointer of the format.\n @param [out] pNumChannels  Pointer of number of channels.\n @param [in] texRef  Pointer of texture reference.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefGetFormat(
        pFormat: *mut hipArray_Format,
        pNumChannels: *mut ::libc::c_int,
        texRef: *const textureReference,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets the maximum anisotropy for a texture reference [Deprecated]\n\n @param [out] pmaxAnsio  Pointer of the maximum anisotropy.\n @param [in] texRef  Pointer of texture reference.\n\n @returns #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefGetMaxAnisotropy(
        pmaxAnsio: *mut ::libc::c_int,
        texRef: *const textureReference,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets the mipmap filter mode for a texture reference [Deprecated]\n\n @param [out] pfm  Pointer of the mipmap filter mode.\n @param [in] texRef  Pointer of texture reference.\n\n @returns #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefGetMipmapFilterMode(
        pfm: *mut hipTextureFilterMode,
        texRef: *const textureReference,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets the mipmap level bias for a texture reference [Deprecated]\n\n @param [out] pbias  Pointer of the mipmap level bias.\n @param [in] texRef  Pointer of texture reference.\n\n @returns #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefGetMipmapLevelBias(
        pbias: *mut f32,
        texRef: *const textureReference,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets the minimum and maximum mipmap level clamps for a texture reference [Deprecated]\n\n @param [out] pminMipmapLevelClamp  Pointer of the minimum mipmap level clamp.\n @param [out] pmaxMipmapLevelClamp  Pointer of the maximum mipmap level clamp.\n @param [in] texRef  Pointer of texture reference.\n\n @returns #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefGetMipmapLevelClamp(
        pminMipmapLevelClamp: *mut f32,
        pmaxMipmapLevelClamp: *mut f32,
        texRef: *const textureReference,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets the mipmapped array bound to a texture reference [Deprecated]\n\n @param [out] pArray  Pointer of the mipmapped array.\n @param [in] texRef  Pointer of texture reference.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefGetMipMappedArray(
        pArray: *mut hipMipmappedArray_t,
        texRef: *const textureReference,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets an bound address for a texture reference [Deprecated]\n\n @param [out] ByteOffset  Pointer of the offset in bytes.\n @param [in] texRef  Pointer of texture reference.\n @param [in] dptr  Pointer of device address to bind.\n @param [in] bytes  Size in bytes.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefSetAddress(
        ByteOffset: *mut usize,
        texRef: *mut textureReference,
        dptr: hipDeviceptr_t,
        bytes: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Set a bind an address as a 2D texture reference [Deprecated]\n\n @param [in] texRef  Pointer of texture reference.\n @param [in] desc  Pointer of array descriptor.\n @param [in] dptr  Pointer of device address to bind.\n @param [in] Pitch  Pitch in bytes.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefSetAddress2D(
        texRef: *mut textureReference,
        desc: *const HIP_ARRAY_DESCRIPTOR,
        dptr: hipDeviceptr_t,
        Pitch: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets the maximum anisotropy for a texture reference [Deprecated]\n\n @param [in] texRef  Pointer of texture reference.\n @param [out] maxAniso  Value of the maximum anisotropy.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefSetMaxAnisotropy(
        texRef: *mut textureReference,
        maxAniso: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets border color for a texture reference [Deprecated]\n\n @param [in] texRef  Pointer of texture reference.\n @param [in] pBorderColor  Pointer of border color.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefSetBorderColor(
        texRef: *mut textureReference,
        pBorderColor: *mut f32,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets mipmap filter mode for a texture reference [Deprecated]\n\n @param [in] texRef  Pointer of texture reference.\n @param [in] fm  Value of filter mode.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefSetMipmapFilterMode(
        texRef: *mut textureReference,
        fm: hipTextureFilterMode,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets mipmap level bias for a texture reference [Deprecated]\n\n @param [in] texRef  Pointer of texture reference.\n @param [in] bias  Value of mipmap bias.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefSetMipmapLevelBias(texRef: *mut textureReference, bias: f32) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets mipmap level clamp for a texture reference [Deprecated]\n\n @param [in] texRef  Pointer of texture reference.\n @param [in] minMipMapLevelClamp  Value of minimum mipmap level clamp.\n @param [in] maxMipMapLevelClamp  Value of maximum mipmap level clamp.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefSetMipmapLevelClamp(
        texRef: *mut textureReference,
        minMipMapLevelClamp: f32,
        maxMipMapLevelClamp: f32,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Binds mipmapped array to a texture reference [Deprecated]\n\n @param [in] texRef  Pointer of texture reference to bind.\n @param [in] mipmappedArray  Pointer of mipmapped array to bind.\n @param [in] Flags  Flags should be set as HIP_TRSA_OVERRIDE_FORMAT, as a valid value.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning This API is deprecated.\n"]
    pub fn hipTexRefSetMipmappedArray(
        texRef: *mut textureReference,
        mipmappedArray: *mut hipMipmappedArray,
        Flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @defgroup Callback Callback Activity APIs\n  @{\n  This section describes the callback/Activity of HIP runtime API.\n/\n/**\n @brief Returns HIP API name by ID.\n\n @param [in] id ID of HIP API\n\n @returns #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipApiName(id: u32) -> *const ::libc::c_char;
}
extern "C" {
    #[doc = " @brief Returns kernel name reference by function name.\n\n @param [in] f Name of function\n\n @returns #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipKernelNameRef(f: hipFunction_t) -> *const ::libc::c_char;
}
extern "C" {
    #[doc = " @brief Retrives kernel for a given host pointer, unless stated otherwise.\n\n @param [in] hostFunction Pointer of host function.\n @param [in] stream Stream the kernel is executed on.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipKernelNameRefByPtr(
        hostFunction: *const ::libc::c_void,
        stream: hipStream_t,
    ) -> *const ::libc::c_char;
}
extern "C" {
    #[doc = " @brief Returns device ID on the stream.\n\n @param [in] stream Stream of device executed on.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipGetStreamDeviceId(stream: hipStream_t) -> ::libc::c_int;
}
extern "C" {
    #[doc = " @brief Begins graph capture on a stream.\n\n @param [in] stream - Stream to initiate capture.\n @param [in] mode - Controls the interaction of this capture sequence with other API calls that\n are not safe.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues.\n"]
    pub fn hipStreamBeginCapture(stream: hipStream_t, mode: hipStreamCaptureMode) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Begins graph capture on a stream to an existing graph.\n\n @param [in] stream - Stream to initiate capture.\n @param [in] graph - Graph to capture into.\n @param [in] dependencies - Dependencies of the first node captured in the stream. Can be NULL if\n numDependencies is 0.\n @param [in] dependencyData - Optional array of data associated with each dependency.\n @param [in] numDependencies - Number of dependencies.\n @param [in] mode - Controls the interaction of this capture sequence with other API calls that\nare not safe.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning param \"const hipGraphEdgeData* dependencyData\" is currently not supported and has to be\npassed as nullptr. This API is marked as beta, meaning, while this is feature complete, it is still\nopen to changes and may have outstanding issues."]
    pub fn hipStreamBeginCaptureToGraph(
        stream: hipStream_t,
        graph: hipGraph_t,
        dependencies: *const hipGraphNode_t,
        dependencyData: *const hipGraphEdgeData,
        numDependencies: usize,
        mode: hipStreamCaptureMode,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Ends capture on a stream, returning the captured graph.\n\n @param [in] stream - Stream to end capture.\n @param [out] pGraph - Captured graph.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues.\n"]
    pub fn hipStreamEndCapture(stream: hipStream_t, pGraph: *mut hipGraph_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Get capture status of a stream.\n\n @param [in] stream - Stream of which to get capture status from.\n @param [out] pCaptureStatus - Returns current capture status.\n @param [out] pId - Unique capture ID.\n\n @returns #hipSuccess, #hipErrorStreamCaptureImplicit\n\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues.\n"]
    pub fn hipStreamGetCaptureInfo(
        stream: hipStream_t,
        pCaptureStatus: *mut hipStreamCaptureStatus,
        pId: *mut ::libc::c_ulonglong,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Get stream's capture state\n\n @param [in] stream - Stream of which to get capture status from.\n @param [out] captureStatus_out - Returns current capture status.\n @param [out] id_out - Unique capture ID.\n @param [out] graph_out - Returns the graph being captured into.\n @param [out] dependencies_out - Pointer to an array of nodes representing the graphs dependencies.\n @param [out] numDependencies_out - Returns size of the array returned in dependencies_out.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorStreamCaptureImplicit\n\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues.\n"]
    pub fn hipStreamGetCaptureInfo_v2(
        stream: hipStream_t,
        captureStatus_out: *mut hipStreamCaptureStatus,
        id_out: *mut ::libc::c_ulonglong,
        graph_out: *mut hipGraph_t,
        dependencies_out: *mut *const hipGraphNode_t,
        numDependencies_out: *mut usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Get stream's capture state\n\n @param [in] stream - Stream of which to get capture status from.\n @param [out] pCaptureStatus - Returns current capture status.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorStreamCaptureImplicit\n\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues.\n"]
    pub fn hipStreamIsCapturing(
        stream: hipStream_t,
        pCaptureStatus: *mut hipStreamCaptureStatus,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Update the set of dependencies in a capturing stream\n\n @param [in] stream  Stream that is being captured.\n @param [in] dependencies  Pointer to an array of nodes to add/replace.\n @param [in] numDependencies  Size of the dependencies array.\n @param [in] flags  Flag to update dependency set. Should be one of the values\n in enum #hipStreamUpdateCaptureDependenciesFlags.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorIllegalState\n\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues.\n"]
    pub fn hipStreamUpdateCaptureDependencies(
        stream: hipStream_t,
        dependencies: *mut hipGraphNode_t,
        numDependencies: usize,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Swaps the stream capture mode of a thread.\n\n @param [in] mode - Pointer to mode value to swap with the current mode.\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues.\n"]
    pub fn hipThreadExchangeStreamCaptureMode(mode: *mut hipStreamCaptureMode) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Creates a graph\n\n @param [out] pGraph - pointer to graph to create.\n @param [in] flags - flags for graph creation, must be 0.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryAllocation\n\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues.\n"]
    pub fn hipGraphCreate(pGraph: *mut hipGraph_t, flags: ::libc::c_uint) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Destroys a graph\n\n @param [in] graph - instance of graph to destroy.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues.\n"]
    pub fn hipGraphDestroy(graph: hipGraph_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Adds dependency edges to a graph.\n\n @param [in] graph - Instance of the graph to add dependencies to.\n @param [in] from - Pointer to the graph nodes with dependencies to add from.\n @param [in] to - Pointer to the graph nodes to add dependencies to.\n @param [in] numDependencies - Number of dependencies to add.\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues.\n"]
    pub fn hipGraphAddDependencies(
        graph: hipGraph_t,
        from: *const hipGraphNode_t,
        to: *const hipGraphNode_t,
        numDependencies: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Removes dependency edges from a graph.\n\n @param [in] graph - Instance of the graph to remove dependencies from.\n @param [in] from - Array of nodes that provide the dependencies.\n @param [in] to - Array of dependent nodes.\n @param [in] numDependencies - Number of dependencies to remove.\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues.\n"]
    pub fn hipGraphRemoveDependencies(
        graph: hipGraph_t,
        from: *const hipGraphNode_t,
        to: *const hipGraphNode_t,
        numDependencies: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns a graph's dependency edges.\n\n @param [in] graph - Instance of the graph to get the edges from.\n @param [out] from - Pointer to the graph nodes to return edge endpoints.\n @param [out] to - Pointer to the graph nodes to return edge endpoints.\n @param [out] numEdges - Returns number of edges.\n @returns #hipSuccess, #hipErrorInvalidValue\n\n from and to may both be NULL, in which case this function only returns the number of edges in\n numEdges. Otherwise, numEdges entries will be filled in. If numEdges is higher than the actual\n number of edges, the remaining entries in from and to will be set to NULL, and the number of\n edges actually returned will be written to numEdges.\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues.\n"]
    pub fn hipGraphGetEdges(
        graph: hipGraph_t,
        from: *mut hipGraphNode_t,
        to: *mut hipGraphNode_t,
        numEdges: *mut usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns a graph's nodes.\n\n @param [in] graph - Instance of graph to get the nodes from.\n @param [out] nodes - Pointer to return the  graph nodes.\n @param [out] numNodes - Returns the number of graph nodes.\n @returns #hipSuccess, #hipErrorInvalidValue\n\n nodes may be NULL, in which case this function will return the number of nodes in numNodes.\n Otherwise, numNodes entries will be filled in. If numNodes is higher than the actual number of\n nodes, the remaining entries in nodes will be set to NULL, and the number of nodes actually\n obtained will be returned in numNodes.\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues.\n"]
    pub fn hipGraphGetNodes(
        graph: hipGraph_t,
        nodes: *mut hipGraphNode_t,
        numNodes: *mut usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns a graph's root nodes.\n\n @param [in] graph - Instance of the graph to get the nodes from.\n @param [out] pRootNodes - Pointer to return the graph's root nodes.\n @param [out] pNumRootNodes - Returns the number of graph's root nodes.\n @returns #hipSuccess, #hipErrorInvalidValue\n\n pRootNodes may be NULL, in which case this function will return the number of root nodes in\n pNumRootNodes. Otherwise, pNumRootNodes entries will be filled in. If pNumRootNodes is higher\n than the actual number of root nodes, the remaining entries in pRootNodes will be set to NULL,\n and the number of nodes actually obtained will be returned in pNumRootNodes.\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues.\n"]
    pub fn hipGraphGetRootNodes(
        graph: hipGraph_t,
        pRootNodes: *mut hipGraphNode_t,
        pNumRootNodes: *mut usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns a node's dependencies.\n\n @param [in] node - Graph node to get the dependencies from.\n @param [out] pDependencies - Pointer to return the dependencies.\n @param [out] pNumDependencies -  Returns the number of graph node dependencies.\n @returns #hipSuccess, #hipErrorInvalidValue\n\n pDependencies may be NULL, in which case this function will return the number of dependencies in\n pNumDependencies. Otherwise, pNumDependencies entries will be filled in. If pNumDependencies is\n higher than the actual number of dependencies, the remaining entries in pDependencies will be set\n to NULL, and the number of nodes actually obtained will be returned in pNumDependencies.\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues.\n"]
    pub fn hipGraphNodeGetDependencies(
        node: hipGraphNode_t,
        pDependencies: *mut hipGraphNode_t,
        pNumDependencies: *mut usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns a node's dependent nodes.\n\n @param [in] node - Graph node to get the dependent nodes from.\n @param [out] pDependentNodes - Pointer to return the graph dependent nodes.\n @param [out] pNumDependentNodes - Returns the number of graph node dependent nodes.\n @returns #hipSuccess, #hipErrorInvalidValue\n\n pDependentNodes may be NULL, in which case this function will return the number of dependent nodes\n in pNumDependentNodes. Otherwise, pNumDependentNodes entries will be filled in. If\n pNumDependentNodes is higher than the actual number of dependent nodes, the remaining entries in\n pDependentNodes will be set to NULL, and the number of nodes actually obtained will be returned\n in pNumDependentNodes.\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues.\n"]
    pub fn hipGraphNodeGetDependentNodes(
        node: hipGraphNode_t,
        pDependentNodes: *mut hipGraphNode_t,
        pNumDependentNodes: *mut usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns a node's type.\n\n @param [in] node - Node to get type of.\n @param [out] pType - Returns the node's type.\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues.\n"]
    pub fn hipGraphNodeGetType(node: hipGraphNode_t, pType: *mut hipGraphNodeType) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Remove a node from the graph.\n\n @param [in] node - graph node to remove\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues.\n"]
    pub fn hipGraphDestroyNode(node: hipGraphNode_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Clones a graph.\n\n @param [out] pGraphClone - Returns newly created cloned graph.\n @param [in] originalGraph - original graph to clone from.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryAllocation\n\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues.\n"]
    pub fn hipGraphClone(pGraphClone: *mut hipGraph_t, originalGraph: hipGraph_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Finds a cloned version of a node.\n\n @param [out] pNode - Returns the cloned node.\n @param [in] originalNode - original node handle.\n @param [in] clonedGraph - Cloned graph to query.\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues.\n"]
    pub fn hipGraphNodeFindInClone(
        pNode: *mut hipGraphNode_t,
        originalNode: hipGraphNode_t,
        clonedGraph: hipGraph_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Creates an executable graph from a graph\n\n @param [out] pGraphExec - Pointer to instantiated executable graph.\n @param [in] graph - Instance of graph to instantiate.\n @param [out] pErrorNode - Pointer to error node. In case an error occured during\n graph instantiation, it could modify the corresponding node.\n @param [out] pLogBuffer - Pointer to log buffer.\n @param [out] bufferSize - Size of the log buffer.\n\n @returns #hipSuccess, #hipErrorOutOfMemory\n\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues.\n"]
    pub fn hipGraphInstantiate(
        pGraphExec: *mut hipGraphExec_t,
        graph: hipGraph_t,
        pErrorNode: *mut hipGraphNode_t,
        pLogBuffer: *mut ::libc::c_char,
        bufferSize: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Creates an executable graph from a graph.\n\n @param [out] pGraphExec - Pointer to instantiated executable graph.\n @param [in] graph - Instance of graph to instantiate.\n @param [in] flags - Flags to control instantiation.\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues. It does not support any of\n          flag and is behaving as hipGraphInstantiate."]
    pub fn hipGraphInstantiateWithFlags(
        pGraphExec: *mut hipGraphExec_t,
        graph: hipGraph_t,
        flags: ::libc::c_ulonglong,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Creates an executable graph from a graph.\n\n @param [out] pGraphExec - Pointer to instantiated executable graph.\n @param [in] graph - Instance of graph to instantiate.\n @param [in] instantiateParams - Graph instantiation Params\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphInstantiateWithParams(
        pGraphExec: *mut hipGraphExec_t,
        graph: hipGraph_t,
        instantiateParams: *mut hipGraphInstantiateParams,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Launches an executable graph in the specified stream.\n\n @param [in] graphExec - Instance of executable graph to launch.\n @param [in] stream - Instance of stream in which to launch executable graph.\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphLaunch(graphExec: hipGraphExec_t, stream: hipStream_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Uploads an executable graph to a stream\n\n @param [in] graphExec - Instance of executable graph to be uploaded.\n @param [in] stream - Instance of stream to which the executable graph is uploaded to.\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphUpload(graphExec: hipGraphExec_t, stream: hipStream_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Creates a kernel execution node and adds it to a graph.\n\n @param [out] pGraphNode - Pointer to kernel graph node that is created.\n @param [in] graph - Instance of graph to add the created node to.\n @param [in] pDependencies - Pointer to the dependencies on the kernel execution node.\n @param [in] numDependencies - Number of dependencies.\n @param [in] nodeParams - Pointer to the node parameters.\n @returns #hipSuccess, #hipErrorInvalidValue.\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphAddNode(
        pGraphNode: *mut hipGraphNode_t,
        graph: hipGraph_t,
        pDependencies: *const hipGraphNode_t,
        numDependencies: usize,
        nodeParams: *mut hipGraphNodeParams,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Return the flags of an executable graph.\n\n @param [in] graphExec - Executable graph to get the flags from.\n @param [out] flags - Flags used to instantiate this executable graph.\n @returns #hipSuccess, #hipErrorInvalidValue.\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphExecGetFlags(
        graphExec: hipGraphExec_t,
        flags: *mut ::libc::c_ulonglong,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Updates parameters of a graph's node.\n\n @param [in] node - Instance of the node to set parameters for.\n @param [in] nodeParams - Pointer to the parameters to be set.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidDeviceFunction, #hipErrorNotSupported.\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphNodeSetParams(
        node: hipGraphNode_t,
        nodeParams: *mut hipGraphNodeParams,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Updates parameters of an executable graph's node.\n\n @param [in] graphExec - Instance of the executable graph.\n @param [in] node - Instance of the node to set parameters to.\n @param [in] nodeParams - Pointer to the parameters to be set.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidDeviceFunction, #hipErrorNotSupported.\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphExecNodeSetParams(
        graphExec: hipGraphExec_t,
        node: hipGraphNode_t,
        nodeParams: *mut hipGraphNodeParams,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Destroys an executable graph\n\n @param [in] graphExec - Instance of executable graph to destroy.\n\n @returns #hipSuccess.\n\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphExecDestroy(graphExec: hipGraphExec_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Check whether an executable graph can be updated with a graph and perform the update if  *\n possible.\n\n @param [in] hGraphExec - instance of executable graph to update.\n @param [in] hGraph - graph that contains the updated parameters.\n @param [in] hErrorNode_out -  node which caused the permissibility check to forbid the update.\n @param [in] updateResult_out - Return code whether the graph update was performed.\n @returns #hipSuccess, #hipErrorGraphExecUpdateFailure\n\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphExecUpdate(
        hGraphExec: hipGraphExec_t,
        hGraph: hipGraph_t,
        hErrorNode_out: *mut hipGraphNode_t,
        updateResult_out: *mut hipGraphExecUpdateResult,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Creates a kernel execution node and adds it to a graph.\n\n @param [out] pGraphNode - Pointer to graph node that is created\n @param [in] graph - Instance of graph to add the created node to.\n @param [in] pDependencies - Pointer to the dependencies of the kernel execution node.\n @param [in] numDependencies - The number of the dependencies.\n @param [in] pNodeParams - Pointer to the parameters of the kernel execution node.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidDeviceFunction\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphAddKernelNode(
        pGraphNode: *mut hipGraphNode_t,
        graph: hipGraph_t,
        pDependencies: *const hipGraphNode_t,
        numDependencies: usize,
        pNodeParams: *const hipKernelNodeParams,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets kernel node's parameters.\n\n @param [in] node - instance of the node to get parameters from.\n @param [out] pNodeParams - pointer to the parameters\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphKernelNodeGetParams(
        node: hipGraphNode_t,
        pNodeParams: *mut hipKernelNodeParams,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets a kernel node's parameters.\n\n @param [in] node - Instance of the node to set parameters of.\n @param [in] pNodeParams - const pointer to the parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphKernelNodeSetParams(
        node: hipGraphNode_t,
        pNodeParams: *const hipKernelNodeParams,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets the parameters for a kernel node in the given graphExec.\n\n @param [in] hGraphExec - Instance of the executable graph with the node.\n @param [in] node - Instance of the node to set parameters of.\n @param [in] pNodeParams - const pointer to the kernel node parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphExecKernelNodeSetParams(
        hGraphExec: hipGraphExec_t,
        node: hipGraphNode_t,
        pNodeParams: *const hipKernelNodeParams,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Creates a memcpy node and adds it to a graph.\n\n @param [out] phGraphNode - Pointer to graph node that is created.\n @param [in] hGraph - Instance of graph to add the created node to.\n @param [in] dependencies - const pointer to the dependencies of the memcpy execution node.\n @param [in] numDependencies - The number of dependencies.\n @param [in] copyParams - const pointer to the parameters for the memory copy.\n @param [in] ctx - context related to current device.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipDrvGraphAddMemcpyNode(
        phGraphNode: *mut hipGraphNode_t,
        hGraph: hipGraph_t,
        dependencies: *const hipGraphNode_t,
        numDependencies: usize,
        copyParams: *const HIP_MEMCPY3D,
        ctx: hipCtx_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Creates a memcpy node and adds it to a graph.\n\n @param [out] pGraphNode - Pointer to graph node that is created.\n @param [in] graph - Instance of graph to add the created node to.\n @param [in] pDependencies - const pointer to the dependencies of the memcpy execution node.\n @param [in] numDependencies - The number of dependencies.\n @param [in] pCopyParams - const pointer to the parameters for the memory copy.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphAddMemcpyNode(
        pGraphNode: *mut hipGraphNode_t,
        graph: hipGraph_t,
        pDependencies: *const hipGraphNode_t,
        numDependencies: usize,
        pCopyParams: *const hipMemcpy3DParms,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets a memcpy node's parameters.\n\n @param [in] node - instance of the node to get parameters from.\n @param [out] pNodeParams - pointer to the parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphMemcpyNodeGetParams(
        node: hipGraphNode_t,
        pNodeParams: *mut hipMemcpy3DParms,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets a memcpy node's parameters.\n\n @param [in] node - instance of the node to set parameters to.\n @param [in] pNodeParams - const pointer to the parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphMemcpyNodeSetParams(
        node: hipGraphNode_t,
        pNodeParams: *const hipMemcpy3DParms,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets a node's attribute.\n\n @param [in] hNode - Instance of the node to set parameters of.\n @param [in] attr - The attribute type to be set.\n @param [in] value - const pointer to the parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphKernelNodeSetAttribute(
        hNode: hipGraphNode_t,
        attr: hipLaunchAttributeID,
        value: *const hipLaunchAttributeValue,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets a node's attribute.\n\n @param [in] hNode - Instance of the node to set parameters of.\n @param [in] attr - The attribute type to be set.\n @param [in] value - const pointer to the parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphKernelNodeGetAttribute(
        hNode: hipGraphNode_t,
        attr: hipLaunchAttributeID,
        value: *mut hipLaunchAttributeValue,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets the parameters of a memcpy node in the given graphExec.\n\n @param [in] hGraphExec - Instance of the executable graph with the node.\n @param [in] node - Instance of the node to set parameters of.\n @param [in] pNodeParams - const pointer to the kernel node parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphExecMemcpyNodeSetParams(
        hGraphExec: hipGraphExec_t,
        node: hipGraphNode_t,
        pNodeParams: *mut hipMemcpy3DParms,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Creates a 1D memcpy node and adds it to a graph.\n\n @param [out] pGraphNode - Pointer to graph node that is created.\n @param [in] graph - Instance of graph to add the created node to.\n @param [in] pDependencies - const pointer to the dependencies of the memcpy execution node.\n @param [in] numDependencies - The number of dependencies.\n @param [in] dst - Pointer to memory address of the destination.\n @param [in] src - Pointer to memory address of the source.\n @param [in] count - Size of the memory to copy.\n @param [in] kind - Type of memory copy.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphAddMemcpyNode1D(
        pGraphNode: *mut hipGraphNode_t,
        graph: hipGraph_t,
        pDependencies: *const hipGraphNode_t,
        numDependencies: usize,
        dst: *mut ::libc::c_void,
        src: *const ::libc::c_void,
        count: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets a memcpy node's parameters to perform a 1-dimensional copy.\n\n @param [in] node - Instance of the node to set parameters of.\n @param [in] dst - Pointer to memory address of the destination.\n @param [in] src - Pointer to memory address of the source.\n @param [in] count - Size of the memory to copy.\n @param [in] kind - Type of memory copy.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphMemcpyNodeSetParams1D(
        node: hipGraphNode_t,
        dst: *mut ::libc::c_void,
        src: *const ::libc::c_void,
        count: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets the parameters for a memcpy node in the given graphExec to perform a 1-dimensional\n copy.\n\n @param [in] hGraphExec - Instance of the executable graph with the node.\n @param [in] node - Instance of the node to set parameters of.\n @param [in] dst - Pointer to memory address of the destination.\n @param [in] src - Pointer to memory address of the source.\n @param [in] count - Size of the memory to copy.\n @param [in] kind - Type of memory copy.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphExecMemcpyNodeSetParams1D(
        hGraphExec: hipGraphExec_t,
        node: hipGraphNode_t,
        dst: *mut ::libc::c_void,
        src: *const ::libc::c_void,
        count: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Creates a memcpy node to copy from a symbol on the device and adds it to a graph.\n\n @param [out] pGraphNode - Pointer to graph node that is created.\n @param [in] graph - Instance of graph to add the created node to.\n @param [in] pDependencies - const pointer to the dependencies of the memcpy execution node.\n @param [in] numDependencies - Number of the dependencies.\n @param [in] dst - Pointer to memory address of the destination.\n @param [in] symbol - Device symbol address.\n @param [in] count - Size of the memory to copy.\n @param [in] offset - Offset from start of symbol in bytes.\n @param [in] kind - Type of memory copy.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphAddMemcpyNodeFromSymbol(
        pGraphNode: *mut hipGraphNode_t,
        graph: hipGraph_t,
        pDependencies: *const hipGraphNode_t,
        numDependencies: usize,
        dst: *mut ::libc::c_void,
        symbol: *const ::libc::c_void,
        count: usize,
        offset: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets a memcpy node's parameters to copy from a symbol on the device.\n\n @param [in] node - Instance of the node to set parameters of.\n @param [in] dst - Pointer to memory address of the destination.\n @param [in] symbol - Device symbol address.\n @param [in] count - Size of the memory to copy.\n @param [in] offset - Offset from start of symbol in bytes.\n @param [in] kind - Type of memory copy.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphMemcpyNodeSetParamsFromSymbol(
        node: hipGraphNode_t,
        dst: *mut ::libc::c_void,
        symbol: *const ::libc::c_void,
        count: usize,
        offset: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets the parameters for a memcpy node in the given graphExec to copy from a symbol on the\n * device.\n\n @param [in] hGraphExec - Instance of the executable graph with the node.\n @param [in] node - Instance of the node to set parameters of.\n @param [in] dst - Pointer to memory address of the destination.\n @param [in] symbol - Device symbol address.\n @param [in] count - Size of the memory to copy.\n @param [in] offset - Offset from start of symbol in bytes.\n @param [in] kind - Type of memory copy.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphExecMemcpyNodeSetParamsFromSymbol(
        hGraphExec: hipGraphExec_t,
        node: hipGraphNode_t,
        dst: *mut ::libc::c_void,
        symbol: *const ::libc::c_void,
        count: usize,
        offset: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Creates a memcpy node to copy to a symbol on the device and adds it to a graph.\n\n @param [out] pGraphNode - Pointer to graph node that is created.\n @param [in] graph - Instance of graph to add the created node to.\n @param [in] pDependencies - const pointer to the dependencies on the memcpy execution node.\n @param [in] numDependencies - Number of dependencies.\n @param [in] symbol - Device symbol address.\n @param [in] src - Pointer to memory address of the src.\n @param [in] count - Size of the memory to copy.\n @param [in] offset - Offset from start of symbol in bytes.\n @param [in] kind - Type of memory copy.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphAddMemcpyNodeToSymbol(
        pGraphNode: *mut hipGraphNode_t,
        graph: hipGraph_t,
        pDependencies: *const hipGraphNode_t,
        numDependencies: usize,
        symbol: *const ::libc::c_void,
        src: *const ::libc::c_void,
        count: usize,
        offset: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets a memcpy node's parameters to copy to a symbol on the device.\n\n @param [in] node - Instance of the node to set parameters of.\n @param [in] symbol - Device symbol address.\n @param [in] src - Pointer to memory address of the src.\n @param [in] count - Size of the memory to copy.\n @param [in] offset - Offset from start of symbol in bytes.\n @param [in] kind - Type of memory copy.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphMemcpyNodeSetParamsToSymbol(
        node: hipGraphNode_t,
        symbol: *const ::libc::c_void,
        src: *const ::libc::c_void,
        count: usize,
        offset: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets the parameters for a memcpy node in the given graphExec to copy to a symbol on the\n device.\n @param [in] hGraphExec - Instance of the executable graph with the node.\n @param [in] node - Instance of the node to set parameters of.\n @param [in] symbol - Device symbol address.\n @param [in] src - Pointer to memory address of the src.\n @param [in] count - Size of the memory to copy.\n @param [in] offset - Offset from start of symbol in bytes.\n @param [in] kind - Type of memory copy.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphExecMemcpyNodeSetParamsToSymbol(
        hGraphExec: hipGraphExec_t,
        node: hipGraphNode_t,
        symbol: *const ::libc::c_void,
        src: *const ::libc::c_void,
        count: usize,
        offset: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Creates a memset node and adds it to a graph.\n\n @param [out] pGraphNode - Pointer to graph node that is created.\n @param [in] graph - Instance of the graph to add the created node to.\n @param [in] pDependencies - const pointer to the dependencies on the memset execution node.\n @param [in] numDependencies - Number of dependencies.\n @param [in] pMemsetParams - const pointer to the parameters for the memory set.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphAddMemsetNode(
        pGraphNode: *mut hipGraphNode_t,
        graph: hipGraph_t,
        pDependencies: *const hipGraphNode_t,
        numDependencies: usize,
        pMemsetParams: *const hipMemsetParams,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets a memset node's parameters.\n\n @param [in] node - Instance of the node to get parameters of.\n @param [out] pNodeParams - Pointer to the parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphMemsetNodeGetParams(
        node: hipGraphNode_t,
        pNodeParams: *mut hipMemsetParams,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets a memset node's parameters.\n\n @param [in] node - Instance of the node to set parameters of.\n @param [in] pNodeParams - Pointer to the parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphMemsetNodeSetParams(
        node: hipGraphNode_t,
        pNodeParams: *const hipMemsetParams,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets the parameters for a memset node in the given graphExec.\n\n @param [in] hGraphExec - Instance of the executable graph with the node.\n @param [in] node - Instance of the node to set parameters of.\n @param [in] pNodeParams - Pointer to the parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphExecMemsetNodeSetParams(
        hGraphExec: hipGraphExec_t,
        node: hipGraphNode_t,
        pNodeParams: *const hipMemsetParams,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Creates a host execution node and adds it to a graph.\n\n @param [out] pGraphNode - Pointer to graph node that is created.\n @param [in] graph - Instance of the graph to add the created node to.\n @param [in] pDependencies - const pointer to the dependencies of the memset execution node.\n @param [in] numDependencies - Number of dependencies.\n @param [in] pNodeParams - Pointer to the parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphAddHostNode(
        pGraphNode: *mut hipGraphNode_t,
        graph: hipGraph_t,
        pDependencies: *const hipGraphNode_t,
        numDependencies: usize,
        pNodeParams: *const hipHostNodeParams,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns a host node's parameters.\n\n @param [in] node - Instance of the node to get parameters of.\n @param [out] pNodeParams - Pointer to the parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphHostNodeGetParams(
        node: hipGraphNode_t,
        pNodeParams: *mut hipHostNodeParams,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets a host node's parameters.\n\n @param [in] node - Instance of the node to set parameters of.\n @param [in] pNodeParams - Pointer to the parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphHostNodeSetParams(
        node: hipGraphNode_t,
        pNodeParams: *const hipHostNodeParams,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets the parameters for a host node in the given graphExec.\n\n @param [in] hGraphExec - Instance of the executable graph with the node.\n @param [in] node - Instance of the node to set parameters of.\n @param [in] pNodeParams - Pointer to the parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphExecHostNodeSetParams(
        hGraphExec: hipGraphExec_t,
        node: hipGraphNode_t,
        pNodeParams: *const hipHostNodeParams,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Creates a child graph node and adds it to a graph.\n\n @param [out] pGraphNode - Pointer to graph node that is created.\n @param [in] graph - Instance of the graph to add the created node.\n @param [in] pDependencies - const pointer to the dependencies of the memset execution node.\n @param [in] numDependencies - Number of dependencies.\n @param [in] childGraph - Graph to clone into this node\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphAddChildGraphNode(
        pGraphNode: *mut hipGraphNode_t,
        graph: hipGraph_t,
        pDependencies: *const hipGraphNode_t,
        numDependencies: usize,
        childGraph: hipGraph_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets a handle to the embedded graph of a child graph node.\n\n @param [in] node - Instance of the node to get child graph of.\n @param [out] pGraph - Pointer to get the graph.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphChildGraphNodeGetGraph(
        node: hipGraphNode_t,
        pGraph: *mut hipGraph_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Updates node parameters in the child graph node in the given graphExec.\n\n @param [in] hGraphExec - instance of the executable graph with the node.\n @param [in] node - node from the graph which was used to instantiate graphExec.\n @param [in] childGraph - child graph with updated parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphExecChildGraphNodeSetParams(
        hGraphExec: hipGraphExec_t,
        node: hipGraphNode_t,
        childGraph: hipGraph_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Creates an empty node and adds it to a graph.\n\n @param [out] pGraphNode - Pointer to graph node that is created.\n @param [in] graph - Instance of the graph the node is added to.\n @param [in] pDependencies - const pointer to the node dependencies.\n @param [in] numDependencies - Number of dependencies.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphAddEmptyNode(
        pGraphNode: *mut hipGraphNode_t,
        graph: hipGraph_t,
        pDependencies: *const hipGraphNode_t,
        numDependencies: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Creates an event record node and adds it to a graph.\n\n @param [out] pGraphNode - Pointer to graph node that is created.\n @param [in] graph - Instance of the graph the node is added to.\n @param [in] pDependencies - const pointer to the node dependencies.\n @param [in] numDependencies - Number of dependencies.\n @param [in] event - Event of the node.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphAddEventRecordNode(
        pGraphNode: *mut hipGraphNode_t,
        graph: hipGraph_t,
        pDependencies: *const hipGraphNode_t,
        numDependencies: usize,
        event: hipEvent_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns the event associated with an event record node.\n\n @param [in] node -  Instance of the node to get event of.\n @param [out] event_out - Pointer to return the event.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphEventRecordNodeGetEvent(
        node: hipGraphNode_t,
        event_out: *mut hipEvent_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets an event record node's event.\n\n @param [in] node - Instance of the node to set event to.\n @param [in] event - Pointer to the event.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphEventRecordNodeSetEvent(node: hipGraphNode_t, event: hipEvent_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets the event for an event record node in the given graphExec.\n\n @param [in] hGraphExec - instance of the executable graph with the node.\n @param [in] hNode - node from the graph which was used to instantiate graphExec.\n @param [in] event - pointer to the event.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphExecEventRecordNodeSetEvent(
        hGraphExec: hipGraphExec_t,
        hNode: hipGraphNode_t,
        event: hipEvent_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Creates an event wait node and adds it to a graph.\n\n @param [out] pGraphNode - Pointer to graph node that is created.\n @param [in] graph - Instance of the graph the node to be added.\n @param [in] pDependencies - const pointer to the node dependencies.\n @param [in] numDependencies - Number of dependencies.\n @param [in] event - Event for the node.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphAddEventWaitNode(
        pGraphNode: *mut hipGraphNode_t,
        graph: hipGraph_t,
        pDependencies: *const hipGraphNode_t,
        numDependencies: usize,
        event: hipEvent_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns the event associated with an event wait node.\n\n @param [in] node -  Instance of the node to get event of.\n @param [out] event_out - Pointer to return the event.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphEventWaitNodeGetEvent(
        node: hipGraphNode_t,
        event_out: *mut hipEvent_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets an event wait node's event.\n\n @param [in] node - Instance of the node to set event of.\n @param [in] event - Pointer to the event.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphEventWaitNodeSetEvent(node: hipGraphNode_t, event: hipEvent_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets the event for an event record node in the given graphExec.\n\n @param [in] hGraphExec - instance of the executable graph with the node.\n @param [in] hNode - node from the graph which was used to instantiate graphExec.\n @param [in] event - pointer to the event.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphExecEventWaitNodeSetEvent(
        hGraphExec: hipGraphExec_t,
        hNode: hipGraphNode_t,
        event: hipEvent_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Creates a memory allocation node and adds it to a graph\n\n @param [out] pGraphNode      - Pointer to the graph node to create and add to the graph\n @param [in] graph            - Instance of the graph node to be added\n @param [in] pDependencies    - Const pointer to the node dependencies\n @param [in] numDependencies  - The number of dependencies\n @param [in, out] pNodeParams - Node parameters for memory allocation, returns a pointer to the allocated memory.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphAddMemAllocNode(
        pGraphNode: *mut hipGraphNode_t,
        graph: hipGraph_t,
        pDependencies: *const hipGraphNode_t,
        numDependencies: usize,
        pNodeParams: *mut hipMemAllocNodeParams,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns parameters for memory allocation node\n\n @param [in] node         - Memory allocation node to query\n @param [out] pNodeParams - Parameters for the specified memory allocation node\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphMemAllocNodeGetParams(
        node: hipGraphNode_t,
        pNodeParams: *mut hipMemAllocNodeParams,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Creates a memory free node and adds it to a graph\n\n @param [out] pGraphNode      - Pointer to the graph node to create and add to the graph\n @param [in] graph            - Instance of the graph node to be added\n @param [in] pDependencies    - Const pointer to the node dependencies\n @param [in] numDependencies  - The number of dependencies\n @param [in] dev_ptr          - Pointer to the memory to be freed\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphAddMemFreeNode(
        pGraphNode: *mut hipGraphNode_t,
        graph: hipGraph_t,
        pDependencies: *const hipGraphNode_t,
        numDependencies: usize,
        dev_ptr: *mut ::libc::c_void,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns parameters for memory free node\n\n @param [in] node     - Memory free node to query\n @param [out] dev_ptr - Device pointer of the specified memory free node\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphMemFreeNodeGetParams(
        node: hipGraphNode_t,
        dev_ptr: *mut ::libc::c_void,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Get the mem attribute for graphs.\n\n @param [in] device - Device to get attributes from\n @param [in] attr - Attribute type to be queried\n @param [out] value - Value of the queried attribute\n @returns #hipSuccess, #hipErrorInvalidDevice\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipDeviceGetGraphMemAttribute(
        device: ::libc::c_int,
        attr: hipGraphMemAttributeType,
        value: *mut ::libc::c_void,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Set the mem attribute for graphs.\n\n @param [in] device - Device to set attribute of.\n @param [in] attr - Attribute type to be set.\n @param [in] value - Value of the attribute.\n @returns #hipSuccess, #hipErrorInvalidDevice\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipDeviceSetGraphMemAttribute(
        device: ::libc::c_int,
        attr: hipGraphMemAttributeType,
        value: *mut ::libc::c_void,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Free unused memory reserved for graphs on a specific device and return it back to the OS.\n\n @param [in] device - Device for which memory should be trimmed\n @returns #hipSuccess, #hipErrorInvalidDevice\n\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipDeviceGraphMemTrim(device: ::libc::c_int) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Create an instance of userObject to manage lifetime of a resource.\n\n @param [out] object_out - pointer to instace of userobj.\n @param [in] ptr - pointer to pass to destroy function.\n @param [in] destroy - destroy callback to remove resource.\n @param [in] initialRefcount - reference to resource.\n @param [in] flags - flags passed to API.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipUserObjectCreate(
        object_out: *mut hipUserObject_t,
        ptr: *mut ::libc::c_void,
        destroy: hipHostFn_t,
        initialRefcount: ::libc::c_uint,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Release number of references to resource.\n\n @param [in] object - pointer to instace of userobj.\n @param [in] count - reference to resource to be retained.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipUserObjectRelease(object: hipUserObject_t, count: ::libc::c_uint) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Retain number of references to resource.\n\n @param [in] object - pointer to instace of userobj.\n @param [in] count - reference to resource to be retained.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipUserObjectRetain(object: hipUserObject_t, count: ::libc::c_uint) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Retain user object for graphs.\n\n @param [in] graph - pointer to graph to retain the user object for.\n @param [in] object - pointer to instace of userobj.\n @param [in] count - reference to resource to be retained.\n @param [in] flags - flags passed to API.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphRetainUserObject(
        graph: hipGraph_t,
        object: hipUserObject_t,
        count: ::libc::c_uint,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Release user object from graphs.\n\n @param [in] graph - pointer to graph to retain the user object for.\n @param [in] object - pointer to instace of userobj.\n @param [in] count - reference to resource to be retained.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphReleaseUserObject(
        graph: hipGraph_t,
        object: hipUserObject_t,
        count: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Write a DOT file describing graph structure.\n\n @param [in] graph - graph object for which DOT file has to be generated.\n @param [in] path - path to write the DOT file.\n @param [in] flags - Flags from hipGraphDebugDotFlags to get additional node information.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorOperatingSystem\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphDebugDotPrint(
        graph: hipGraph_t,
        path: *const ::libc::c_char,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Copies attributes from source node to destination node.\n\n Copies attributes from source node to destination node.\n Both node must have the same context.\n\n @param [out] hDst - Destination node.\n @param [in] hSrc - Source node.\n For list of attributes see ::hipKernelNodeAttrID.\n\n @returns #hipSuccess, #hipErrorInvalidContext\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphKernelNodeCopyAttributes(
        hSrc: hipGraphNode_t,
        hDst: hipGraphNode_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Enables or disables the specified node in the given graphExec\n\n Sets hNode to be either enabled or disabled. Disabled nodes are functionally equivalent\n to empty nodes until they are reenabled. Existing node parameters are not affected by\n disabling/enabling the node.\n\n The node is identified by the corresponding hNode in the non-executable graph, from which the\n executable graph was instantiated.\n\n hNode must not have been removed from the original graph.\n\n @note Currently only kernel, memset and memcpy nodes are supported.\n\n @param [in] hGraphExec - The executable graph in which to set the specified node.\n @param [in] hNode      - Node from the graph from which graphExec was instantiated.\n @param [in] isEnabled  - Node is enabled if != 0, otherwise the node is disabled.\n\n @returns #hipSuccess, #hipErrorInvalidValue,\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphNodeSetEnabled(
        hGraphExec: hipGraphExec_t,
        hNode: hipGraphNode_t,
        isEnabled: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Query whether a node in the given graphExec is enabled\n\n Sets isEnabled to 1 if hNode is enabled, or 0 if it is disabled.\n\n The node is identified by the corresponding node in the non-executable graph, from which the\n executable graph was instantiated.\n\n hNode must not have been removed from the original graph.\n\n @note Currently only kernel, memset and memcpy nodes are supported.\n\n @param [in]  hGraphExec - The executable graph in which to set the specified node.\n @param [in]  hNode      - Node from the graph from which graphExec was instantiated.\n @param [out] isEnabled  - Location to return the enabled status of the node.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphNodeGetEnabled(
        hGraphExec: hipGraphExec_t,
        hNode: hipGraphNode_t,
        isEnabled: *mut ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Creates a external semaphor wait node and adds it to a graph.\n\n @param [out] pGraphNode - pointer to the graph node to create.\n @param [in] graph - instance of the graph to add the created node.\n @param [in] pDependencies - const pointer to the dependencies on the memset execution node.\n @param [in] numDependencies - the number of the dependencies.\n @param [in] nodeParams -pointer to the parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphAddExternalSemaphoresWaitNode(
        pGraphNode: *mut hipGraphNode_t,
        graph: hipGraph_t,
        pDependencies: *const hipGraphNode_t,
        numDependencies: usize,
        nodeParams: *const hipExternalSemaphoreWaitNodeParams,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Creates a external semaphor signal node and adds it to a graph.\n\n @param [out] pGraphNode - pointer to the graph node to create.\n @param [in] graph - instance of the graph to add the created node.\n @param [in] pDependencies - const pointer to the dependencies on the memset execution node.\n @param [in] numDependencies - the number of the dependencies.\n @param [in] nodeParams -pointer to the parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphAddExternalSemaphoresSignalNode(
        pGraphNode: *mut hipGraphNode_t,
        graph: hipGraph_t,
        pDependencies: *const hipGraphNode_t,
        numDependencies: usize,
        nodeParams: *const hipExternalSemaphoreSignalNodeParams,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Updates node parameters in the external semaphore signal node.\n\n @param [in]  hNode      - Node from the graph from which graphExec was instantiated.\n @param [in]  nodeParams  - Pointer to the params to be set.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphExternalSemaphoresSignalNodeSetParams(
        hNode: hipGraphNode_t,
        nodeParams: *const hipExternalSemaphoreSignalNodeParams,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Updates node parameters in the external semaphore wait node.\n\n @param [in]  hNode      - Node from the graph from which graphExec was instantiated.\n @param [in]  nodeParams  - Pointer to the params to be set.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphExternalSemaphoresWaitNodeSetParams(
        hNode: hipGraphNode_t,
        nodeParams: *const hipExternalSemaphoreWaitNodeParams,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns external semaphore signal node params.\n\n @param [in]   hNode       - Node from the graph from which graphExec was instantiated.\n @param [out]  params_out  - Pointer to params.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphExternalSemaphoresSignalNodeGetParams(
        hNode: hipGraphNode_t,
        params_out: *mut hipExternalSemaphoreSignalNodeParams,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns external semaphore wait node params.\n\n @param [in]   hNode       - Node from the graph from which graphExec was instantiated.\n @param [out]  params_out  - Pointer to params.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphExternalSemaphoresWaitNodeGetParams(
        hNode: hipGraphNode_t,
        params_out: *mut hipExternalSemaphoreWaitNodeParams,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Updates node parameters in the external semaphore signal node in the given graphExec.\n\n @param [in]  hGraphExec - The executable graph in which to set the specified node.\n @param [in]  hNode      - Node from the graph from which graphExec was instantiated.\n @param [in]  nodeParams  - Pointer to the params to be set.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphExecExternalSemaphoresSignalNodeSetParams(
        hGraphExec: hipGraphExec_t,
        hNode: hipGraphNode_t,
        nodeParams: *const hipExternalSemaphoreSignalNodeParams,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Updates node parameters in the external semaphore wait node in the given graphExec.\n\n @param [in]  hGraphExec - The executable graph in which to set the specified node.\n @param [in]  hNode      - Node from the graph from which graphExec was instantiated.\n @param [in]  nodeParams  - Pointer to the params to be set.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipGraphExecExternalSemaphoresWaitNodeSetParams(
        hGraphExec: hipGraphExec_t,
        hNode: hipGraphNode_t,
        nodeParams: *const hipExternalSemaphoreWaitNodeParams,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets a memcpy node's parameters.\n\n @param [in] hNode - instance of the node to get parameters from.\n @param [out] nodeParams - pointer to the parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipDrvGraphMemcpyNodeGetParams(
        hNode: hipGraphNode_t,
        nodeParams: *mut HIP_MEMCPY3D,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets a memcpy node's parameters.\n\n @param [in] hNode - instance of the node to Set parameters for.\n @param [out] nodeParams - pointer to the parameters.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipDrvGraphMemcpyNodeSetParams(
        hNode: hipGraphNode_t,
        nodeParams: *const HIP_MEMCPY3D,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Creates a memset node and adds it to a graph.\n\n @param [out] phGraphNode - pointer to graph node to create.\n @param [in] hGraph - instance of graph to add the created node to.\n @param [in] dependencies - const pointer to the dependencies on the memset execution node.\n @param [in] numDependencies - number of the dependencies.\n @param [in] memsetParams - const pointer to the parameters for the memory set.\n @param [in] ctx - cotext related to current device.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipDrvGraphAddMemsetNode(
        phGraphNode: *mut hipGraphNode_t,
        hGraph: hipGraph_t,
        dependencies: *const hipGraphNode_t,
        numDependencies: usize,
        memsetParams: *const HIP_MEMSET_NODE_PARAMS,
        ctx: hipCtx_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Creates a memory free node and adds it to a graph\n\n @param [out] phGraphNode - Pointer to the graph node to create and add to the graph\n @param [in]  hGraph - Instance of the graph the node to be added\n @param [in]  dependencies - Const pointer to the node dependencies\n @param [in]  numDependencies - The number of dependencies\n @param [in]  dptr - Pointer to the memory to be freed\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipDrvGraphAddMemFreeNode(
        phGraphNode: *mut hipGraphNode_t,
        hGraph: hipGraph_t,
        dependencies: *const hipGraphNode_t,
        numDependencies: usize,
        dptr: hipDeviceptr_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets the parameters for a memcpy node in the given graphExec.\n\n @param [in] hGraphExec - instance of the executable graph with the node.\n @param [in] hNode - instance of the node to set parameters to.\n @param [in] copyParams - const pointer to the memcpy node params.\n @param [in] ctx - cotext related to current device.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipDrvGraphExecMemcpyNodeSetParams(
        hGraphExec: hipGraphExec_t,
        hNode: hipGraphNode_t,
        copyParams: *const HIP_MEMCPY3D,
        ctx: hipCtx_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Sets the parameters for a memset node in the given graphExec.\n\n @param [in] hGraphExec - instance of the executable graph with the node.\n @param [in] hNode - instance of the node to set parameters to.\n @param [in] memsetParams - pointer to the parameters.\n @param [in] ctx - cotext related to current device.\n @returns #hipSuccess, #hipErrorInvalidValue\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues."]
    pub fn hipDrvGraphExecMemsetNodeSetParams(
        hGraphExec: hipGraphExec_t,
        hNode: hipGraphNode_t,
        memsetParams: *const HIP_MEMSET_NODE_PARAMS,
        ctx: hipCtx_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Frees an address range reservation made via hipMemAddressReserve\n\n @param [in] devPtr - starting address of the range.\n @param [in] size - size of the range.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues.\n\n @note  This API is implemented on Linux and is under development on Microsoft Windows."]
    pub fn hipMemAddressFree(devPtr: *mut ::libc::c_void, size: usize) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Reserves an address range\n\n @param [out] ptr - starting address of the reserved range.\n @param [in] size - size of the reservation.\n @param [in] alignment - alignment of the address.\n @param [in] addr - requested starting address of the range.\n @param [in] flags - currently unused, must be zero.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues.\n\n @note  This API is implemented on Linux and is under development on Microsoft Windows."]
    pub fn hipMemAddressReserve(
        ptr: *mut *mut ::libc::c_void,
        size: usize,
        alignment: usize,
        addr: *mut ::libc::c_void,
        flags: ::libc::c_ulonglong,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Creates a memory allocation described by the properties and size\n\n @param [out] handle - value of the returned handle.\n @param [in] size - size of the allocation.\n @param [in] prop - properties of the allocation.\n @param [in] flags - currently unused, must be zero.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues.\n\n @note  This API is implemented on Linux and is under development on Microsoft Windows."]
    pub fn hipMemCreate(
        handle: *mut hipMemGenericAllocationHandle_t,
        size: usize,
        prop: *const hipMemAllocationProp,
        flags: ::libc::c_ulonglong,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Exports an allocation to a requested shareable handle type.\n\n @param [out] shareableHandle - value of the returned handle.\n @param [in] handle - handle to share.\n @param [in] handleType - type of the shareable handle.\n @param [in] flags - currently unused, must be zero.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues.\n\n @note  This API is implemented on Linux and is under development on Microsoft Windows."]
    pub fn hipMemExportToShareableHandle(
        shareableHandle: *mut ::libc::c_void,
        handle: hipMemGenericAllocationHandle_t,
        handleType: hipMemAllocationHandleType,
        flags: ::libc::c_ulonglong,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Get the access flags set for the given location and ptr.\n\n @param [out] flags - flags for this location.\n @param [in] location - target location.\n @param [in] ptr - address to check the access flags.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues.\n\n @note  This API is implemented on Linux and is under development on Microsoft Windows."]
    pub fn hipMemGetAccess(
        flags: *mut ::libc::c_ulonglong,
        location: *const hipMemLocation,
        ptr: *mut ::libc::c_void,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Calculates either the minimal or recommended granularity.\n\n @param [out] granularity - returned granularity.\n @param [in] prop - location properties.\n @param [in] option - determines which granularity to return.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues.\n\n @note  This API is implemented on Linux and is under development on Microsoft Windows.\n"]
    pub fn hipMemGetAllocationGranularity(
        granularity: *mut usize,
        prop: *const hipMemAllocationProp,
        option: hipMemAllocationGranularity_flags,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Retrieve the property structure of the given handle.\n\n @param [out] prop - properties of the given handle.\n @param [in] handle - handle to perform the query on.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues.\n\n @note  This API is implemented on Linux and is under development on Microsoft Windows."]
    pub fn hipMemGetAllocationPropertiesFromHandle(
        prop: *mut hipMemAllocationProp,
        handle: hipMemGenericAllocationHandle_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Imports an allocation from a requested shareable handle type.\n\n @param [out] handle - returned value.\n @param [in] osHandle - shareable handle representing the memory allocation.\n @param [in] shHandleType - handle type.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues.\n\n @note  This API is implemented on Linux and is under development on Microsoft Windows."]
    pub fn hipMemImportFromShareableHandle(
        handle: *mut hipMemGenericAllocationHandle_t,
        osHandle: *mut ::libc::c_void,
        shHandleType: hipMemAllocationHandleType,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Maps an allocation handle to a reserved virtual address range.\n\n @param [in] ptr - address where the memory will be mapped.\n @param [in] size - size of the mapping.\n @param [in] offset - offset into the memory, currently must be zero.\n @param [in] handle - memory allocation to be mapped.\n @param [in] flags - currently unused, must be zero.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues.\n\n @note  This API is implemented on Linux and is under development on Microsoft Windows."]
    pub fn hipMemMap(
        ptr: *mut ::libc::c_void,
        size: usize,
        offset: usize,
        handle: hipMemGenericAllocationHandle_t,
        flags: ::libc::c_ulonglong,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Maps or unmaps subregions of sparse HIP arrays and sparse HIP mipmapped arrays.\n\n @param [in] mapInfoList - list of hipArrayMapInfo.\n @param [in] count - number of hipArrayMapInfo in mapInfoList.\n @param [in] stream - stream identifier for the stream to use for map or unmap operations.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n @warning This API is under development. Currently it is not supported on AMD\n          GPUs and returns #hipErrorNotSupported."]
    pub fn hipMemMapArrayAsync(
        mapInfoList: *mut hipArrayMapInfo,
        count: ::libc::c_uint,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Release a memory handle representing a memory allocation which was previously allocated through hipMemCreate.\n\n @param [in] handle - handle of the memory allocation.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues.\n\n @note  This API is implemented on Linux and is under development on Microsoft Windows."]
    pub fn hipMemRelease(handle: hipMemGenericAllocationHandle_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns the allocation handle of the backing memory allocation given the address.\n\n @param [out] handle - handle representing addr.\n @param [in] addr - address to look up.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues.\n\n @note  This API is implemented on Linux and is under development on Microsoft Windows."]
    pub fn hipMemRetainAllocationHandle(
        handle: *mut hipMemGenericAllocationHandle_t,
        addr: *mut ::libc::c_void,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Set the access flags for each location specified in desc for the given virtual address range.\n\n @param [in] ptr - starting address of the virtual address range.\n @param [in] size - size of the range.\n @param [in] desc - array of hipMemAccessDesc.\n @param [in] count - number of hipMemAccessDesc in desc.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues.\n\n @note  This API is implemented on Linux and is under development on Microsoft Windows."]
    pub fn hipMemSetAccess(
        ptr: *mut ::libc::c_void,
        size: usize,
        desc: *const hipMemAccessDesc,
        count: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Unmap memory allocation of a given address range.\n\n @param [in] ptr - starting address of the range to unmap.\n @param [in] size - size of the virtual address range.\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotSupported\n @warning This API is marked as Beta. While this feature is complete, it can\n          change and might have outstanding issues.\n\n @note  This API is implemented on Linux and is under development on Microsoft Windows."]
    pub fn hipMemUnmap(ptr: *mut ::libc::c_void, size: usize) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Maps a graphics resource for access.\n\n @param [in] count - Number of resources to map.\n @param [in] resources - Pointer of resources to map.\n @param [in] stream - Stream for synchronization.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorUnknown, #hipErrorInvalidResourceHandle\n"]
    pub fn hipGraphicsMapResources(
        count: ::libc::c_int,
        resources: *mut hipGraphicsResource_t,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Get an array through which to access a subresource of a mapped graphics resource.\n\n @param [out] array - Pointer of array through which a subresource of resource may be accessed.\n @param [in] resource - Mapped resource to access.\n @param [in] arrayIndex - Array index for the subresource to access.\n @param [in] mipLevel - Mipmap level for the subresource to access.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n\n @note  In this API, the value of arrayIndex higher than zero is currently not supported.\n"]
    pub fn hipGraphicsSubResourceGetMappedArray(
        array: *mut hipArray_t,
        resource: hipGraphicsResource_t,
        arrayIndex: ::libc::c_uint,
        mipLevel: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets device accessible address of a graphics resource.\n\n @param [out] devPtr - Pointer of device through which graphic resource may be accessed.\n @param [out] size - Size of the buffer accessible from devPtr.\n @param [in] resource - Mapped resource to access.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipGraphicsResourceGetMappedPointer(
        devPtr: *mut *mut ::libc::c_void,
        size: *mut usize,
        resource: hipGraphicsResource_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Unmaps graphics resources.\n\n @param [in] count - Number of resources to unmap.\n @param [in] resources - Pointer of resources to unmap.\n @param [in] stream - Stream for synchronization.\n\n @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorUnknown, #hipErrorContextIsDestroyed\n"]
    pub fn hipGraphicsUnmapResources(
        count: ::libc::c_int,
        resources: *mut hipGraphicsResource_t,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Unregisters a graphics resource.\n\n @param [in] resource - Graphics resources to unregister.\n\n @returns #hipSuccess\n"]
    pub fn hipGraphicsUnregisterResource(resource: hipGraphicsResource_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Create a surface object.\n\n @param [out] pSurfObject  Pointer of surface object to be created.\n @param [in] pResDesc  Pointer of suface object descriptor.\n\n @returns #hipSuccess, #hipErrorInvalidValue\n"]
    pub fn hipCreateSurfaceObject(
        pSurfObject: *mut hipSurfaceObject_t,
        pResDesc: *const hipResourceDesc,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Destroy a surface object.\n\n @param [in] surfaceObject  Surface object to be destroyed.\n\n @returns #hipSuccess, #hipErrorInvalidValue"]
    pub fn hipDestroySurfaceObject(surfaceObject: hipSurfaceObject_t) -> hipError_t;
}
extern "C" {
    pub fn hipMemcpy_spt(
        dst: *mut ::libc::c_void,
        src: *const ::libc::c_void,
        sizeBytes: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipMemcpyToSymbol_spt(
        symbol: *const ::libc::c_void,
        src: *const ::libc::c_void,
        sizeBytes: usize,
        offset: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipMemcpyFromSymbol_spt(
        dst: *mut ::libc::c_void,
        symbol: *const ::libc::c_void,
        sizeBytes: usize,
        offset: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipMemcpy2D_spt(
        dst: *mut ::libc::c_void,
        dpitch: usize,
        src: *const ::libc::c_void,
        spitch: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipMemcpy2DFromArray_spt(
        dst: *mut ::libc::c_void,
        dpitch: usize,
        src: hipArray_const_t,
        wOffset: usize,
        hOffset: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipMemcpy3D_spt(p: *const hipMemcpy3DParms) -> hipError_t;
}
extern "C" {
    pub fn hipMemset_spt(
        dst: *mut ::libc::c_void,
        value: ::libc::c_int,
        sizeBytes: usize,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipMemsetAsync_spt(
        dst: *mut ::libc::c_void,
        value: ::libc::c_int,
        sizeBytes: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipMemset2D_spt(
        dst: *mut ::libc::c_void,
        pitch: usize,
        value: ::libc::c_int,
        width: usize,
        height: usize,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipMemset2DAsync_spt(
        dst: *mut ::libc::c_void,
        pitch: usize,
        value: ::libc::c_int,
        width: usize,
        height: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipMemset3DAsync_spt(
        pitchedDevPtr: hipPitchedPtr,
        value: ::libc::c_int,
        extent: hipExtent,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipMemset3D_spt(
        pitchedDevPtr: hipPitchedPtr,
        value: ::libc::c_int,
        extent: hipExtent,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipMemcpyAsync_spt(
        dst: *mut ::libc::c_void,
        src: *const ::libc::c_void,
        sizeBytes: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipMemcpy3DAsync_spt(p: *const hipMemcpy3DParms, stream: hipStream_t) -> hipError_t;
}
extern "C" {
    pub fn hipMemcpy2DAsync_spt(
        dst: *mut ::libc::c_void,
        dpitch: usize,
        src: *const ::libc::c_void,
        spitch: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipMemcpyFromSymbolAsync_spt(
        dst: *mut ::libc::c_void,
        symbol: *const ::libc::c_void,
        sizeBytes: usize,
        offset: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipMemcpyToSymbolAsync_spt(
        symbol: *const ::libc::c_void,
        src: *const ::libc::c_void,
        sizeBytes: usize,
        offset: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipMemcpyFromArray_spt(
        dst: *mut ::libc::c_void,
        src: hipArray_const_t,
        wOffsetSrc: usize,
        hOffset: usize,
        count: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipMemcpy2DToArray_spt(
        dst: hipArray_t,
        wOffset: usize,
        hOffset: usize,
        src: *const ::libc::c_void,
        spitch: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipMemcpy2DFromArrayAsync_spt(
        dst: *mut ::libc::c_void,
        dpitch: usize,
        src: hipArray_const_t,
        wOffsetSrc: usize,
        hOffsetSrc: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipMemcpy2DToArrayAsync_spt(
        dst: hipArray_t,
        wOffset: usize,
        hOffset: usize,
        src: *const ::libc::c_void,
        spitch: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipStreamQuery_spt(stream: hipStream_t) -> hipError_t;
}
extern "C" {
    pub fn hipStreamSynchronize_spt(stream: hipStream_t) -> hipError_t;
}
extern "C" {
    pub fn hipStreamGetPriority_spt(
        stream: hipStream_t,
        priority: *mut ::libc::c_int,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipStreamWaitEvent_spt(
        stream: hipStream_t,
        event: hipEvent_t,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipStreamGetFlags_spt(stream: hipStream_t, flags: *mut ::libc::c_uint) -> hipError_t;
}
extern "C" {
    pub fn hipStreamAddCallback_spt(
        stream: hipStream_t,
        callback: hipStreamCallback_t,
        userData: *mut ::libc::c_void,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipEventRecord_spt(event: hipEvent_t, stream: hipStream_t) -> hipError_t;
}
extern "C" {
    pub fn hipLaunchCooperativeKernel_spt(
        f: *const ::libc::c_void,
        gridDim: dim3,
        blockDim: dim3,
        kernelParams: *mut *mut ::libc::c_void,
        sharedMemBytes: u32,
        hStream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipLaunchKernel_spt(
        function_address: *const ::libc::c_void,
        numBlocks: dim3,
        dimBlocks: dim3,
        args: *mut *mut ::libc::c_void,
        sharedMemBytes: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipGraphLaunch_spt(graphExec: hipGraphExec_t, stream: hipStream_t) -> hipError_t;
}
extern "C" {
    pub fn hipStreamBeginCapture_spt(stream: hipStream_t, mode: hipStreamCaptureMode)
        -> hipError_t;
}
extern "C" {
    pub fn hipStreamEndCapture_spt(stream: hipStream_t, pGraph: *mut hipGraph_t) -> hipError_t;
}
extern "C" {
    pub fn hipStreamIsCapturing_spt(
        stream: hipStream_t,
        pCaptureStatus: *mut hipStreamCaptureStatus,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipStreamGetCaptureInfo_spt(
        stream: hipStream_t,
        pCaptureStatus: *mut hipStreamCaptureStatus,
        pId: *mut ::libc::c_ulonglong,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipStreamGetCaptureInfo_v2_spt(
        stream: hipStream_t,
        captureStatus_out: *mut hipStreamCaptureStatus,
        id_out: *mut ::libc::c_ulonglong,
        graph_out: *mut hipGraph_t,
        dependencies_out: *mut *const hipGraphNode_t,
        numDependencies_out: *mut usize,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipLaunchHostFunc_spt(
        stream: hipStream_t,
        fn_: hipHostFn_t,
        userData: *mut ::libc::c_void,
    ) -> hipError_t;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipDataType {
    HIP_R_32F = 0,
    HIP_R_64F = 1,
    HIP_R_16F = 2,
    HIP_R_8I = 3,
    HIP_C_32F = 4,
    HIP_C_64F = 5,
    HIP_C_16F = 6,
    HIP_C_8I = 7,
    HIP_R_8U = 8,
    HIP_C_8U = 9,
    HIP_R_32I = 10,
    HIP_C_32I = 11,
    HIP_R_32U = 12,
    HIP_C_32U = 13,
    HIP_R_16BF = 14,
    HIP_C_16BF = 15,
    HIP_R_4I = 16,
    HIP_C_4I = 17,
    HIP_R_4U = 18,
    HIP_C_4U = 19,
    HIP_R_16I = 20,
    HIP_C_16I = 21,
    HIP_R_16U = 22,
    HIP_C_16U = 23,
    HIP_R_64I = 24,
    HIP_C_64I = 25,
    HIP_R_64U = 26,
    HIP_C_64U = 27,
    HIP_R_8F_E4M3 = 28,
    HIP_R_8F_E5M2 = 29,
    HIP_R_8F_E4M3_FNUZ = 1000,
    HIP_R_8F_E5M2_FNUZ = 1001,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipLibraryPropertyType {
    HIP_LIBRARY_MAJOR_VERSION = 0,
    HIP_LIBRARY_MINOR_VERSION = 1,
    HIP_LIBRARY_PATCH_LEVEL = 2,
}
#[doc = " \\brief Struct to represent a 8 bit floating-point number."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipblaslt_f8_fnuz {
    pub data: u8,
}
#[test]
fn bindgen_test_layout_hipblaslt_f8_fnuz() {
    const UNINIT: ::std::mem::MaybeUninit<hipblaslt_f8_fnuz> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipblaslt_f8_fnuz>(),
        1usize,
        concat!("Size of: ", stringify!(hipblaslt_f8_fnuz))
    );
    assert_eq!(
        ::std::mem::align_of::<hipblaslt_f8_fnuz>(),
        1usize,
        concat!("Alignment of ", stringify!(hipblaslt_f8_fnuz))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipblaslt_f8_fnuz),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipblaslt_bf8_fnuz {
    pub data: u8,
}
#[test]
fn bindgen_test_layout_hipblaslt_bf8_fnuz() {
    const UNINIT: ::std::mem::MaybeUninit<hipblaslt_bf8_fnuz> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipblaslt_bf8_fnuz>(),
        1usize,
        concat!("Size of: ", stringify!(hipblaslt_bf8_fnuz))
    );
    assert_eq!(
        ::std::mem::align_of::<hipblaslt_bf8_fnuz>(),
        1usize,
        concat!("Alignment of ", stringify!(hipblaslt_bf8_fnuz))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipblaslt_bf8_fnuz),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipblaslt_f8 {
    pub data: u8,
}
#[test]
fn bindgen_test_layout_hipblaslt_f8() {
    const UNINIT: ::std::mem::MaybeUninit<hipblaslt_f8> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipblaslt_f8>(),
        1usize,
        concat!("Size of: ", stringify!(hipblaslt_f8))
    );
    assert_eq!(
        ::std::mem::align_of::<hipblaslt_f8>(),
        1usize,
        concat!("Alignment of ", stringify!(hipblaslt_f8))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipblaslt_f8),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipblaslt_bf8 {
    pub data: u8,
}
#[test]
fn bindgen_test_layout_hipblaslt_bf8() {
    const UNINIT: ::std::mem::MaybeUninit<hipblaslt_bf8> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipblaslt_bf8>(),
        1usize,
        concat!("Size of: ", stringify!(hipblaslt_bf8))
    );
    assert_eq!(
        ::std::mem::align_of::<hipblaslt_bf8>(),
        1usize,
        concat!("Alignment of ", stringify!(hipblaslt_bf8))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipblaslt_bf8),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " \\brief Single precision floating point type"]
pub type hipblasLtFloat = f32;
#[doc = " \\brief Structure definition for hipblasLtHalf"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _hipblasLtHalf {
    pub data: u16,
}
#[test]
fn bindgen_test_layout__hipblasLtHalf() {
    const UNINIT: ::std::mem::MaybeUninit<_hipblasLtHalf> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_hipblasLtHalf>(),
        2usize,
        concat!("Size of: ", stringify!(_hipblasLtHalf))
    );
    assert_eq!(
        ::std::mem::align_of::<_hipblasLtHalf>(),
        2usize,
        concat!("Alignment of ", stringify!(_hipblasLtHalf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_hipblasLtHalf),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " \\brief Structure definition for hipblasLtHalf"]
pub type hipblasLtHalf = _hipblasLtHalf;
#[doc = " \\brief Struct to represent a 16 bit brain floating point number."]
pub type hipblasLtBfloat16 = hip_bfloat16;
pub type hipblasLtInt8 = i8;
pub type hipblasLtInt32 = i32;
#[repr(u32)]
#[non_exhaustive]
#[doc = " \\ingroup types_module\n  \\brief Specify the enum type to set the postprocessing options for the epilogue."]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipblasLtEpilogue_t {
    #[doc = "<No special postprocessing, just scale and quantize the results if necessary."]
    HIPBLASLT_EPILOGUE_DEFAULT = 1,
    #[doc = "<Apply ReLU point-wise transform to the results:(x:=max(x, 0))"]
    HIPBLASLT_EPILOGUE_RELU = 2,
    #[doc = "<Apply (broadcast) bias from the bias vector. Bias vector length must match matrix D rows, and it must be packed (such as stride between vector elements is 1). Bias vector is broadcast to all columns and added before applying the final postprocessing."]
    HIPBLASLT_EPILOGUE_BIAS = 4,
    #[doc = "<Apply bias and then ReLU transform."]
    HIPBLASLT_EPILOGUE_RELU_BIAS = 6,
    #[doc = "<Apply GELU point-wise transform to the results (x:=GELU(x))."]
    HIPBLASLT_EPILOGUE_GELU = 32,
    #[doc = "<Apply Bias and then GELU transform."]
    HIPBLASLT_EPILOGUE_GELU_BIAS = 36,
    #[doc = "<Output GEMM results before applying GELU transform."]
    HIPBLASLT_EPILOGUE_GELU_AUX = 160,
    #[doc = "<Output GEMM results after applying bias but before applying GELU transform."]
    HIPBLASLT_EPILOGUE_GELU_AUX_BIAS = 164,
    #[doc = "<Apply gradient GELU transform. Requires additional aux input."]
    HIPBLASLT_EPILOGUE_DGELU = 192,
    #[doc = "<Apply gradient GELU transform and bias gradient to the results. Requires additional aux input."]
    HIPBLASLT_EPILOGUE_DGELU_BGRAD = 208,
    #[doc = "<Apply bias gradient to A and output gemm result."]
    HIPBLASLT_EPILOGUE_BGRADA = 256,
    #[doc = "<Apply bias gradient to B and output gemm result."]
    HIPBLASLT_EPILOGUE_BGRADB = 512,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " \\ingroup types_module\n  \\brief Specify the attributes that define the details of the matrix."]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipblasLtMatrixLayoutAttribute_t {
    #[doc = "<Number of batch of this matrix. Default value is 1. Data Type: int32_t"]
    HIPBLASLT_MATRIX_LAYOUT_BATCH_COUNT = 0,
    #[doc = "<Stride (in elements) to the next matrix for the strided batch operation. Default value is 0. Data Type: int64_t"]
    HIPBLASLT_MATRIX_LAYOUT_STRIDED_BATCH_OFFSET = 1,
    #[doc = " Data type, see hipDataType.\n\n uint32_t"]
    HIPBLASLT_MATRIX_LAYOUT_TYPE = 2,
    #[doc = " Memory order of the data, see hipblasLtOrder_t.\n\n int32_t, default: HIPBLASLT_ORDER_COL"]
    HIPBLASLT_MATRIX_LAYOUT_ORDER = 3,
    #[doc = " Number of rows.\n\n Usually only values that can be expressed as int32_t are supported.\n\n uint64_t"]
    HIPBLASLT_MATRIX_LAYOUT_ROWS = 4,
    #[doc = " Number of columns.\n\n Usually only values that can be expressed as int32_t are supported.\n\n uint64_t"]
    HIPBLASLT_MATRIX_LAYOUT_COLS = 5,
    #[doc = " Matrix leading dimension.\n\n For HIPBLASLT_ORDER_COL this is stride (in elements) of matrix column, for more details and documentation for\n other memory orders see documentation for hipblasLtOrder_t values.\n\n Currently only non-negative values are supported, must be large enough so that matrix memory locations are not\n overlapping (e.g. greater or equal to HIPBLASLT_MATRIX_LAYOUT_ROWS in case of HIPBLASLT_ORDER_COL).\n\n int64_t;"]
    HIPBLASLT_MATRIX_LAYOUT_LD = 6,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " \\ingroup types_module\n  \\brief Pointer mode to use for alpha."]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipblasLtPointerMode_t {
    HIPBLASLT_POINTER_MODE_HOST = 0,
    #[doc = " targets host memory"]
    HIPBLASLT_POINTER_MODE_DEVICE = 1,
    #[doc = " targets device memory"]
    HIPBLASLT_POINTER_MODE_ALPHA_DEVICE_VECTOR_BETA_HOST = 4,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " \\ingroup types_module\n  \\brief Specify the attributes that define the specifics of the matrix multiply operation."]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipblasLtMatmulDescAttributes_t {
    #[doc = "<Specifies the type of transformation operation that should be performed on matrix A. Default value is HIPBLAS_OP_N (for example, non-transpose operation). See hipblasOperation_t. Data Type:int32_t"]
    HIPBLASLT_MATMUL_DESC_TRANSA = 0,
    #[doc = "<Specifies the type of transformation operation that should be performed on matrix B. Default value is HIPBLAS_OP_N (for example, non-transpose operation). See hipblasOperation_t. Data Type:int32_t"]
    HIPBLASLT_MATMUL_DESC_TRANSB = 1,
    #[doc = "<Epilogue function. See hipblasLtEpilogue_t. Default value is: HIPBLASLT_EPILOGUE_DEFAULT. Data Type: uint32_t"]
    HIPBLASLT_MATMUL_DESC_EPILOGUE = 2,
    #[doc = "<Bias or Bias gradient vector pointer in the device memory. Data Type:void* /const void*"]
    HIPBLASLT_MATMUL_DESC_BIAS_POINTER = 3,
    #[doc = "<Type of the bias vector in the device memory. Can be set same as D matrix type or Scale type. Bias case: see HIPBLASLT_EPILOGUE_BIAS. Data Type:int32_t based on hipDataType"]
    HIPBLASLT_MATMUL_DESC_BIAS_DATA_TYPE = 4,
    #[doc = "<Device pointer to the scale factor value that converts data in matrix A to the compute data type range. The scaling factor must have the same type as the compute type. If not specified, or set to NULL, the scaling factor is assumed to be 1. If set for an unsupported matrix data, scale, and compute type combination, calling hipblasLtMatmul() will return HIPBLAS_INVALID_VALUE. Default value: NULL Data Type: void* /const void*"]
    HIPBLASLT_MATMUL_DESC_A_SCALE_POINTER = 5,
    #[doc = "<Equivalent to HIPBLASLT_MATMUL_DESC_A_SCALE_POINTER for matrix B. Default value: NULL Type: void* /const void*"]
    HIPBLASLT_MATMUL_DESC_B_SCALE_POINTER = 6,
    #[doc = "<Equivalent to HIPBLASLT_MATMUL_DESC_A_SCALE_POINTER for matrix C. Default value: NULL Type: void* /const void*"]
    HIPBLASLT_MATMUL_DESC_C_SCALE_POINTER = 7,
    #[doc = "<Equivalent to HIPBLASLT_MATMUL_DESC_A_SCALE_POINTER for matrix D. Default value: NULL Type: void* /const void*"]
    HIPBLASLT_MATMUL_DESC_D_SCALE_POINTER = 8,
    #[doc = "<Equivalent to HIPBLASLT_MATMUL_DESC_A_SCALE_POINTER for matrix AUX. Default value: NULL Type: void* /const void*"]
    HIPBLASLT_MATMUL_DESC_EPILOGUE_AUX_SCALE_POINTER = 9,
    #[doc = "<Epilogue auxiliary buffer pointer in the device memory. Data Type:void* /const void*"]
    HIPBLASLT_MATMUL_DESC_EPILOGUE_AUX_POINTER = 10,
    #[doc = "<The leading dimension of the epilogue auxiliary buffer pointer in the device memory. Data Type:int64_t"]
    HIPBLASLT_MATMUL_DESC_EPILOGUE_AUX_LD = 11,
    #[doc = "<The batch stride of the epilogue auxiliary buffer pointer in the device memory. Data Type:int64_t"]
    HIPBLASLT_MATMUL_DESC_EPILOGUE_AUX_BATCH_STRIDE = 12,
    #[doc = "<Specifies alpha and beta are passed by reference, whether they are scalars on the host or on the device, or device vectors. Default value is: HIPBLASLT_POINTER_MODE_HOST (i.e., on the host). Data Type: int32_t based on hipblasLtPointerMode_t"]
    HIPBLASLT_MATMUL_DESC_POINTER_MODE = 13,
    #[doc = "<Device pointer to the memory location that on completion will be set to the maximum of absolute values in the output matrix. Data Type:void* /const void*"]
    HIPBLASLT_MATMUL_DESC_AMAX_D_POINTER = 14,
    #[doc = "<Compute input A types. Defines the data type used for the input A of matrix multiply."]
    HIPBLASLT_MATMUL_DESC_COMPUTE_INPUT_TYPE_A_EXT = 100,
    #[doc = "<Compute input B types. Defines the data type used for the input B of matrix multiply."]
    HIPBLASLT_MATMUL_DESC_COMPUTE_INPUT_TYPE_B_EXT = 101,
    #[doc = "<Equivalent to HIPBLASLT_MATMUL_DESC_A_SCALE_POINTER but in vector. Default value: NULL Type: void* /const void*"]
    HIPBLASLT_MATMUL_DESC_A_SCALE_POINTER_VEC_EXT = 102,
    #[doc = "<Equivalent to HIPBLASLT_MATMUL_DESC_B_SCALE_POINTER but in vector. Default value: NULL Type: void* /const void*"]
    HIPBLASLT_MATMUL_DESC_B_SCALE_POINTER_VEC_EXT = 103,
    HIPBLASLT_MATMUL_DESC_MAX = 104,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " \\ingroup types_module\n  \\brief It is an enumerated type used to apply algorithm search preferences while fine-tuning the heuristic function."]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipblasLtMatmulPreferenceAttributes_t {
    #[doc = "<Search mode. Data Type: uint32_t"]
    HIPBLASLT_MATMUL_PREF_SEARCH_MODE = 0,
    #[doc = "<Maximum allowed workspace memory. Default is 0 (no workspace memory allowed). Data Type: uint64_t"]
    HIPBLASLT_MATMUL_PREF_MAX_WORKSPACE_BYTES = 1,
    HIPBLASLT_MATMUL_PREF_MAX = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Enum for data ordering"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipblasLtOrder_t {
    #[doc = " Column-major\n\n Leading dimension is the stride (in elements) to the beginning of next column in memory."]
    HIPBLASLT_ORDER_COL = 0,
    #[doc = " Row major\n\n Leading dimension is the stride (in elements) to the beginning of next row in memory."]
    HIPBLASLT_ORDER_ROW = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Matrix transform descriptor attributes to define details of the operation."]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipblasLtMatrixTransformDescAttributes_t {
    #[doc = " Scale type, see hipDataType. Inputs are converted to scale type for scaling and summation and results are then\n converted to output type to store in memory.\n\n int32_t"]
    HIPBLASLT_MATRIX_TRANSFORM_DESC_SCALE_TYPE = 0,
    #[doc = " Pointer mode of alpha and beta, see hipblasLtPointerMode_t.\n\n int32_t, default: HIPBLASLT_POINTER_MODE_HOST"]
    HIPBLASLT_MATRIX_TRANSFORM_DESC_POINTER_MODE = 1,
    #[doc = " Transform of matrix A, see hipblasOperation_t.\n\n int32_t, default: HIPBLAS_OP_N"]
    HIPBLASLT_MATRIX_TRANSFORM_DESC_TRANSA = 2,
    #[doc = " Transform of matrix B, see hipblasOperation_t.\n\n int32_t, default: HIPBLAS_OP_N"]
    HIPBLASLT_MATRIX_TRANSFORM_DESC_TRANSB = 3,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipblasLtMatmulDescOpaque_t {
    pub data: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_hipblasLtMatmulDescOpaque_t() {
    const UNINIT: ::std::mem::MaybeUninit<hipblasLtMatmulDescOpaque_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipblasLtMatmulDescOpaque_t>(),
        32usize,
        concat!("Size of: ", stringify!(hipblasLtMatmulDescOpaque_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hipblasLtMatmulDescOpaque_t>(),
        8usize,
        concat!("Alignment of ", stringify!(hipblasLtMatmulDescOpaque_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipblasLtMatmulDescOpaque_t),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipblasLtMatrixLayoutOpaque_t {
    pub data: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_hipblasLtMatrixLayoutOpaque_t() {
    const UNINIT: ::std::mem::MaybeUninit<hipblasLtMatrixLayoutOpaque_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipblasLtMatrixLayoutOpaque_t>(),
        32usize,
        concat!("Size of: ", stringify!(hipblasLtMatrixLayoutOpaque_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hipblasLtMatrixLayoutOpaque_t>(),
        8usize,
        concat!("Alignment of ", stringify!(hipblasLtMatrixLayoutOpaque_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipblasLtMatrixLayoutOpaque_t),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipblasLtMatmulPreferenceOpaque_t {
    pub data: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_hipblasLtMatmulPreferenceOpaque_t() {
    const UNINIT: ::std::mem::MaybeUninit<hipblasLtMatmulPreferenceOpaque_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipblasLtMatmulPreferenceOpaque_t>(),
        40usize,
        concat!("Size of: ", stringify!(hipblasLtMatmulPreferenceOpaque_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hipblasLtMatmulPreferenceOpaque_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hipblasLtMatmulPreferenceOpaque_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipblasLtMatmulPreferenceOpaque_t),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " Semi-opaque descriptor for hipblasLtMatrixTransform() operation details"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipblasLtMatrixTransformDescOpaque_t {
    pub data: [u64; 8usize],
}
#[test]
fn bindgen_test_layout_hipblasLtMatrixTransformDescOpaque_t() {
    const UNINIT: ::std::mem::MaybeUninit<hipblasLtMatrixTransformDescOpaque_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hipblasLtMatrixTransformDescOpaque_t>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(hipblasLtMatrixTransformDescOpaque_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hipblasLtMatrixTransformDescOpaque_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hipblasLtMatrixTransformDescOpaque_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipblasLtMatrixTransformDescOpaque_t),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " \\ingroup types_module\n  \\brief Opaque descriptor for hipblasLtMatrixTransform() operation details\n\n  \\details\n  The hipblasLtMatrixTransformDesc_t is a pointer to an opaque structure holding the description of a matrix transformation operation.\n  \\ref hipblasLtMatrixTransformDescCreate():\n  To create one instance of the descriptor.\n  \\ref hipblasLtMatrixTransformDescDestroy():\n  To destroy a previously created descriptor and release the resources."]
pub type hipblasLtMatrixTransformDesc_t = *mut hipblasLtMatrixTransformDescOpaque_t;
#[doc = " \\ingroup types_module\n  \\brief Handle to the hipBLASLt library context queue\n\n  \\details\n  The hipblasLtHandle_t type is a pointer type to an opaque structure holding the hipBLASLt library context. Use the following functions to manipulate this library context:\n\n  \\ref hipblasLtCreate():\n  To initialize the hipBLASLt library context and return a handle to an opaque structure holding the hipBLASLt library context.\n  \\ref hipblasLtDestroy():\n  To destroy a previously created hipBLASLt library context descriptor and release the resources."]
pub type hipblasLtHandle_t = *mut ::libc::c_void;
#[doc = " \\ingroup types_module\n  \\brief Descriptor of the matrix multiplication operation\n\n  \\details\n  This is a pointer to an opaque structure holding the description of the matrix multiplication operation \\ref hipblasLtMatmul().\n  Use the following functions to manipulate this descriptor:\n  \\ref hipblasLtMatmulDescCreate(): To create one instance of the descriptor.\n  \\ref hipblasLtMatmulDescDestroy(): To destroy a previously created descriptor and release the resources."]
pub type hipblasLtMatmulDesc_t = *mut hipblasLtMatmulDescOpaque_t;
#[doc = " \\ingroup types_module\n  \\brief Descriptor of the matrix layout\n\n  \\details\n  This is a pointer to an opaque structure holding the description of a matrix layout.\n  Use the following functions to manipulate this descriptor:\n  \\ref hipblasLtMatrixLayoutCreate(): To create one instance of the descriptor.\n  \\ref hipblasLtMatrixLayoutDestroy(): To destroy a previously created descriptor and release the resources."]
pub type hipblasLtMatrixLayout_t = *mut hipblasLtMatrixLayoutOpaque_t;
#[doc = " \\ingroup types_module\n  \\brief Descriptor of the matrix multiplication preference\n\n  \\details\n  This is a pointer to an opaque structure holding the description of the preferences for \\ref hipblasLtMatmulAlgoGetHeuristic() configuration.\n  Use the following functions to manipulate this descriptor:\n  \\ref hipblasLtMatmulPreferenceCreate(): To create one instance of the descriptor.\n  \\ref hipblasLtMatmulPreferenceDestroy(): To destroy a previously created descriptor and release the resources."]
pub type hipblasLtMatmulPreference_t = *mut hipblasLtMatmulPreferenceOpaque_t;
#[doc = " \\ingroup types_module\n  \\struct hipblasLtMatmulAlgo_t\n  \\brief Description of the matrix multiplication algorithm\n\n  \\details\n  This is an opaque structure holding the description of the matrix multiplication algorithm.\n  This structure can be trivially serialized and later restored for use with the same version of hipBLASLt library to save on selecting the right configuration again."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _hipblasLtMatmulAlgo_t {
    pub data: [u8; 16usize],
    pub max_workspace_bytes: usize,
}
#[test]
fn bindgen_test_layout__hipblasLtMatmulAlgo_t() {
    const UNINIT: ::std::mem::MaybeUninit<_hipblasLtMatmulAlgo_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_hipblasLtMatmulAlgo_t>(),
        24usize,
        concat!("Size of: ", stringify!(_hipblasLtMatmulAlgo_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_hipblasLtMatmulAlgo_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_hipblasLtMatmulAlgo_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_hipblasLtMatmulAlgo_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_workspace_bytes) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_hipblasLtMatmulAlgo_t),
            "::",
            stringify!(max_workspace_bytes)
        )
    );
}
#[doc = " \\ingroup types_module\n  \\struct hipblasLtMatmulAlgo_t\n  \\brief Description of the matrix multiplication algorithm\n\n  \\details\n  This is an opaque structure holding the description of the matrix multiplication algorithm.\n  This structure can be trivially serialized and later restored for use with the same version of hipBLASLt library to save on selecting the right configuration again."]
pub type hipblasLtMatmulAlgo_t = _hipblasLtMatmulAlgo_t;
#[doc = " \\ingroup types_module\n  \\struct hipblasLtMatmulHeuristicResult_t\n  \\brief Description of the matrix multiplication algorithm\n\n  \\details\n  This is a descriptor that holds the configured matrix multiplication algorithm descriptor and its runtime properties.\n  This structure can be trivially serialized and later restored for use with the same version of hipBLASLt library to save on selecting the right configuration again.\n  @param algo \\ref hipblasLtMatmulAlgo_t struct\n  @param workspaceSize Actual size of workspace memory required\n  @param state Result status. Other fields are valid only if, after call to hipblasLtMatmulAlgoGetHeuristic(), this member is set to HIPBLAS_STATUS_SUCCESS"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, PartialEq)]
pub struct _hipblasLtMatmulHeuristicResult_t {
    #[doc = "<Algo struct"]
    pub algo: hipblasLtMatmulAlgo_t,
    #[doc = "<Actual size of workspace memory required."]
    pub workspaceSize: usize,
    #[doc = "<Result status. Other fields are valid only if, after call to hipblasLtMatmulAlgoGetHeuristic(), this member is set to HIPBLAS_STATUS_SUCCESS.."]
    pub state: hipblasStatus_t,
    #[doc = "<Waves count is a device utilization metric. A wavesCount value of 1.0f suggests that when the kernel is launched it will fully occupy the GPU."]
    pub wavesCount: f32,
    #[doc = "<Reserved."]
    pub reserved: [::libc::c_int; 4usize],
}
#[test]
fn bindgen_test_layout__hipblasLtMatmulHeuristicResult_t() {
    const UNINIT: ::std::mem::MaybeUninit<_hipblasLtMatmulHeuristicResult_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_hipblasLtMatmulHeuristicResult_t>(),
        56usize,
        concat!("Size of: ", stringify!(_hipblasLtMatmulHeuristicResult_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_hipblasLtMatmulHeuristicResult_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_hipblasLtMatmulHeuristicResult_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).algo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_hipblasLtMatmulHeuristicResult_t),
            "::",
            stringify!(algo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).workspaceSize) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_hipblasLtMatmulHeuristicResult_t),
            "::",
            stringify!(workspaceSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_hipblasLtMatmulHeuristicResult_t),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wavesCount) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_hipblasLtMatmulHeuristicResult_t),
            "::",
            stringify!(wavesCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_hipblasLtMatmulHeuristicResult_t),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for _hipblasLtMatmulHeuristicResult_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\ingroup types_module\n  \\struct hipblasLtMatmulHeuristicResult_t\n  \\brief Description of the matrix multiplication algorithm\n\n  \\details\n  This is a descriptor that holds the configured matrix multiplication algorithm descriptor and its runtime properties.\n  This structure can be trivially serialized and later restored for use with the same version of hipBLASLt library to save on selecting the right configuration again.\n  @param algo \\ref hipblasLtMatmulAlgo_t struct\n  @param workspaceSize Actual size of workspace memory required\n  @param state Result status. Other fields are valid only if, after call to hipblasLtMatmulAlgoGetHeuristic(), this member is set to HIPBLAS_STATUS_SUCCESS"]
pub type hipblasLtMatmulHeuristicResult_t = _hipblasLtMatmulHeuristicResult_t;
extern "C" {
    pub fn hipblasLtGetVersion(
        handle: hipblasLtHandle_t,
        version: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasLtGetGitRevision(
        handle: hipblasLtHandle_t,
        rev: *mut ::libc::c_char,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasLtGetArchName(archName: *mut *mut ::libc::c_char) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\ingroup library_module\n  \\brief Create a hipblaslt handle\n\n  \\details\n  This function initializes the hipBLASLt library and creates a handle to an\n opaque structure holding the hipBLASLt library context. It allocates light\n hardware resources on the host and device, and must be called prior to making\n any other hipBLASLt library calls. The hipBLASLt library context is tied to\n the current ROCm device. To use the library on multiple devices, one\n hipBLASLt handle should be created for each device.\n\n  @param[out]\n  handle  Pointer to the allocated hipBLASLt handle for the created hipBLASLt\n context.\n\n  \\retval HIPBLAS_STATUS_SUCCESS The allocation completed successfully.\n  \\retval HIPBLAS_STATUS_INVALID_VALUE \\p handle == NULL."]
    pub fn hipblasLtCreate(handle: *mut hipblasLtHandle_t) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\ingroup library_module\n  \\brief Destory a hipblaslt handle\n\n  \\details\n  This function releases hardware resources used by the hipBLASLt library.\n  This function is usually the last call with a particular handle to the\n hipBLASLt library. Because hipblasLtCreate() allocates some internal\n resources and the release of those resources by calling hipblasLtDestroy()\n will implicitly call hipDeviceSynchronize(), it is recommended to minimize\n the number of hipblasLtCreate()/hipblasLtDestroy() occurrences.\n\n  @param[in]\n  handle  Pointer to the hipBLASLt handle to be destroyed.\n\n  \\retval HIPBLAS_STATUS_SUCCESS The hipBLASLt context was successfully\n destroyed. \\retval HIPBLAS_STATUS_NOT_INITIALIZED The hipBLASLt library was\n not initialized. \\retval HIPBLAS_STATUS_INVALID_VALUE \\p handle == NULL."]
    pub fn hipblasLtDestroy(handle: hipblasLtHandle_t) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\ingroup library_module\n  \\brief Create a matrix layout descriptor\n\n  \\details\n  This function creates a matrix layout descriptor by allocating the memory\n needed to hold its opaque structure.\n\n  @param[out]\n  matLayout Pointer to the structure holding the matrix layout descriptor\n created by this function. see \\ref hipblasLtMatrixLayout_t .\n  @param[in]\n  type Enumerant that specifies the data precision for the matrix layout\n descriptor this function creates. See hipDataType.\n  @param[in]\n  rows Number of rows of the matrix.\n  @param[in]\n  cols Number of columns of the matrix.\n  @param[in]\n  ld The leading dimension of the matrix. In column major layout, this is the\n number of elements to jump to reach the next column. Thus ld >= m (number of\n rows).\n\n  \\retval HIPBLAS_STATUS_SUCCESS If the descriptor was created successfully.\n  \\retval HIPBLAS_STATUS_ALLOC_FAILED If the memory could not be allocated."]
    pub fn hipblasLtMatrixLayoutCreate(
        matLayout: *mut hipblasLtMatrixLayout_t,
        type_: hipDataType,
        rows: u64,
        cols: u64,
        ld: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\ingroup library_module\n  \\brief Destory a matrix layout descriptor\n\n  \\details\n  This function destroys a previously created matrix layout descriptor object.\n\n  @param[in]\n  matLayout Pointer to the structure holding the matrix layout descriptor that\n should be destroyed by this function. see \\ref hipblasLtMatrixLayout_t .\n\n  \\retval HIPBLAS_STATUS_SUCCESS If the operation was successful."]
    pub fn hipblasLtMatrixLayoutDestroy(matLayout: hipblasLtMatrixLayout_t) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\ingroup library_module\n  \\brief  Set attribute to a matrix descriptor\n\n  \\details\n  This function sets the value of the specified attribute belonging to a\n previously created matrix descriptor.\n\n  @param[in]\n  matLayout  Pointer to the previously created structure holding the matrix\n mdescriptor queried by this function. See \\ref hipblasLtMatrixLayout_t.\n  @param[in]\n  attr  \tThe attribute that will be set by this function. See \\ref\n hipblasLtMatrixLayoutAttribute_t.\n  @param[in]\n  buf  The value to which the specified attribute should be set.\n  @param[in]\n  sizeInBytes Size of buf buffer (in bytes) for verification.\n\n  \\retval HIPBLAS_STATUS_SUCCESS If the attribute was set successfully..\n  \\retval HIPBLAS_STATUS_INVALID_VALUE If \\p buf is NULL or \\p sizeInBytes\n doesn't match the size of the internal storage for the selected attribute."]
    pub fn hipblasLtMatrixLayoutSetAttribute(
        matLayout: hipblasLtMatrixLayout_t,
        attr: hipblasLtMatrixLayoutAttribute_t,
        buf: *const ::libc::c_void,
        sizeInBytes: usize,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\ingroup library_module\n  \\brief Query attribute from a matrix descriptor\n\n  \\details\n  This function returns the value of the queried attribute belonging to a\n previously created matrix descriptor.\n\n  @param[in]\n  matLayout  Pointer to the previously created structure holding the matrix\n descriptor queried by this function. See \\ref hipblasLtMatrixLayout_t.\n  @param[in]\n  attr  \t    The attribute that will be retrieved by this function. See\n \\ref hipblasLtMatrixLayoutAttribute_t.\n  @param[out]\n  buf         Memory address containing the attribute value retrieved by this\n function.\n  @param[in]\n  sizeInBytes Size of \\p buf buffer (in bytes) for verification.\n  @param[out]\n  sizeWritten Valid only when the return value is HIPBLAS_STATUS_SUCCESS. If\n sizeInBytes is non-zero: then sizeWritten is the number of bytes actually\n written; if sizeInBytes is 0: then sizeWritten is the number of bytes needed\n to write full contents.\n\n  \\retval HIPBLAS_STATUS_SUCCESS       If attribute's value was successfully\n written to user memory. \\retval HIPBLAS_STATUS_INVALID_VALUE If \\p\n sizeInBytes is 0 and \\p sizeWritten is NULL, or if \\p sizeInBytes is non-zero\n and \\p buf is NULL, or \\p sizeInBytes doesn't match size of internal storage\n for the selected attribute."]
    pub fn hipblasLtMatrixLayoutGetAttribute(
        matLayout: hipblasLtMatrixLayout_t,
        attr: hipblasLtMatrixLayoutAttribute_t,
        buf: *mut ::libc::c_void,
        sizeInBytes: usize,
        sizeWritten: *mut usize,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\ingroup library_module\n  \\brief Create a matrix multiply descriptor\n\n  \\details\n  This function creates a matrix multiply descriptor by allocating the memory\n needed to hold its opaque structure.\n\n  @param[out]\n  matmulDesc  Pointer to the structure holding the matrix multiply descriptor\n created by this function. See \\ref hipblasLtMatmulDesc_t .\n  @param[in]\n  computeType  Enumerant that specifies the data precision for the matrix\n multiply descriptor this function creates. See hipblasComputeType_t .\n  @param[in]\n  scaleType  Enumerant that specifies the data precision for the matrix\n transform descriptor this function creates. See hipDataType.\n\n  \\retval HIPBLAS_STATUS_SUCCESS If the descriptor was created successfully.\n  \\retval HIPBLAS_STATUS_ALLOC_FAILED If the memory could not be allocated."]
    pub fn hipblasLtMatmulDescCreate(
        matmulDesc: *mut hipblasLtMatmulDesc_t,
        computeType: hipblasComputeType_t,
        scaleType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\ingroup library_module\n  \\brief Destory a matrix multiply descriptor\n\n  \\details\n  This function destroys a previously created matrix multiply descriptor\n object.\n\n  @param[in]\n  matmulDesc  Pointer to the structure holding the matrix multiply descriptor\n that should be destroyed by this function. See \\ref hipblasLtMatmulDesc_t .\n\n  \\retval HIPBLAS_STATUS_SUCCESS If operation was successful."]
    pub fn hipblasLtMatmulDescDestroy(matmulDesc: hipblasLtMatmulDesc_t) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\ingroup library_module\n  \\brief  Set attribute to a matrix multiply descriptor\n\n  \\details\n  This function sets the value of the specified attribute belonging to a\n previously created matrix multiply descriptor.\n\n  @param[in]\n  matmulDesc  Pointer to the previously created structure holding the matrix\n multiply descriptor queried by this function. See \\ref hipblasLtMatmulDesc_t.\n  @param[in]\n  attr  \tThe attribute that will be set by this function. See \\ref\n hipblasLtMatmulDescAttributes_t.\n  @param[in]\n  buf  The value to which the specified attribute should be set.\n  @param[in]\n  sizeInBytes Size of buf buffer (in bytes) for verification.\n\n  \\retval HIPBLAS_STATUS_SUCCESS If the attribute was set successfully..\n  \\retval HIPBLAS_STATUS_INVALID_VALUE If \\p buf is NULL or \\p sizeInBytes\n doesn't match the size of the internal storage for the selected attribute."]
    pub fn hipblasLtMatmulDescSetAttribute(
        matmulDesc: hipblasLtMatmulDesc_t,
        attr: hipblasLtMatmulDescAttributes_t,
        buf: *const ::libc::c_void,
        sizeInBytes: usize,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\ingroup library_module\n  \\brief Query attribute from a matrix multiply descriptor\n\n  \\details\n  This function returns the value of the queried attribute belonging to a\n previously created matrix multiply descriptor.\n\n  @param[in]\n  matmulDesc  Pointer to the previously created structure holding the matrix\n multiply descriptor queried by this function. See \\ref hipblasLtMatmulDesc_t.\n  @param[in]\n  attr  \t    The attribute that will be retrieved by this function. See\n \\ref hipblasLtMatmulDescAttributes_t.\n  @param[out]\n  buf         Memory address containing the attribute value retrieved by this\n function.\n  @param[in]\n  sizeInBytes Size of \\p buf buffer (in bytes) for verification.\n  @param[out]\n  sizeWritten Valid only when the return value is HIPBLAS_STATUS_SUCCESS. If\n sizeInBytes is non-zero: then sizeWritten is the number of bytes actually\n written; if sizeInBytes is 0: then sizeWritten is the number of bytes needed\n to write full contents.\n\n  \\retval HIPBLAS_STATUS_SUCCESS       If attribute's value was successfully\n written to user memory. \\retval HIPBLAS_STATUS_INVALID_VALUE If \\p\n sizeInBytes is 0 and \\p sizeWritten is NULL, or if \\p sizeInBytes is non-zero\n and \\p buf is NULL, or \\p sizeInBytes doesn't match size of internal storage\n for the selected attribute."]
    pub fn hipblasLtMatmulDescGetAttribute(
        matmulDesc: hipblasLtMatmulDesc_t,
        attr: hipblasLtMatmulDescAttributes_t,
        buf: *mut ::libc::c_void,
        sizeInBytes: usize,
        sizeWritten: *mut usize,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\ingroup library_module\n  \\brief Create a preference descriptor\n\n  \\details\n  This function creates a matrix multiply heuristic search preferences\n descriptor by allocating the memory needed to hold its opaque structure.\n\n  @param[out]\n  pref  Pointer to the structure holding the matrix multiply preferences\n descriptor created by this function. see \\ref hipblasLtMatmulPreference_t .\n\n  \\retval HIPBLAS_STATUS_SUCCESS         If the descriptor was created\n successfully. \\retval HIPBLAS_STATUS_ALLOC_FAILED    If memory could not be\n allocated."]
    pub fn hipblasLtMatmulPreferenceCreate(
        pref: *mut hipblasLtMatmulPreference_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\ingroup library_module\n  \\brief Destory a preferences descriptor\n\n  \\details\n  This function destroys a previously created matrix multiply preferences\n descriptor object.\n\n  @param[in]\n  pref  Pointer to the structure holding the matrix multiply preferences\n descriptor that should be destroyed by this function. See \\ref\n hipblasLtMatmulPreference_t .\n\n  \\retval HIPBLAS_STATUS_SUCCESS If operation was successful."]
    pub fn hipblasLtMatmulPreferenceDestroy(pref: hipblasLtMatmulPreference_t) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\ingroup library_module\n  \\brief Set attribute to a preference descriptor\n\n  \\details\n  This function sets the value of the specified attribute belonging to a\n previously created matrix multiply preferences descriptor.\n\n  @param[in]\n  pref        Pointer to the previously created structure holding the matrix\n multiply preferences descriptor queried by this function. See \\ref\n hipblasLtMatmulPreference_t\n  @param[in]\n  attr  \t    The attribute that will be set by this function. See \\ref\n hipblasLtMatmulPreferenceAttributes_t.\n  @param[in]\n  buf         The value to which the specified attribute should be set.\n  @param[in]\n  sizeInBytes Size of \\p buf buffer (in bytes) for verification.\n\n  \\retval HIPBLAS_STATUS_SUCCESS If the attribute was set successfully..\n  \\retval HIPBLAS_STATUS_INVALID_VALUE If \\p buf is NULL or \\p sizeInBytes\n doesn't match the size of the internal storage for the selected attribute."]
    pub fn hipblasLtMatmulPreferenceSetAttribute(
        pref: hipblasLtMatmulPreference_t,
        attr: hipblasLtMatmulPreferenceAttributes_t,
        buf: *const ::libc::c_void,
        sizeInBytes: usize,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\ingroup library_module\n  \\brief Query attribute from a preference descriptor\n\n  \\details\n  This function returns the value of the queried attribute belonging to a\n previously created matrix multiply heuristic search preferences descriptor.\n\n  @param[in]\n  pref        Pointer to the previously created structure holding the matrix\n multiply heuristic search preferences descriptor queried by this function.\n See \\ref hipblasLtMatmulPreference_t.\n  @param[in]\n  attr  \t    The attribute that will be retrieved by this function. See\n \\ref hipblasLtMatmulPreferenceAttributes_t.\n  @param[out]\n  buf         Memory address containing the attribute value retrieved by this\n function.\n  @param[in]\n  sizeInBytes Size of \\p buf buffer (in bytes) for verification.\n  @param[out]\n  sizeWritten Valid only when the return value is HIPBLAS_STATUS_SUCCESS. If\n sizeInBytes is non-zero: then sizeWritten is the number of bytes actually\n written; if sizeInBytes is 0: then sizeWritten is the number of bytes needed\n to write full contents.\n\n  \\retval HIPBLAS_STATUS_SUCCESS       If attribute's value was successfully\n written to user memory. \\retval HIPBLAS_STATUS_INVALID_VALUE If \\p\n sizeInBytes is 0 and \\p sizeWritten is NULL, or if \\p sizeInBytes is non-zero\n and \\p buf is NULL, or \\p sizeInBytes doesn't match size of internal storage\n for the selected attribute."]
    pub fn hipblasLtMatmulPreferenceGetAttribute(
        pref: hipblasLtMatmulPreference_t,
        attr: hipblasLtMatmulPreferenceAttributes_t,
        buf: *mut ::libc::c_void,
        sizeInBytes: usize,
        sizeWritten: *mut usize,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\ingroup library_module\n  \\brief Retrieve the possible algorithms\n\n  \\details\n  This function retrieves the possible algorithms for the matrix multiply\n operation hipblasLtMatmul() function with the given input matrices A, B and\n C, and the output matrix D. The output is placed in heuristicResultsArray[]\n in the order of increasing estimated compute time. Note that the wall duration\n increases if the requestedAlgoCount increases.\n\n  @param[in]\n  handle                  Pointer to the allocated hipBLASLt handle for the\n hipBLASLt context. See \\ref hipblasLtHandle_t .\n  @param[in]\n  matmulDesc              Handle to a previously created matrix multiplication\n descriptor of type \\ref hipblasLtMatmulDesc_t .\n  @param[in]\n  Adesc,Bdesc,Cdesc,Ddesc Handles to the previously created matrix layout\n descriptors of the type \\ref hipblasLtMatrixLayout_t .\n  @param[in]\n  pref                    Pointer to the structure holding the heuristic\n search preferences descriptor. See \\ref hipblasLtMatmulPreference_t .\n  @param[in]\n  requestedAlgoCount      Size of the \\p heuristicResultsArray (in elements).\n This is the requested maximum number of algorithms to return.\n  @param[out]\n  heuristicResultsArray[] Array containing the algorithm heuristics and\n associated runtime characteristics, returned by this function, in the order\n of increasing estimated compute time.\n  @param[out]\n  returnAlgoCount         Number of algorithms returned by this function. This\n is the number of \\p heuristicResultsArray elements written.\n\n  \\retval HIPBLAS_STATUS_SUCCESS           If query was successful. Inspect\n heuristicResultsArray[0 to (returnAlgoCount -1)].state for the status of the\n results. \\retval HIPBLAS_STATUS_NOT_SUPPORTED     If no heuristic function\n available for current configuration. \\retval HIPBLAS_STATUS_INVALID_VALUE If\n \\p requestedAlgoCount is less or equal to zero."]
    pub fn hipblasLtMatmulAlgoGetHeuristic(
        handle: hipblasLtHandle_t,
        matmulDesc: hipblasLtMatmulDesc_t,
        Adesc: hipblasLtMatrixLayout_t,
        Bdesc: hipblasLtMatrixLayout_t,
        Cdesc: hipblasLtMatrixLayout_t,
        Ddesc: hipblasLtMatrixLayout_t,
        pref: hipblasLtMatmulPreference_t,
        requestedAlgoCount: ::libc::c_int,
        heuristicResultsArray: *mut hipblasLtMatmulHeuristicResult_t,
        returnAlgoCount: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\ingroup library_module\n  \\brief Retrieve the possible algorithms\n\n  \\details\n  This function computes the matrix multiplication of matrices A and B to\n produce the output matrix D, according to the following operation: \\p D = \\p\n alpha*( \\p A *\\p B) + \\p beta*( \\p C ), where \\p A, \\p B, and \\p C are input\n matrices, and \\p alpha and \\p beta are input scalars. Note: This function\n supports both in-place matrix multiplication (C == D and Cdesc == Ddesc) and\n out-of-place matrix multiplication (C != D, both matrices must have the same\n data type, number of rows, number of columns, batch size, and memory order).\n In the out-of-place case, the leading dimension of C can be different from\n the leading dimension of D. Specifically the leading dimension of C can be 0\n to achieve row or column broadcast. If Cdesc is omitted, this function\n assumes it to be equal to Ddesc.\n\n  @param[in]\n  handle                  Pointer to the allocated hipBLASLt handle for the\n hipBLASLt context. See \\ref hipblasLtHandle_t .\n  @param[in]\n  matmulDesc              Handle to a previously created matrix multiplication\n descriptor of type \\ref hipblasLtMatmulDesc_t .\n  @param[in]\n  alpha,beta              Pointers to the scalars used in the multiplication.\n  @param[in]\n  Adesc,Bdesc,Cdesc,Ddesc Handles to the previously created matrix layout\n descriptors of the type \\ref hipblasLtMatrixLayout_t .\n  @param[in]\n  A,B,C                   Pointers to the GPU memory associated with the\n corresponding descriptors \\p Adesc, \\p Bdesc and \\p Cdesc .\n  @param[out]\n  D                       Pointer to the GPU memory associated with the\n descriptor \\p Ddesc .\n  @param[in]\n  algo                    Handle for matrix multiplication algorithm to be\n used. See \\ref hipblasLtMatmulAlgo_t . When NULL, an implicit heuristics query\n with default search preferences will be performed to determine actual\n algorithm to use.\n  @param[in]\n  workspace               Pointer to the workspace buffer allocated in the GPU\n memory. Pointer must be 16B aligned (that is, lowest 4 bits of address must\n be 0).\n  @param[in]\n  workspaceSizeInBytes    Size of the workspace.\n  @param[in]\n  stream                  The HIP stream where all the GPU work will be\n submitted.\n\n  \\retval HIPBLAS_STATUS_SUCCESS           If the operation completed\n successfully. \\retval HIPBLAS_STATUS_EXECUTION_FAILED  If HIP reported an\n execution error from the device. \\retval HIPBLAS_STATUS_ARCH_MISMATCH     If\n the configured operation cannot be run using the selected device. \\retval\n HIPBLAS_STATUS_NOT_SUPPORTED     If the current implementation on the\n selected device doesn't support the configured operation. \\retval\n HIPBLAS_STATUS_INVALID_VALUE     If the parameters are unexpectedly NULL, in\n conflict or in an impossible configuration. For example, when\n workspaceSizeInBytes is less than workspace required by the configured algo.\n  \\retval HIBLAS_STATUS_NOT_INITIALIZED    If hipBLASLt handle has not been\n initialized."]
    pub fn hipblasLtMatmul(
        handle: hipblasLtHandle_t,
        matmulDesc: hipblasLtMatmulDesc_t,
        alpha: *const ::libc::c_void,
        A: *const ::libc::c_void,
        Adesc: hipblasLtMatrixLayout_t,
        B: *const ::libc::c_void,
        Bdesc: hipblasLtMatrixLayout_t,
        beta: *const ::libc::c_void,
        C: *const ::libc::c_void,
        Cdesc: hipblasLtMatrixLayout_t,
        D: *mut ::libc::c_void,
        Ddesc: hipblasLtMatrixLayout_t,
        algo: *const hipblasLtMatmulAlgo_t,
        workspace: *mut ::libc::c_void,
        workspaceSizeInBytes: usize,
        stream: hipStream_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " Create new matrix transform operation descriptor.\n\n \\retval     HIPBLAS_STATUS_ALLOC_FAILED  if memory could not be allocated\n \\retval     HIPBLAS_STATUS_SUCCESS       if desciptor was created successfully"]
    pub fn hipblasLtMatrixTransformDescCreate(
        transformDesc: *mut hipblasLtMatrixTransformDesc_t,
        scaleType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " Destroy matrix transform operation descriptor.\n\n \\retval     HIPBLAS_STATUS_SUCCESS  if operation was successful"]
    pub fn hipblasLtMatrixTransformDescDestroy(
        transformDesc: hipblasLtMatrixTransformDesc_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " Set matrix transform operation descriptor attribute.\n\n \\param[in]  transformDesc  The descriptor\n \\param[in]  attr           The attribute\n \\param[in]  buf            memory address containing the new value\n \\param[in]  sizeInBytes    size of buf buffer for verification (in bytes)\n\n \\retval     HIPBLAS_STATUS_INVALID_VALUE  if buf is NULL or sizeInBytes doesn't match size of internal storage for\n                                          selected attribute\n \\retval     HIPBLAS_STATUS_SUCCESS        if attribute was set successfully"]
    pub fn hipblasLtMatrixTransformDescSetAttribute(
        transformDesc: hipblasLtMatrixTransformDesc_t,
        attr: hipblasLtMatrixTransformDescAttributes_t,
        buf: *const ::libc::c_void,
        sizeInBytes: usize,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\ingroup library_module\n  \\brief Matrix transform operation getter\n  \\details Get matrix transform operation descriptor attribute.\n\n @param[in]  transformDesc  The descriptor\n @param[in]  attr           The attribute\n @param[out] buf            memory address containing the new value\n @param[in]  sizeInBytes    size of buf buffer for verification (in bytes)\n @param[out] sizeWritten    only valid when return value is HIPBLAS_STATUS_SUCCESS. If sizeInBytes is non-zero: number\n of bytes actually written, if sizeInBytes is 0: number of bytes needed to write full contents\n\n \\retval HIPBLAS_STATUS_INVALID_VALUE  if sizeInBytes is 0 and sizeWritten is NULL, or if  sizeInBytes is non-zero\n                                          and buf is NULL or sizeInBytes doesn't match size of internal storage for\n                                          selected attribute\n \\retval HIPBLAS_STATUS_SUCCESS        if attribute's value was successfully written to user memory"]
    pub fn hipblasLtMatrixTransformDescGetAttribute(
        transformDesc: hipblasLtMatrixTransformDesc_t,
        attr: hipblasLtMatrixTransformDescAttributes_t,
        buf: *mut ::libc::c_void,
        sizeInBytes: usize,
        sizeWritten: *mut usize,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\ingroup library_module\n  \\brief Matrix layout conversion helper\n  \\details\n   Matrix layout conversion helper (C = alpha * op(A) + beta * op(B)),\n can be used to change memory order of data or to scale and shift the values.\n @param[in]  lightHandle   Pointer to the allocated hipBLASLt handle for the\n hipBLASLt context. See \\ref hipblasLtHandle_t .\n @param[in]  transformDesc Pointer to allocated matrix transform descriptor.\n @param[in]  alpha         Pointer to scalar alpha, either pointer to host or device address.\n @param[in]  A             Pointer to matrix A, must be pointer to device address.\n @param[in]  Adesc         Pointer to layout for input matrix A.\n @param[in]  beta          Pointer to scalar beta, either pointer to host or device address.\n @param[in]  B             Pointer to layout for matrix B, must be pointer to device address\n @param[in]  Bdesc         Pointer to layout for inputmatrix B.\n @param[in]  C             Pointer to matrix C, must be pointer to device address\n @param[out] Cdesc         Pointer to layout for output matrix C.\n @param[in] stream         The HIP stream where all the GPU work will be submitted.\n\n \\retval HIPBLAS_STATUS_NOT_INITIALIZED   if hipBLASLt handle has not been initialized\n \\retval HIPBLAS_STATUS_INVALID_VALUE     if parameters are in conflict or in an impossible configuration; e.g.\n                                              when A is not NULL, but Adesc is NULL\n \\retval HIPBLAS_STATUS_NOT_SUPPORTED     if current implementation on selected device doesn't support configured\n                                              operation\n \\retval HIPBLAS_STATUS_ARCH_MISMATCH     if configured operation cannot be run using selected device\n \\retval HIPBLAS_STATUS_EXECUTION_FAILED  if HIP reported execution error from the device\n \\retval HIPBLAS_STATUS_SUCCESS           if the operation completed successfully"]
    pub fn hipblasLtMatrixTransform(
        lightHandle: hipblasLtHandle_t,
        transformDesc: hipblasLtMatrixTransformDesc_t,
        alpha: *const ::libc::c_void,
        A: *const ::libc::c_void,
        Adesc: hipblasLtMatrixLayout_t,
        beta: *const ::libc::c_void,
        B: *const ::libc::c_void,
        Bdesc: hipblasLtMatrixLayout_t,
        C: *mut ::libc::c_void,
        Cdesc: hipblasLtMatrixLayout_t,
        stream: hipStream_t,
    ) -> hipblasStatus_t;
}
